<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="categories-C++"><meta name="description" content="C++ 游戏服务器知识点零散记录"><meta name="author" content="beyondhxl"><title>C++游戏服务器知识点散记 - 宇宙の騎士</title><meta description="C++ 游戏服务器知识点零散记录"><meta property="og:type" content="article"><meta property="og:title" content="C++游戏服务器知识点散记"><meta property="og:url" content="https://www.beyondhxl.com/post/70ae5d6.html"><meta property="og:site_name" content="宇宙の騎士"><meta property="og:description" content="C++ 游戏服务器知识点零散记录"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%AE%AB%E5%B4%8E%E9%AA%8F/%E9%BE%99%E7%8C%AB/ChMkJ1bKweuIAUBlAAJtrunlO0AAALGgABCVwEAAm3G541.jpg"><meta property="article:published_time" content="2020-06-20T01:34:03.000Z"><meta property="article:modified_time" content="2024-08-02T20:36:09.804Z"><meta property="article:author" content="beyondhxl"><meta property="article:tag" content="categories-C++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%AE%AB%E5%B4%8E%E9%AA%8F/%E9%BE%99%E7%8C%AB/ChMkJ1bKweuIAUBlAAJtrunlO0AAALGgABCVwEAAm3G541.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.beyondhxl.com/post/70ae5d6.html"},"headline":"C++游戏服务器知识点散记","image":["https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%AE%AB%E5%B4%8E%E9%AA%8F/%E9%BE%99%E7%8C%AB/ChMkJ1bKweuIAUBlAAJtrunlO0AAALGgABCVwEAAm3G541.jpg"],"datePublished":"2020-06-20T01:34:03.000Z","dateModified":"2024-08-02T20:36:09.804Z","author":{"@type":"Person","name":"beyondhxl"},"description":"C++ 游戏服务器知识点零散记录"}</script><link rel="alternative" href="/atom.xml" title="宇宙の騎士" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/logo1.png" alt="宇宙の騎士" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">专辑</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">说说</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/steamgames">Steam</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%AE%AB%E5%B4%8E%E9%AA%8F/%E9%BE%99%E7%8C%AB/ChMkJ1bKweuIAUBlAAJtrunlO0AAALGgABCVwEAAm3G541.jpg" alt="C++游戏服务器知识点散记"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><div style="color: #3273dc;font-size: 1.8rem;"><i class="fas fa-arrow-alt-circle-up"></i> </div><i class="far fa-calendar-plus"> </i>2020-06-20  <a class="commentCountImg" href="/post/70ae5d6.html#comment-container"><span class="display-none-class">892333c0078af8fc79d32c584033eaa1</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="892333c0078af8fc79d32c584033eaa1">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>14 分钟  <i class="fas fa-pencil-alt"> </i>2.1 k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">C++游戏服务器知识点散记</h1><div class="content"><blockquote>
<p>C++ 游戏服务器知识点零散记录</p>
</blockquote>
<a id="more"></a>



<h3 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h3><p>1、声明为 static 的对象<br>2、global scope<br>3、namespace scope</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>非自然多态 unnatural polymorphism</strong></p>
<p>对象涉及多重继承或虚拟继承的基类，会拥有多个地址</p>
<p><strong>C++ 以下列方法支持多态:</strong></p>
<p>1、隐式的转化<br>把一个 derived class 指针转化为一个指向其 public base type 的指针<br>2、经由 virtual function 机制<br>3、经由 dynamic-cast 和 typeid 运算法</p>
<p><strong>多态的主要用途</strong></p>
<p>经由一个共同的接口来影响类型的封装，这个接口通常被定义在一个抽象的 base class 中。这个接口是以 virtual function 机制引发的，它可以在执行期根据 object 的真正类型解析出到底是哪一个函数实体被调用。</p>
<p><strong>抽象混合式基类 abstract base class</strong></p>
<p>不能被实例化的 base class 至少有一个纯虚函数</p>
<h3 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h3><p>1、dynamic_cast 只适用于那种”所指对象至少有一个虚函数”</p>
<h3 id="C-隐式类型转换和关键字-explicit"><a href="#C-隐式类型转换和关键字-explicit" class="headerlink" title="C++ 隐式类型转换和关键字 explicit"></a>C++ 隐式类型转换和关键字 explicit</h3><p>1、explicit 制止单一参数的 constructor 被当做一个 conversion 运算符<br>2、conversion 运算符即类型转换运算符，这是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型，一般形式为：operator type() const，其中 type 表示被转换成的某种类型。<br>3、《C++ Primer》中讲到了一个规定：如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（关键字 explicit 出现的原因就是在 C++ 这个规定的基础上）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Test(<span class="keyword">int</span> num);</span><br><span class="line">&#125;</span><br><span class="line">Test obj = <span class="number">10</span>； <span class="comment">// 编译器自动将整型“隐式转换”为Test类对象</span></span><br><span class="line">                <span class="comment">// 在这种情况下，该语句等同于 Test temp(10); Test obj = temp;</span></span><br><span class="line">隐式类型转换中，编译器只会自动地执行一步类型转换（只允许一步类类型转换）。</span><br><span class="line"></span><br><span class="line">我们可以通过将构造函数声明为 <span class="keyword">explicit</span> 从而抑制构造函数定义的隐式转换。</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">explicit</span> Test(<span class="keyword">int</span> num);</span><br><span class="line">&#125;</span><br><span class="line">Test obj = <span class="number">10</span>;  <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p><code>explicit</code> 构造函数只能用于直接初始化，不能用于拷贝形式的初始化过程。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Java 生成的是字节码，没有链接的过程。比如修改一个函数，Java 添加完成，可以直接启动测试，但是 C++ 可能会因为一行代码的修改，导致无数 cpp 文件的编译。</p>
<p><strong>为什么 C/C++ 要分为头文件和源文件？</strong></p>
<p>因为编译出来的二进制码（比如 .o、.obj、.lib、.dll）不包含自我描述的信息，要复用这种可行码的话得另外的文件。C# 和 Java 的可执行码自带元数据信息，但是这也意味着运行时的内存需求增加，毕竟自我描述的数据对最终用户来说是无用的。</p>
<p><strong><strong>cdecl、</strong>stdcall、<strong>fastcall、</strong>pascal</strong></p>
<p>__cdecl 是 C Declaration 的缩写（declaration 声明），表示 C 语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</p>
<p>__stdcall 调用规则使得被调用者来执行清栈操作（由被调用者函数自身将 ESP 拉高以维持堆栈平衡）</p>
<p>__fastcall 调用规则使得被调用者负责清理栈的操作（由被调用者函数自身将 ESP 拉高以维持堆栈平衡）</p>
<p>__pascal 则是从左到右依次入栈。并且，被调用者（函数自身）将自行完成清栈操作</p>
<table>
<thead>
<tr>
<th align="center">调用规则</th>
<th align="center">入栈顺序</th>
<th align="center">清栈责任</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__cdecl</td>
<td align="center">从右到左</td>
<td align="center">调用者</td>
</tr>
<tr>
<td align="center">__stdcall</td>
<td align="center">从右到左</td>
<td align="center">被调用者</td>
</tr>
<tr>
<td align="center">__fastcall</td>
<td align="center">从右到左（先 EDX、ECX，再到堆栈）</td>
<td align="center">被调用者</td>
</tr>
<tr>
<td align="center">__pascal</td>
<td align="center">从左到右</td>
<td align="center">被调用者</td>
</tr>
</tbody></table>
<h3 id="GatewayServer"><a href="#GatewayServer" class="headerlink" title="GatewayServer"></a>GatewayServer</h3><p>也称之为连接服务器，网络游戏的客户端一般是连接到这里，然后再由该连接服务器根据不同的需要，把游戏消息转发给其它相应的服务器（逻辑和地图服务器）。也因为它是客户端直接连接的对象，它同时也承担了验证客户身份的工作。</p>
<p><strong>Q&amp;&amp;A</strong><br>1、Gateway 上的客户端连接类有多个连接的原因？<br>2、Scene 只有一个 SessionClient？</p>
<p><strong>游戏网关服务器GatewayServer的作用</strong>：</p>
<ol>
<li>游戏网关服务器可以作为客户端与 game server 的隔离作用</li>
<li>消息解析</li>
<li>与客户端保持连接，作为广播作用</li>
<li>消息合法性验证</li>
<li>转发消息到业务服务，针对不同的客户端消息分发到相应的服务处理</li>
<li>流量限制，消息分流作用</li>
<li>版本验证等</li>
<li>可扩展性、动态拓展</li>
</ol>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>1、技术 : Techniques<br>2、Idioms : 习语<br>3、Patterns : 模式<br>4、stumble[<code>st^mbl</code>] : 蹒跚、结巴、失足、绊脚、过失<br>5、aggregation[ˌæɡrɪˈɡeɪʃn] 聚集、集合、聚集体；集合体；聚合作用；凝聚；聚集作用；总量；<br>6、reconcile[ˈrekənsaɪl] 使和谐一致; 调和; 使配合; 使和解; 使和好如初; 将就; 妥协;<br>7、reduction[rɪˈdʌkʃn] 减少; 缩小; 降低; 减价; 折扣; (照片、地图、图片等的) 缩图，缩版;<br>8、preemptive[priˈɛmptɪv] 先发制人的; 先买的，有先买权的;<br>9、restore[rɪˈstɔː(r)] 恢复(某种情况或感受); 使复原; 使复位; 使复职; 修复; 整修;<br>10、immutable[ɪˈmjuːtəbl] 不可改变的; 永恒不变的;<br>11、stale[steɪl] adj. 不新鲜的; (空气) 污浊的; (烟味) 难闻的; 陈腐的; 没有新意的; 老掉牙的; n.(牛马、骆驼的)尿;<br>12、cancellation[ˌkænsəˈleɪʃn] 取消; 撤销; 被取消了的事物; 作废; 废除; 中止;<br>13、ephemeral[ɪˈfemərəl] 短暂的; 瞬息的;</p>
<h3 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h3><p><strong>条款25 C++ swap 函数</strong></p>
<p>1、标准库 swap 函数<br>定义在 std 命名空间的函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库的 swap 实现调用了拷贝构造函数（对于非内置类型），并且有两次赋值运算，这在很多情况下是不满足我们的效率需求的（大型对象的拷贝是毫无必要的操作，我们仅需要交换指针，若存在容器类型，调用容器类的 swap 明显是更加正确的操作）。在 C++11 中，我们有如下的优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;</span><br><span class="line">    a = <span class="built_in">std</span>::move(b);</span><br><span class="line">    b = <span class="built_in">std</span>::move(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移动方式的本质就是移交临时对象对资源的控制权，通常就是指针的替换，因此上述操作对存在移动构造和移动赋值运算的类来讲，已经可以基本满足要求，但是，对于未定义上述操作的类来讲，改进版本的 swap 操作并未有任何效率上的提升，因此，有必要定义类类型的 swap。</p>
<p>2、copy and swap 中的 swap 操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">            swap(<span class="keyword">this</span>-&gt;a, rhs.a);   <span class="comment">// 我们简单地交换了指针</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述操作并没有解决问题，我们希望能够像调用普通 swap 函数操作一样调用 swap(A&amp; a, A&amp; b)，因此，我们下一步的操作就是在 std 命名空间内特化 swap 版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;A&gt;(A&amp; a, A&amp; b) &#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 std 空间内的特化版本满足 C++ 标准的规定，这种扩充操作使得我们的特化版本对包含了 std 空间的文件都处于可见状态，因此，我们可以像以前一样使用 swap 进行交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">A a, b;</span><br><span class="line">swap(a, b);</span><br></pre></td></tr></table></figure>
<p>我们知道，C++ 允许对类模板全特化，但是对函数模板不允许全特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 以下定义不允许！</span></span><br><span class="line"><span class="keyword">void</span> swap&lt;A&lt;T&gt;&gt; (A&lt;T&gt;&amp; a, A&lt;T&gt;&amp; b) &#123;</span><br><span class="line">    a.swap(b);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，std 内对 swap 的重载也不符合规定，我们的解决方案就是，在自定义的命名空间内定义 swap 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Astuff &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&lt;T&gt;&amp; a, A&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，我们在当前的命名空间内就拥有了 swap 的完整定义，那么为什么在使用时要加 using std::swap 呢？这句声明会使 std 命名空间的 swap 暴露出来，编译器会自动在当前命名空间和 std 空间内寻找最符合当前函数调用的 swap 版本，因此，以下的写法完全错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a, b;</span><br><span class="line"><span class="built_in">std</span>::swap(a, b);</span><br></pre></td></tr></table></figure>
<p>这种写法直接调用了 std 空间内的 swap 函数，因此并不符合大多数情况下的需求，using 版本才是最准确的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">swap(a, b);</span><br></pre></td></tr></table></figure>

<h3 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h3><p><strong>条款25：将 constructor 和 non-member function 虚化</strong><br>1、virtual constructor 是某种函数，视其获得的输入，可产生不同类型的对象。<br>2、copy-on-write 写入时才复制<br>3、子类写父类的函数时，虚函数的返回值可以与父类的不一样，子类返回一个引用或者指针。</p>
<h3 id="结构体-Struct"><a href="#结构体-Struct" class="headerlink" title="结构体 Struct"></a>结构体 Struct</h3><p>1、C 中的 Struct 一个用途<br>一个复杂的 class object 的全部或部分到某个 C 函数去时，可以将数据封装起来。并保证拥有与 C 兼容的空间布局。</p>
<p>2、把单一元素的数组放在一个 struct 的尾端。每个 struct object 可以拥有可变大小的数组。(柔性数组)</p>
<h4 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h4><p>要判断一个结构体所占的空间大小，大体来说分三步走：</p>
<ol>
<li>先确定实际对齐单位，其由以下三个因素决定<br>(1) cpu 周期<br>win、vs、qt 默认8字节对齐，linux 32位，默认4字节对齐，linux 64位默认8字节对齐。<br>(2) 结构体最大成员(基本数据类型变量)<br>(3) 预编译指令 #pragma pack(n) 手动设置（n 只能填1 2 4 8 16）<br>上面三者取最小的。</li>
<li>除结构体的第一个成员外，其他所有的成员的地址相对于结构体地址（即它首个成员的地址）的偏移量必须为实际对齐单位或自身大小的整数倍（取两者中小的那个）</li>
<li>结构体的整体大小必须为实际对齐单位的整数倍</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">nums</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    short b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(nums));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 nums 中，没有手动设置对齐单位，linux 64位系统的默认对齐单位是8字节，结构体 nums 的最大成员 double d 占8个字节，故实际对齐字节是二者最小，即8字节。</p>
<p>char a 放在结构体的起始地址;</p>
<p>short b 占2个字节，2小于实际对齐字节8，故 b 的起始地址相对于 a 的起始地址的偏移量必须为2的整数倍个字节;</p>
<p>int c 占4个字节，4小于实际对齐字节8，故 c 起始地址相对于 a 的起始地址的偏移量必须为4的整数倍个字节；</p>
<p>double d 占8个字节，8与实际对齐字节8相等，故 d 的起始地址相对于 a 的起始地址的偏移量须为8的整数倍个字节；</p>
<p>所以 nums 所占空间如下：1(a)+1(浪费的空间，由 b 的起始地址决定这1字节必须腾出)+2(b)+4(c)+8(d)=16个字节</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-9-ubuntu:~$ ./stru </span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<p>在结构体最后添加一个 char 数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">nums</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    short b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">13</span>];</span><br><span class="line">&#125;nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(nums));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的类型是 char[13]，并不是基本数据类型，这里仍然当做13个 char 型变量来处理，char 占1个字节，小于实际对齐字节8，所以这13个 char 型变量可以直接挨着 double d 后面放（最后结果看起来也就相当于整个数组挨着 double d 放置）。所以总的空间情况是：1(a)+1(浪费空间)+2(b)+4(c)+8(d)+13(arr)=29，但29并不满足上面三步走的最后一步：“整个结构体的大小必须是实际对齐单位的整数倍”，所以29+3(浪费空间)=32，所以最后nums 的空间情况是：1(a)+1(浪费空间)+2(b)+4(c)+8(d)+13(arr)+3(浪费空间)=32字节。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-9-ubuntu:~$ ./stru</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<p>结构体嵌套结构体的字节对齐和上面原理一样，唯一要注意的是子结构体的起始地址与母结构体的起地址之间的距离必须是子结构体最大成员或者实际对齐单位（还是取两者小的那个）的整数倍。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> b;     <span class="comment">// 2</span></span><br><span class="line">    short c;    <span class="comment">// 2</span></span><br><span class="line">&#125;parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">child</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;     <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">int</span> b;      <span class="comment">// 4</span></span><br><span class="line">    parent p;   <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">long</span> c;     <span class="comment">// 8</span></span><br><span class="line">&#125;child;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent:%ld\n child:%ld\n"</span>, <span class="keyword">sizeof</span>(parent), <span class="keyword">sizeof</span>(child));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-9-ubuntu:~$ ./stru</span><br><span class="line">parent:8</span><br><span class="line">child:24</span><br></pre></td></tr></table></figure>

<p>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的 CPU 在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个 int 型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这 32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<p><strong>结构体内部存在 static 类型的变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> a; </span><br><span class="line">    <span class="keyword">long</span> b; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> c; <span class="comment">//静态 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态变量存放在全局数据区内，而 sizeof 计算栈中分配的空间的大小，故不计算在内，S4 的大小为 4+4=8。<br>（在自然对齐的结构体中，在 32 位系统内，对于某一个成员变量，如果前面的变量所占空间比自身小，那么前面的空间填充为满 4 字节，使得这个成员的地址从 4 字节整数倍开始，最后结构体的总体字节调整为 4 字节的整数倍即可）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    short  b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">char</span> e;</span><br><span class="line">    <span class="comment">// char f;</span></span><br><span class="line">    <span class="comment">// char g;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sizeof(struct test) = 20。如果将最后两行注释去掉，仍然是 20 字节。规则是这样的，假设从 0x00000000 地址开始存储成员，那么 a 偏移为 1，但是 b 必须从 2 的地址开始，那么 a 就必须填充一个字节，那么 a、b 共占用 4 个字节，c 需要从 4 字节的整数倍开始，现在正好，上述不用填充，d 也从可以被 4 整除的字节数开始存储（现在正好，其实也是 8 字节的整数倍，这是凑巧了），连续填充 8 个字节，现在变成 0x0000010（16 进制），那么 e 的地址为 0x00000011，但是整个结构体的大小不是 4 字节的整数倍，最后需要填充 3 个字节，整体是 0x00000014，如果将最后两行注释去掉，那么仍然是 20 字节，需要填充的就是 g，填充 1 个字节。</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p><strong>C++ 支持三种范式：</strong><br>1、程序模型(procedural model)<br>2、抽象数据类型模型(abstract data type model ADT)<br>3、面向对象模型(object-oriented model)</p>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>1、一个 inline 函数有静态链接、不会被文件以外者看到。<br>2、每一个 non-inline member function 只会诞生一个函数实例。</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL find 函数用类指针的一个原因是可以应用到链表的 next</p>
<h4 id="1、lower-bound-和-upper-bound-实现"><a href="#1、lower-bound-和-upper-bound-实现" class="headerlink" title="1、lower_bound 和 upper_bound 实现"></a>1、lower_bound 和 upper_bound 实现</h4><p>lower_bound 算法返回第一个大于等于给定值所在的位置。设置两个指针 start 和 last，其中 start 指向数组的起始位置，last 指向数组末尾位置之后的位置。当 start 和 last 指向相同位置时循环结束。mid 指向 [start, last) 区间的中间位置，当中间位置元素值大于等于给定 val 时，说明第一个大于等于 val 值在 mid 位置的左边，更新 last 为 mid。当中间位置元素值小于给定的 val 时，说明第一个大于等于 val 值在 mid 右边，不包括 mid 所在的位置，更新 start 为 mid+1。</p>
<p><strong>1、在从小到大的排序数组中</strong></p>
<p><strong>lower_bound(begin, end, num)</strong></p>
<p>从数组的 begin 位置到 end-1 位置二分查找第一个大于或等于 num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin，得到找到数字在数组中的下标。</p>
<p><strong>upper_bound(begin, end, num)</strong></p>
<p>从数组的 begin 位置到 end-1 位置二分查找第一个大于 num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin，得到找到数字在数组中的下标。</p>
<p><strong>2、在从大到小的排序数组中</strong></p>
<p>重载 lower_bound() 和 upper_bound()</p>
<p><strong>lower_bound(begin, end, num, greater<type>())</strong></p>
<p>从数组的 begin 位置到 end-1 位置二分查找第一个小于或等于 num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin，得到找到数字在数组中的下标。</p>
<p><strong>upper_bound( begin,end,num,greater<type>() )</strong></p>
<p>从数组的 begin 位置到 end-1 位置二分查找第一个小于 num 的数字，找到返回该数字的地址，不存在则返回 end。通过返回的地址减去起始地址 begin，得到找到数字在数组中的下标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) <span class="comment">// equal</span></span><br><span class="line">    &#123;	</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[mid]) </span><br><span class="line">        &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;	<span class="comment">// mid - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>upper_bound 算法返回第一个大于给定元素值所在的位置，设置两个指针 start 和 last，其中 start 指向数组的起始位置，last 指向数组末尾位置之后的位置，当 start 和 last 指向相同位置时循环结束，mid 指向 [start, last) 区间的中间位置，当中间位置元素值小于等于给定 val 时，说明第一个大于 val 值在 mid 位置的右边，更新 start 为 mid+1。当中间位置元素值大于给定元素时，说明第一大于在 mid 左边，包括 mid 所在位置，所以更新 last 为 mid。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) <span class="comment">// equal !!</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[mid]) </span><br><span class="line">        &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;		<span class="comment">// mid - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lower_bound、upper_bound 例子</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>target = 2，则 lower_bound 返回的位置是 第 1 个位置，upper_bound 返回的位置是第 3 个位置。(从第 0 个位置开始)</p>
<p>upper_bound - lower_bound = 数组中 target 的个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">2</span>*<span class="keyword">int</span>(<span class="number">1e9</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">34</span>&#125;; </span><br><span class="line">	sort(num,num+<span class="number">6</span>);                          <span class="comment">//按从小到大排序 </span></span><br><span class="line">	<span class="keyword">int</span> pos1=lower_bound(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于或等于被查数的值 </span></span><br><span class="line">	<span class="keyword">int</span> pos2=upper_bound(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于被查数的值</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos1&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos1]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos2&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	sort(num,num+<span class="number">6</span>,cmd);                      <span class="comment">//按从大到小排序</span></span><br><span class="line">	<span class="keyword">int</span> pos3=lower_bound(num,num+<span class="number">6</span>,<span class="number">7</span>,greater&lt;<span class="keyword">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于或等于被查数的值 </span></span><br><span class="line">	<span class="keyword">int</span> pos4=upper_bound(num,num+<span class="number">6</span>,<span class="number">7</span>,greater&lt;<span class="keyword">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于被查数的值 </span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos3&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos3]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pos4&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos4]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SessionServer"><a href="#SessionServer" class="headerlink" title="SessionServer"></a>SessionServer</h3><p>Session 服务器上有所有的玩家(RelationUser)</p>
<h3 id="游戏服务器中的数据库异步操作技术和游戏数据的保存机制"><a href="#游戏服务器中的数据库异步操作技术和游戏数据的保存机制" class="headerlink" title="游戏服务器中的数据库异步操作技术和游戏数据的保存机制"></a>游戏服务器中的数据库异步操作技术和游戏数据的保存机制</h3><p>1、在游戏服务器中，处理玩家登陆需要向数据库查询玩家的账号和密码，玩家上线和下线需要对玩家的角色数据从数据库中读取和保存。<br>2、为了不阻塞逻辑线程，可以采用异步数据库访问的方式，即数据库操作请求提交给专门的数据库处理线程池，然后逻辑线程不再等待数据库处理结果，继续处理其他，不再阻塞在这里。<br>3、改成数据库异步处理后，为了保障数据安全，我们希望不只是玩家下线的时候才会保存玩家数据，同时也希望每隔一段时间统一保存所有在线玩家的数据，可以考虑这样的思路：假设我们有一个 GAMEDB 服务器，GAMEDB 缓存了所有在线玩家的角色数据，每次到保存时间，GAMEDB 就将所有在线玩家的数据（DBO）的副本都统一提交给 DB 线程池，让它保存数据，提交的过程很快，提交完后，GAMEDB 的逻辑线程仍能继续处理游戏服务器的更新和读取 CACHE 的请求。为什么要保存副本呢，DB 线程的执行保存队列的过程也许很耗时，但是队列中的数据都是 GAMEDB 提交 DBO 那个时刻的数据，这样就能保证玩家的游戏数据的完整性。<br>4、为提高性能，网络游戏服务器程序启动后一般都会把事先需要的数据从数据库提取到内存供使用，以减少读数据库的频率。<br>5、当然，网游开发中，遇到需要立即写库或者更新库的内容时，我们会立即向数据库服务器发送 insert、delete、update 等以期望数据库能立即更新我们的数据，比如玩家切换到新地图，这种数据就有必要立即提交到数据库：</p>
<ol>
<li>写到数据服务(这个数据服务器就是程序中缓存，用来缓存一些所要提交的数据)中，并不直接写库，因为数据库不是你想象的那么高效；</li>
<li>业务服务实时写数据库，数据服务定时存盘，比如5分钟保存一次；</li>
</ol>
<p>6、数据服务中心负责所有数据统一管理，提供实时的数据读写，多服务器环境下数据服务中心的处理能力直接关系到整个集群系统的性能，所有的关键数据库访问都它包装。一般对内存需求会很大，因为有大量数据要在内存缓存。<br>7、一般场景服务器 SceneServer 是没有数据库连接池的，存档的数据，都是通过档案服务器客户端 RecordClient 发送到 RecordServer(DBServer) 上的。</p>
<h3 id="服务器传输层在异步模型下的基本使用序列"><a href="#服务器传输层在异步模型下的基本使用序列" class="headerlink" title="服务器传输层在异步模型下的基本使用序列"></a>服务器传输层在异步模型下的基本使用序列</h3><p>1、在主循环（TimeTick）中，不断尝试读取，看是否有什么数据可读<br>2、如果上一步返回有数据到达了，则读取数据<br>3、读取数据处理后，需要发送数据，则向网络写入数据（写的话，可以先发送到写的缓冲buffer、多缓存一些，然后::send() 出去）<br>网游比较特殊，最大的特点在于客户端和服务器端是要进行长连接的，客户端和服务器端基本上一直要保持连接，不是典型的 Request-Response 模式，Client 会主动给 Server 发送数据，Server 也可能主动往 Client 发送数据，生命周期比较长，一次发送的数据量比较小，但是数据交互发送比较频繁。由于要进行长连接，服务器端的 socket 就不能进行复用，单台服务器处理请求是有限的。</p>
<h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>在编写 C++ 程序的时候，总是设法保证对象的构造和析构是成对出现的。</p>
<p>生命期和程序一样长的对象，直接使用全局对象(或 scope_ptr)或者做成 main() 的栈上对象。有如下发生串话场景：<br>从某个 TCP 连接 A 收到了一个 request，程序开始处理这个 request；处理可能要花一定的时间，为了避免耽误(阻塞)处理其他 request，程序记住了发来 request 的 TCP 连接，在某个线程池中处理这个请求；在处理完之后，会把 response 发回 TCP 连接 A。但是，在处理 request 的过程中，客户端断开了 TCP 连接 A，而另一个客户端刚好创建了新连接 B。程序不能只记住 TCP 连接 A 的文件描述符，而应该持有封装 socket 连接的 TcpConnection 对象，保证在处理 request 期间 TCP 连接 A 的文件描述符不会被关闭。或者持有 TcpConnection 对象的弱引用(week_ptr)，这样能知道 socket 连接在处理 request 期间是否已经关闭了，fd=8 的文件描述符到底是“前世”还是“今生”。</p>
<p>在 C++ 项目中，自己写个 File Class，把项目用到的文件 IO 功能简单封装一下(以 RAII 手法封装 File* 或者 file descriptor 都可以)，通常就能满足需要。记得把拷贝构造和赋值操作符禁用，在析构函数里释放资源，避免泄露内部的 handle。</p>
<p>如果要用 stream 方式做 logging，可以抛开繁重的 iostream，自己写一个简单的 LogStream，重载几个 operate&lt;&lt; 操作符，而且可以用 stack buffer，轻松做到线程安全与高效。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;    <span class="comment">// 调用构造函数</span></span><br><span class="line">    fork();     <span class="comment">// fork 为两个进程</span></span><br><span class="line">    foo.doit(); <span class="comment">// 在父子进程中都使用 foo</span></span><br><span class="line">    <span class="comment">// 析构函数会被调用两次，父进程和子进程各一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork() 之后，子进程继承了父进程的几乎全部状态。子进程会继承地址空间和文件描述符，因此用于管理动态内存和文件描述符的 RAII class 都能正常工作。但子进程不会继承：<br>1、父进程的内存锁，mlock()、mlockall()<br>2、父进程的文件锁，fcntl()<br>3、父进程的某些定时器，settimer()、alarm()、timer_create()等等</p>
<p>fork() 一般不能在多线程程序中调用，因为 Linux 的 fork() 只克隆当前线程的 thread of control，不克隆其他线程。不能一下子 fork() 出一个和父进程一样的多线程子进程。Linux 没有 forkall() 这样的系统调用。因为其他线程可能等在 condition variable 上，可能阻塞在系统调用上，可能等着 mutex 以跨入临界区，还可能在密集的计算中，这些都不好全盘搬到子进程里。</p>
<p>其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，再也没有机会去解锁了。如果子进程试图再对同一个 mutex 加锁，就会立刻死锁。在 fork() 之后，子进程就相当于处于 signal handler 之中，不能调用线程安全的函数(除非它是可重入的)，而只能调用异步信号安全(async-signal-safe)函数。子进程不能调用：<br>1、malloc()。因为 malloc() 在访问全局状态时几乎肯定会加锁。<br>2、任何可能分配或释放内存的函数，包括 new、map::insert()、snprintf…..<br>3、任何 Pthreads 函数。不能用 pthread_cond_signal() 去通知父进程，只能通过读写 pipe() 来同步。<br>4、printf() 系列函数，因为其他线程可能恰好持有 stdout/stderr 的锁。<br>5、除了 man 7 signal 中明确列出的 “signal 安全” 函数之外的任何函数。</p>
<p>唯一安全的做法是在 fork() 之后立即调用 exec() 执行另一个程序，彻底隔断子进程与父进程的联系。</p>
<h3 id="Signal信号"><a href="#Signal信号" class="headerlink" title="Signal信号"></a>Signal信号</h3><p>在多线程程序中，使用 signal 的第一原则是<strong>不要使用 signal</strong><br>1、不要使用 signal 作为 IPC 的手段，包括不要使用 SIGUSR1 等信号来触发服务端的行为。可以采取增加监听端口的方式来实现双向的、可远程访问的进程控制。<br>2、不要使用基于 signal 实现的定时函数，包括 alarm/ualarm/settitimer/timer_create、sleep/usleep 等等。<br>3、不主动处理各种异常信号(SIGTERM、SIGINT 等等)，只用默认语义：结束进程。有一个例外 SIGPIPE，服务器程序通常的做法是忽略此信号，否则如果对方断开连接，而本机继续 write 的话，会导致程序意外终止。<br>4、在没有别的替代方法的情况下(比如需要处理 SIGCHILD 信号)，把异步信号转换为同步的文件描述符事件。传统的做法是在 signal handler 里往一个特定的 pipe() 写一个字节，在主程序中从这个 pipe 读取，从而纳入统一的 IO 事件处理框架中去。现代 Linux 的做法是采用 signalfd() 把信号直接转换为文件描述符事件，从根本上避免使用 signal handler。</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>O_NONBLOCK 的功能是开启非阻塞 IO，而文件描述符默认是阻塞的。<br>FD_CLOEXEC 的功能是让程序 exec() 时，进程会自动关闭这个文件描述符。而文件描述默认是被子进程继承的(这是传统 Unix 的一种典型 IPC，比如用 pipe() 在父子进程间单向通信)。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 的客户端只支持同步操作，对于 UPDATE/INSERT/DELETE 之类只要行为不管结果的操作，可以用一个单独的线程来做，以降低服务线程的延迟。</p>
<h4 id="Mysql-联合索引最左匹配原则"><a href="#Mysql-联合索引最左匹配原则" class="headerlink" title="Mysql 联合索引最左匹配原则"></a>Mysql 联合索引最左匹配原则</h4><p><strong>最左前缀匹配原则</strong></p>
<p>在 mysql 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：</p>
<p>对列 col1、列 col2 和列 col3 建一个联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1, col2, col3);</span><br></pre></td></tr></table></figure>

<p>联合索引 test_col1_col2_col3 实际建立了 (col1)、(col1, col2)、(col1, col2, col3) 三个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=“<span class="number">1</span>” <span class="keyword">AND</span> clo2=“<span class="number">2</span>” <span class="keyword">AND</span> clo4=“<span class="number">4</span>”</span><br></pre></td></tr></table></figure>

<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引 (col1, col2) 进行数据匹配。</p>
<p>索引的字段可以是任意顺序的，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=“<span class="number">1</span>” <span class="keyword">AND</span> clo2=“<span class="number">2</span>”</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col2=“<span class="number">2</span>” <span class="keyword">AND</span> clo1=“<span class="number">1</span>”</span><br></pre></td></tr></table></figure>

<p>这两个查询语句都会用到索引 (col1, col2)，mysql 创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段 col1 的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段 col2 进行排序。其实就相当于实现了类似 order by col1 col2 这样一种排序规则。</p>
<p>有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引 (col1, col2) 中的 col1、col2 两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助 mysql 查询优化器 explain，explain 会纠正 sql 语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p>
<p><strong>为什么要使用联合索引</strong></p>
<ul>
<li><strong>减少开销</strong>。建一个联合索引 (col1, col2, col3)，实际相当于建了 (col1)、(col1, col2)、(col1, col2, col3) 三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引 (col1, col2, col3)，如果有如下的 <code>sql: select col1,col2,col3 from test where col1=1 and col2=2</code>。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。减少 io 操作，特别是随机 io，其实是 dba 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 <code>sql:select from table where col1=1 and col2=2 and col3=3</code>，假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 1000W * 10% = 100w 条数据，然后再回表从 100W 条数据中找到符合 col2=2 and col3=3 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出 1000W * 10% * 10% * 10% = 1W，效率提升可想而知！</li>
</ul>
<p><strong>引申</strong></p>
<p>对于联合索引 (col1, col2, col3)，查询语句 <code>SELECT * FROM test WHERE col2=2</code>；是否能够触发索引？<br>大多数人都会说 NO，实际上却是 YES。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col2=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>观察上述两个 explain 结果中的 type 字段。查询中分别是：</p>
<ol>
<li>type: index</li>
<li>type: ref</li>
</ol>
<ul>
<li><strong>index</strong>：这种类型表示 mysql 会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个联合索引的一部分，mysql 都可能会采用 index 类型的方式扫描。但是呢，缺点是效率不高，mysql 会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。</li>
<li><strong>ref</strong>：这种类型表示 mysql 会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，<strong>也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引</strong>。</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>一次 HTTP proxy 的请求如果没有命中本地 cache：<br>1、解析域名<br>2、建立连接<br>3、发送 HTTP 请求<br>4、等待对方回应<br>5、把结果返回给客户<br>这5步中和2个 sever 发生了3次 round-trip：<br>1、向 DNS 问域名，等待回复<br>2、向对方的 HTTP 服务器发起连接，等待 TCP 三路握手完成<br>3、向对方发送 HTTP request，等待对方 response</p>
<h3 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h3><p>网络同步 = 数据同步 + 表现同步，数据同步是后端操作，表现同步就是让前端对后端同步过来的数据进行进一步的处理从而达到表现上的一致。一般的 Web 服务器只是单纯的从服务器向客户端进行数据同步，不会把其他客户端的数据都发给你。游戏服务器对实时性要求比较高(尤其是 MMORPG、FPS 类型的网游)。综上 <strong>网络同步 = 实时的多端数据同步 + 实时的多端表现同步</strong>。网络同步是一个网络 IO 与 CPU 计算同样密集的游戏功能。</p>
<h3 id="游戏服务器基础组件-Java"><a href="#游戏服务器基础组件-Java" class="headerlink" title="游戏服务器基础组件(Java)"></a>游戏服务器基础组件(Java)</h3><p>1、网络组件<br>包括内网通信模块和外网通信模块、协议<br>2、数据库组件<br>玩家数据和全局数据的持久化<br>3、日志组件<br>异常日志(代码异常打印日志)、行为日志(为运营平台提供的行为日志)<br>4、配置组件<br>程序启动配置(如 ip、port、连接关系)和游戏相关配置(各种数据表格)</p>
<h3 id="游戏逻辑模块-Java"><a href="#游戏逻辑模块-Java" class="headerlink" title="游戏逻辑模块(Java)"></a>游戏逻辑模块(Java)</h3><p>1、系统服务线程组<br>登录系统服务、好友系统服务、帮派系统服务…，可以将一个或者多服务挂载一个线程，也可以分别挂载不同线程</p>
<p>2、场景逻辑线程组<br>玩家的行走、战斗、道具获得、使用，系统服务线程组提供的系统服务基本都是通过 RPC 调用的方式为场景逻辑组线程提供服务。比如添加好友、场景逻辑线程上的玩家收到添加好友消息，然后通过 RPC 调用系统服务线程组的好友服务实现添加好友功能。<br>登录服务做了特殊处理，登录消息会直接分发到登录服务，登录服务进行验证，验证通过后会在场景服务线程组创建对应的角色通信对象与客户端进行通信。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ol>
<li><p>堆<br>是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p>
</li>
<li><p>栈<br>是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。因此，栈是 thread safe 的。操作系统在切换线程的时候会自动的切换栈，就是切换 ss/esp 寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">进程占有的资源</th>
<th align="center">线程占有的资源</th>
</tr>
</thead>
<tbody><tr>
<td align="center">地址空间</td>
<td align="center">栈</td>
</tr>
<tr>
<td align="center">全局变量</td>
<td align="center">寄存器</td>
</tr>
<tr>
<td align="center">打开的文件</td>
<td align="center">状态</td>
</tr>
<tr>
<td align="center">子进程</td>
<td align="center">程序计数器</td>
</tr>
<tr>
<td align="center">信号量</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">账户信息</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>程序计数器是用来存放下一条指令的地址的。当执行一条指令时，首先需要根据 PC 中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为“取指令”。与此同时，PC 中的地址或自动加1或由转移指针给出下一条指今的地址。此后经过分析指令、执行指令、完成第一条指令的执行，而后根据 PC 取出第二条指令的地址，如此循环，执行每一条指令。</p>
<h4 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h4><p>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。</p>
<p>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。正是这样的设计，大大提高了 CPU 的利用率。进程的出现让每个用户感觉到自己独享 CPU，因此，进程就是为了在 CPU 上实现多道编程而提出的。</p>
<p>进程的不足：</p>
<ul>
<li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li>
<li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
</ul>
<p>举个现实的例子：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p>
<p>进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，不过是指令级的并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发。</p>
<p>区别：</p>
<ul>
<li><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
</li>
<li><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p>
</li>
</ul>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<h4 id="用户级线程与核心级线程（线程的切换）"><a href="#用户级线程与核心级线程（线程的切换）" class="headerlink" title="用户级线程与核心级线程（线程的切换）"></a>用户级线程与核心级线程（线程的切换）</h4><p><strong>1、为什么要说线程的切换</strong></p>
<p>操作系统是多进程的，我们关注的应该是进程之间的切换，那为什么关注线程的切换呢？因为理解了线程的切换之后可以更好的理解进程的切换，换句话说线程的切换是进程切换的基础。</p>
<p>每一个进程都包含一个映射表，如果进程切换了，那么程序选择的映射表肯定也不一样；进程的切换其实是包含两个部分的，第一个指令的切换，第二个映射表的切换。指令的切换就是从这段程序跳到另外一段程序执行，映射表切换就是执行不同的进程，所选择的映射表不一样。线程的切换只有指令的切换，同处于一个进程里面，不存在映射表的切换。进程的切换就是在线程切换的基础上加上映射表的切换。</p>
<p><strong>2、线程的引入</strong></p>
<p>多个进程可以“同时”执行，其实也就是换着执行，那么在同一个进程里面，不同的代码段能不能换着执行呢？比如在进程 A 里面有代码段 1、代码段 2、代码段 3；能不能先执行一下代码段 1，然后执行一下代码段 3，再执行一下代码段 2 呢？答案是可以的。进程的切换包括指令的切换和映射表的切换，那么同一个进程里面就没必要进行映射表的切换了，即只需要切换指令就可以了。上面所说的代码段其实就称为“线程”。</p>
<p>前面说了多线程只需要进行指令的切换就可以了；这样相对于进程来说，多线程保留了多进程的优点：并发。避免了进程切换的代价（切换映射表需要耗费比较多的时间）。如果能够将多线程的切换弄明白，那么多进程的切换其实也就直剩下了映射表的切换，这是典型的“分而治之”。</p>
<p><strong>3、用户级线程</strong></p>
<p>以前网速比较慢的时候，打开浏览器访问一个网页，首先弹出来的是网页的文字部分，然后是一些图片，最后才是一些小视频之类的。为什么呢？浏览器向服务器发起访问的程序是一个进程，它包含若干线程，比如：一个线程用来从服务器接收数据，一个线程用来显示文本，一个线程用来显示视频，一个线程用来显示图片等等。在网速比较慢的时候用来从服务器接收数据的线程要执行的时间比较长，因为一些图片和视频都比较大。如果要等这个线程运行完了之后再显示，那么电脑屏幕就会有一段时间什么东西都没有，这样用户体验就会比较差；一个比较合理的办法是：接受数据的线程接受完文本东西之后，就调用显示文本的线程将数据显示出来，然后再接受图片再显示，再接受视频再显示；这样至少可以保证电脑屏幕上始终有东西；相比前面的方法好很多，当然最根本的办法还是提高网速。</p>
<p>为什么浏览器向服务器请求数据的程序是一个进程，而不是多个？浏览器接受服务器的数据肯定都是存储在一个缓冲区里面的，并且这个缓冲区是共享的，如果是多个进程，那么肯定有多个映射表，也就是说如果程序里面存储数据的地址是连续的，经过不同的映射表之后，就会分布在内存的不同区域，这样肯定没有在一块地方好处理。</p>
<p>1、两个线程与一个栈</p>
<p>线程一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> : A()</span><br><span class="line">&#123;</span><br><span class="line">	B();</span><br><span class="line">	<span class="number">104</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">200</span> : B()</span><br><span class="line">&#123;</span><br><span class="line">	Yield1();	<span class="comment">// 切换线程</span></span><br><span class="line">	<span class="number">204</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程二</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">300</span> : C()</span><br><span class="line">&#123;</span><br><span class="line">	D();</span><br><span class="line">	<span class="number">304</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">400</span> : D()</span><br><span class="line">&#123;</span><br><span class="line">	Yield2();</span><br><span class="line">	<span class="number">404</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个执行一下，首先从线程一的 A 函数开始，调用 B 函数，将 B 函数的返回地址 104 压栈，然后进入 B 函数；在 B 函数内部使用Yield1 切换到线程二的 C() 函数里面去，同时将 Yield1 的返回地址压栈，此时栈中的数据如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span> <span class="number">204</span></span><br></pre></td></tr></table></figure>

<p>Yield1 的伪代码应该是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	find <span class="number">300</span>;</span><br><span class="line">	jmp <span class="number">300</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在执行到了线程二，计划是在 D 函数里面通过 Yield2 跳到线程一的 204 这个地址，完成线程的切换。调用 C 函数，同时将 304 这个地址压栈，跳到 D 函数里面执行，在 D 函数里面调用 Yield2，同时将 404 压栈。Yield2 的伪代码应该是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	find <span class="number">204</span>;</span><br><span class="line">	jmp <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前栈里面的数据应该是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span> <span class="number">204</span> <span class="number">304</span> <span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>跳到 204 之后，接着执行 B 函数剩下的内容，执行完内容之后，执行函数 B 的 “}” 相当于 ret，弹栈，此时栈顶的地址是 404，B 函数应该是返回到 104 处，而不是 404 处；这里就出现了问题。怎么处理？</p>
<p>2、从一个栈到两个栈</p>
<p>处理方法是使用两个栈，在不同的线程里面使用不同的栈。在线程一中使用栈一，线程二中使用栈二。</p>
<p>重新执行一下上面那个程序，从 A 函数开始执行，在 B 函数里面调用 Yield1 进入线程二的 C 函数之后，线程一对应的栈一中的内容应该是：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span> <span class="number">204</span></span><br></pre></td></tr></table></figure>

<p>执行到 D 函数的 Yield2 之后，线程二对应的栈二的内容应该是：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">304</span> <span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>在 Yield2 里面做的第一件事就应该是切换栈，如何切换？肯定需要一个数据结构将原来栈一的地址保存起来，这个数据结构就是 TCB（Thread control block）；当前栈的栈顶地址是存放在 cpu 里面的 esp 寄存器里面的，因此只需要改变 esp 的值就可以切换栈了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TCB2.esp = esp;			<span class="comment">// 保存当前栈顶地址</span></span><br><span class="line">	esp = TCB1.esp;			<span class="comment">// 切换栈</span></span><br><span class="line">	jmp <span class="number">204</span>;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jmp 到 204 之后，执行完 B 函数剩下的代码之后执行 B 函数的 “}”，即弹栈，这时栈顶是 204，也就是又跳到 204 去了，显然有问题，但是比前面已经好很多了，因为不会跳到另外一个线程里去。那现在为什么会这样呢？原因是 Yield2() 直接跳到 204 之后，而没有将栈中的 204 弹出去，如果 Yield2 跳到 204 这个位置，同时将栈中的 204 弹出去就好了。其实这个可以实现，修改 Yield2 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TCB2.esp = esp;			<span class="comment">// 保存当前栈顶地址</span></span><br><span class="line">	esp = TCB1.esp;			<span class="comment">// 切换栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，就是将 jmp 204 去掉就可以了，利用 Yield2 的 “}” 弹栈同时跳到 204 地址处，执行完 B 函数之后，通过 B 函数的 “}” 再次弹栈到 104 处。</p>
<p><strong>4、核心级线程</strong></p>
<p>1、多处理器和多核的区别</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%A4%9A%E6%A0%B8.jpg" alt=""></p>
<p>多处理器每一个 CPU 都有一套自己的 MMU。多核是所有的 CPU 共用一套 MMU，也就是多个 CPU 的内存映射关系是一致的。</p>
<p>多核就有种单个进程的概念，在这个进程内部所有的线程都是共用一套 MMU 的。多处理器就有种多进程的概念，每个 CPU 的 MMU 都不一样。因此对于同一个进程来说，多核可以同时执行这个进程里面的线程，但是多处理器不行，只有多线程才能将多核利用起来，因为现在电脑都是多核的，所以这是多线程的一大用处。这里的线程指的是核心级线程。核心级线程可以将每一个线程对应到具体的 CPU 上。</p>
<p>2、核心级线程与用户级线程有什么区别呢？</p>
<p>核心级线程需要在用户态和核心态里面跑，在用户态里跑需要一个用户栈，在核心态里面跑需要一个核心栈。用户栈和核心栈合起来称为一套栈，这就是核心级线程与用户级线程一个很重要的区别，从一个栈变成了一套栈。用户级线程用 TCB 切换栈的时候是在一个栈与另外一个栈之间切换，核心级线程就是在一套栈与另外一套栈之间的切换（核心级线程切换），核心级线程的 TCB 应该是在内核态里面。</p>
<p>3、用户栈与内核栈之间的关联</p>
<p>内核栈什么时候出现？当线程进入内核的时候就应该建立一个属于这个线程的内核栈，那么线程是如何进入系统内核的？通过 INT 中断。当线程下一次进入内核的时候，操作系统可以根据一些硬件寄存器来知道这是哪个线程，它对应的内核栈在哪里。同时会将用户态的栈的位置（SS、SP）和程序执行到哪个地方了（CS、IP）都压入内核栈。等线程在内核里面执行完（也就是 IRET 指令）之后就根据进入时存入的 SS、SP 的值找到用户态中对应栈的位置，根据存入的 CS、IP 的值找到程序执行到哪个地方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:A()</span><br><span class="line">&#123;</span><br><span class="line">	B();</span><br><span class="line">	<span class="number">104</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">200</span>:B()</span><br><span class="line">&#123;</span><br><span class="line">	read();</span><br><span class="line">	<span class="number">204</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">300</span>:read()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="number">0x80</span>;</span><br><span class="line">	<span class="number">304</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">system_call:</span><br><span class="line">	call sys_read;</span><br><span class="line"><span class="number">1000</span>:</span><br><span class="line"><span class="number">2000</span>:sys_read()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 “- - - - -” 表示用户态和核心态的分界；首先该线程调用 B 函数，将 104 压栈（用户栈），进入 B 函数之后调用 read() 这个系统调用，同时将 204 压栈（用户栈），进入 read() 系统调用通过 int0x80 这个中断号进入内核态，执行到</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sys_read()</span></span><br><span class="line"><span class="string">&#123;</span>	</span><br><span class="line">	<span class="string">读磁盘；</span></span><br><span class="line">	<span class="string">将自己变成阻塞状态；</span></span><br><span class="line">	<span class="string">找到</span> <span class="string">next</span> <span class="string">（下一个执行的线程）；</span></span><br><span class="line">	<span class="string">调用</span> <span class="string">switch_to(cur,</span> <span class="string">next);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>switch_to() 方法就是切换线程，形参 cur 表示当前线程的 TCB，next 表示下一个执行线程的 TCB。这个函数首先将目前 esp 寄存器的值存入 cur.TCB.esp，将 next.TCB.esp 放入 esp 寄存器里面；其实就是从当前线程的内核栈切换到 next 线程的内核栈。这里要明白一件事，内核级线程自己的代码还是在用户态的，只是进入内核态完成系统调用，也就是逛一圈之后还是要回去执行的。因此切换到 next 线程就是要根据 next 线程的内核栈找到这个线程阻塞前执行到的位置，并接着执行。所以切换到 next 线程的内核栈之后应该通过一条包含 IRET 指令的语句进入到用户态执行这个线程的代码。这样就从 cur 线程切换到 next 线程。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，可以考虑多起几个 Redis 进程，Redis 是 key-value 数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失、其他异常等等。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 只修饰离它最近的类型符号 </p>
<p><strong>1、const 修饰的一级指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"> <span class="comment">//*p = 30;         //error:表达式必须是可修改的左值</span></span><br><span class="line"> p = &amp;b;            <span class="comment">//ok</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p); <span class="comment">//20</span></span><br><span class="line"> system(<span class="string">"pause"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码证明出 const int * p 中 const 修饰的是 int，则 const int * p 指的是：*p 所代表的整形值是常量，不能被直接修改，而指针 p 本身是变量，可以被修改。（不能通过修改 p 指针指向地址 a 的数据来修改 *p 的值，但可以通过修改 p 指针本身所储存的地址来修改 p 的值。）<br>另外 const int * p 和 int const * p 是一样的，因为与int const * p 中与 const 相邻的类型只有 int，const 修饰的还是 int。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;</span><br><span class="line"> *p = <span class="number">30</span>;           <span class="comment">//ok</span></span><br><span class="line"> <span class="comment">//p = &amp;b;          //error:表达式必须是可修改的左值</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p); <span class="comment">//20</span></span><br><span class="line"> system(<span class="string">"pause"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，int * const p 中 const 修饰的是 int *，int * const p 指的是：指针 p 本身是常量，不能被修改。而 *p 所代表的是整形变量，可以被直接修改。（指针 p 本身存储的地址不能被修改，而指针 p 指向地址 a 的值可以被修改。）</p>
<p><strong>2、const 修饰的二级指针</strong></p>
<ol>
<li>const int ** p<br>const int ** p 表示 ** p 代表的整形内存放的是常量，不能够被修改。而指针 p 本身是变量，可以被修改。（const 修饰的是 int）</li>
<li>int ** const p<br>int ** const p 表示指针 p 本身是常量，不能被修改。而 ** p 代表的整形内存放的值是变量，可以被修改。（const 修饰 的是int **）</li>
<li>int * const * p<br>int * const * p 是一个二级指针，const 修饰的是 int * ，代表指针 * p 的值是常量，不能被修改。而 ** p 所代表的整形内存放的是变量，可以被修改。指针 p 本身是变量，也可以被修改。（通俗来说，就是二级指针 p 所指向的一级指针 * p 不能被修改，而 ** p 所代表的整形，可以被修改。指针 p 本身，也可以被修改。）</li>
</ol>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h4 id="为什么函数重载不可以根据返回类型区分？"><a href="#为什么函数重载不可以根据返回类型区分？" class="headerlink" title="为什么函数重载不可以根据返回类型区分？"></a>为什么函数重载不可以根据返回类型区分？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当调用 max(1, 2) 时，无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。</p>
<p>函数的返回值只是作为函数运行之后的一个<code>状态</code>，它是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的<code>标识</code>。</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof 实际上是获取了数据在内存中所占用的存储空间，以字节为单位来计数。</p>
<p>C 语言会自动在在双引号 “” 括起来的内容的末尾补上 “\0” 代表结束，ASCII 中的0号位也占用一个字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> b = <span class="string">'b'</span>;</span><br><span class="line">	short c = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">long</span> d = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">6.29f</span>;</span><br><span class="line">	<span class="keyword">double</span> f = <span class="number">95.0629</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="keyword">double</span> *p = &amp;f;</span><br><span class="line">	<span class="keyword">int</span> *i = &amp;a;</span><br><span class="line">	<span class="comment">//分别对各个变量使用sizeof运算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a=%d,b=%d,c=%d,d=%d,e=%d,f=%d,arr=%d,str=%d point_p=%d,point_i=%d\n"</span>,</span><br><span class="line">		<span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(b), <span class="keyword">sizeof</span>(c), <span class="keyword">sizeof</span>(d), <span class="keyword">sizeof</span>(e), <span class="keyword">sizeof</span>(f),</span><br><span class="line">		<span class="keyword">sizeof</span>(arr), <span class="keyword">sizeof</span>(str), <span class="keyword">sizeof</span>(p), <span class="keyword">sizeof</span>(i));</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line">输出的结果是:a=<span class="number">4</span>,b=<span class="number">1</span>,c=<span class="number">2</span>,d=<span class="number">4</span>,e=<span class="number">4</span>,f=<span class="number">8</span>,arr=<span class="number">12</span>,str=<span class="number">6</span> point_p=<span class="number">4</span>,point_i=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>C/C++ 中，sizeof() 只是运算符号，是编译的时候确定大小的。动态分配是运行过程中得到大小的，也就是说 C++ 中 new 出来的内存，sizeof 都无法统计的，退一步说，即使是 new 出来的空间也有可能失败，所以 sizeof 无法统计动态分配的内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用new关键字，在堆区开辟一个int数组</span></span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="comment">//统计一个指针的大小，32位系统指针占4字节，64位系统指针占8字节</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//解指针，32位系统下，结果和上面一样，因为arr指针指向的时数组的首元素，int类型占4字节</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*arr) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sizeof() 为物理存储大小，strlen() 为除去 \0 后逻辑字符串长度。</strong></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h4><p><strong>1、SO_REUSEADDR</strong></p>
<p>一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR 是让端口释放后立即就可以被再次使用。</p>
<p>SO_REUSEADDR 用于对 TCP 套接字处于 TIME_WAIT 状态下的 socket，才可以重复绑定使用。</p>
<p>server 程序总是应该在调用 bind() 之前设置 SO_REUSEADDR 套接字选项 TCP，先调用 close() 的一方会进入 TIME_WAIT 状态。</p>
<p>SO_REUSEADDR 提供如下四个功能：</p>
<ul>
<li>允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则 bind 时将出错。</li>
<li>允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地 IP 地址即可。对于 TCP，我们根本不可能启动捆绑相同 IP 地址和相同端口号的多个服务器。</li>
<li>允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地 IP 地址即可，这一般不用于 TCP 服务器。</li>
</ul>
<p>SO_REUSEADDR 允许完全重复的捆绑：</p>
<ul>
<li>当一个 IP 地址和端口绑定到某个套接口上时，还允许此 IP 地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对 UDP 套接口而言（TCP 不支持多播）。</li>
</ul>
<p>SO_REUSEPORT 选项有如下语义：</p>
<p>此选项允许完全重复捆绑，但仅在想捆绑相同 IP 地址和端口的套接口都指定了此套接口选项才行。</p>
<p>如果被捆绑的 IP 地址是一个多播地址，则 SO_REUSEADDR 和 SO_REUSEPORT 等效。</p>
<p>使用这两个套接口选项的建议：</p>
<ul>
<li>在所有 TCP 服务器中，在调用 bind 之前设置 SO_REUSEADDR 套接口选项；</li>
<li>当编写一个同一时刻在同一主机上可运行多次的多播应用程序时，设置 SO_REUSEADDR 选项，并将本组的多播地址作为本地 IP 地址捆绑。</li>
</ul>
<p><strong>2、SO_REUSEPORT</strong></p>
<p>目前常见的网络编程模型就是多进程或多线程，根据accpet的位置，分为如下场景2种场景</p>
<ul>
<li>单进程或线程创建 socket，并进行 listen 和 accept，接收到连接后创建进程和线程处理连接</li>
<li>单进程或线程创建 socket，并进行 listen，预先创建好多个工作进程或线程 accept() 在同一个服务器套接字</li>
</ul>
<p>这两种模型解充分发挥了多核 CPU 的优势，虽然可以做到线程和 CPU 核绑定，但都会存在：</p>
<ul>
<li>单一 listener 工作进程或线程在高速的连接接入处理时会成为瓶颈</li>
<li>多个线程之间竞争获取服务套接字</li>
<li>缓存行跳跃</li>
<li>很难做到 CPU 之间的负载均衡</li>
<li>随着核数的扩展，性能并没有随着提升</li>
</ul>
<p>SO_REUSEPORT 支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，解决的问题：</p>
<ul>
<li>允许多个套接字 bind()/listen() 同一个 TCP/UDP 端口</li>
<li>每一个线程拥有自己的服务器套接字</li>
<li>在服务器套接字上没有了锁的竞争</li>
<li>内核层面实现负载均衡</li>
<li>安全层面，监听同一个端口的套接字只能位于同一个用户下面</li>
</ul>
<p>其核心的实现主要有三点：</p>
<ul>
<li>扩展 socket option，增加 SO_REUSEPORT 选项，用来设置 reuseport</li>
<li>修改 bind 系统调用实现，以便支持可以绑定到相同的 IP 和端口</li>
<li>修改处理新建连接的实现，查找 listener 的时候，能够支持在监听相同 IP 和端口的多个 sock 之间均衡选择</li>
<li>有了 SO_RESUEPORT 后，每个进程可以自己创建 socket、bind、listen、accept 相同的地址和端口，各自是独立平等的</li>
<li>让多进程监听同一个端口，各个进程中 accept socket fd 不一样，有新连接建立时，内核只会唤醒一个进程来 accept，并且保证唤醒的均衡性</li>
</ul>
<h4 id="Accept-发生在三次握手的哪个阶段？"><a href="#Accept-发生在三次握手的哪个阶段？" class="headerlink" title="Accept 发生在三次握手的哪个阶段？"></a>Accept 发生在三次握手的哪个阶段？</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP/accept.png" alt=""></p>
<p>accept 过程发生在三次握手之后，三次握手完成后，客户端和服务器就建立了 tcp 连接并可以进行数据交互了。这时可以调用 accept 函数获得此连接。</p>
<p>客户端调用 connect 的时候，就是发一个 syn，服务端 accept 的时候，实际上是从内核的 accept 队列里面取一个连接，如果这个队列为空，则进程阻塞（阻塞模式下）。如果 accept 返回则说明成功取到一个连接，返回到应用层。大致的过程是客户端发一个 syn 之后，服务端将这个连接放入到 backlog 队列，在收到客户端的 ack 之后将这个请求移到 accept 队列。所以 accept 一定是发生在三次握手之后，connect只是发一个 syn 而已。</p>
<p>socket 分为两种，一种套接字正如 accept 的参数 sockfd，它是 listen socket，在调用 listen 函数之后，一个 socket 会从主动连接的套接字变为 listen 套接字；而 accept 返回是一个连接套接字，它代表着一个网络已经存在的点对点连接。以后的数据交互就是基于这个连接socket，而之前的那个 listen socket 可以继续工作，从而接收更多的连接。</p>
<p>connect() 在第二次握手返回。</p>
<h4 id="惊群"><a href="#惊群" class="headerlink" title="惊群"></a>惊群</h4><p>惊群效应就是当一个 fd 的事件被触发时，所有等待这个 fd 的线程或进程都被唤醒。一般都是 socket 的 accept() 会导致惊群（当然也可以弄成一堆线程/进程阻塞 read 一个 fd），很多个进程都 block 在 server socket 的 accept()，一但有客户端进来，所有进程的 accept() 都会返回，但是只有一个进程会读到数据，就是惊群。实际上现在的 Linux 内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6内核）。使用 mutex 锁住多个线程是不会惊群的，在某个线程解锁后，只会有一个线程会获得锁，其它的继续等待。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>为什么 C++ 调用空指针对象的成员函数可以运行通过？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B foo "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pp</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B pp"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FunctionB</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"funB"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B *somenull = <span class="literal">NULL</span>;</span><br><span class="line">    somenull-&gt;foo();</span><br><span class="line">    somenull-&gt;pp();</span><br><span class="line">    somenull-&gt;FunctionB();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题可以阐明“静态绑定”和“动态绑定”的区别。<br>真正的原因是：因为对于非虚成员函数，Ｃ++ 这门语言是静态绑定的。这也是 Ｃ++ 语言和其它语言 Java, Python 的一个显著区别。以此下面的语句为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somenull-&gt;foo();</span><br></pre></td></tr></table></figure>

<p>这语句的意图是：调用对象 somenull 的 foo 成员函数。如果这句话在 Java 或 Python 等动态绑定的语言之中，编译器生成的代码大概是：找到 somenull 的 foo 成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）</p>
<p>但是对于 C++。为了保证程序的运行时效率，Ｃ++ 的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以 C++ 的编译器看到这句话会这么做：<br>１：查找 somenull 的类型，发现它有一个非虚的成员函数叫 foo。（编译器处理）<br>２：找到了，在这里生成一个函数调用，直接调 B::foo(somenull)。所以到了运行时，由于 foo() 函数里面并没有任何需要解引用 somenull 指针的代码，所以真实情况下也不会引发 segment fault。这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。正确理解 C++ 的静态绑定可以理解一些特殊情况下 C++ 的行为。</p>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>C++ 中的 mutable 有两种作用。</p>
<p><strong>1、类中的 mutable</strong></p>
<p>可变的只能用来形容变量，而不可能是函数或者类本身。然而，既然是变量，那么它本来就是可变的，也没必要使用 mutable 来修饰。那么，mutable 就只能用来形容某种不变的东西了。</p>
<p>C++ 中，不可变的变量，称之为常量，使用 const 修饰。</p>
<p>事实上，mutable 是用来修饰一个 const 示例的部分可变的数据成员的。如果说得更清晰一点，就是说 mutable 的出现，将 C++ 中的 const 的概念分成了两种。</p>
<ul>
<li>二进制层面的 const，也就是绝对的常量，在任何情况下都不可修改（除非用 const_cast）。</li>
<li>引入 mutable 之后，C++ 可以有逻辑层面的 const，也就是对一个常量实例来说，从外部观察，它是常量不可修改，但是内部可以有非常量的状态。</li>
</ul>
<p>显而易见，mutable 只能用来修饰类的数据成员，而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(key == last_key_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> last_value_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> value&#123;<span class="keyword">this</span>-&gt;lookupInternal(key)&#125;;</span><br><span class="line"></span><br><span class="line">            last_key_ = key;</span><br><span class="line">            last_value_ = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">string</span> last_key_;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">string</span> last_value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对哈希表的查询操作，在逻辑上不应该修改哈希表本身。因此，HashTable::lookup 是一个 const 成员函数。在 HashTable::lookup 中，我们使用了 last_key_ 和 last_value_ 实现了一个简单的缓存逻辑。当传入的 key 与前次查询的 last_key_ 一致时，直接返回 last_value_; 否则，则返回实际查询得到的 value 并更新 last_key_ 和 last_value_。</p>
<p>在这里，last_key_ 和 last_value_ 是 HashTable 的数据成员。按照一般的理解，const 成员函数是不允许修改数据成员的。但是，另一方面，last_key_ 和 last_value_ 在类的外部是看不到的，从逻辑上说，修改它们的值，外部是没有感知的，因此也就不会破坏逻辑上的 const。为了解决这一矛盾，我们用 mutable 来修饰 last_key_ 和 last_value_，以便在 lookup 函数中更新缓存的键值。</p>
<p><strong>2、Lambda 表达式中的 mutable</strong></p>
<p>C++11 引入了 Lambda 表达式，程序员可以凭此创建匿名函数。在 Lambda 表达式的设计中，捕获变量有几种方式；其中按值捕获（Caputre by Value）的方式不允许程序员在 Lambda 函数的函数体中修改捕获的变量。而以 mutable 修饰 Lambda 函数，则可以打破这种限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]() <span class="keyword">mutable</span> &#123;x = <span class="number">42</span>;&#125;; <span class="comment">// okay, 创建了一个函数类型的实例</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()         &#123;x = <span class="number">42</span>;&#125;; <span class="comment">// error, 不允许修改按值捕获的外部变量的值</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，上述 f1 的函数体中，虽然我们给 x 做了赋值操作，但是这一操作仅只在函数内部生效。即，实际是给拷贝至函数内部的 x 进行赋值，而外部的 x 的值依旧是 0。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>为什么要在 C++ 函数中最后添加默认参数？</strong></p>
<p>在参数列表中的任何位置都可能具有默认参数，但这会增加函数调用的复杂性和歧义性（对于编译器，可能更重要的是对于函数用户）。</p>
<p>如果要在各个参数位置使用默认参数，则几乎可以肯定地做到这一点，方法是编写重载，然后简单地转过来并调用内联完全参数化的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(<span class="number">0</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通常，函数参数由编译器处理，并以从右到左的顺序放置在堆栈中。因此，应该首先评估具有默认值的任何参数。（这适用于 __cdecl，它通常是 VC++ 和 __stdcall 函数声明的默认值。）</p>
<h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><p><strong>1、default_random_engine</strong></p>
<p>以前获取伪随机数都是用的 rand，想要获取两个数之间的伪随机数，方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min,max;</span><br><span class="line"><span class="comment">//定义上下边界</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> range=max-min;</span><br><span class="line"><span class="comment">//获取中间的范围</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> randNum = rand() % range + min;</span><br><span class="line"><span class="comment">//生成介于min和max之间的伪随机数</span></span><br></pre></td></tr></table></figure>

<p>《C++ Primer 5th Edition》里面介绍了使用 default_random_engine 来获取随机数，并且指出“C++ 程序不应该使用库函数 rand，而应使用 default_random_engine 类来恰当的分布类对象。”用这种新方法获取两个数之间的伪随机数的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min,max;</span><br><span class="line"><span class="comment">//定义上下边界</span></span><br><span class="line"> </span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="comment">//创建引擎</span></span><br><span class="line"> </span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(min,max)</span></span>;</span><br><span class="line"><span class="comment">//创建取值范围</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> randNum=u(e);</span><br><span class="line"><span class="comment">//获取伪随机数</span></span><br></pre></td></tr></table></figure>

<p>有一个问题，就是多次调用同一对范围和引擎时，每次生成的数都是一样的。为了避免这个情况，需要在定义范围和引擎时，将其定义为 static的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> default_random_engine e;</span><br><span class="line"><span class="function"><span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(min,max)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关于设置种子，既可以在定义时设置种子，也可以创建完成后再设置种子，方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e1</span><span class="params">(<span class="number">32767</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建引擎时设置种子</span></span><br><span class="line"> </span><br><span class="line">default_random_engine e2;</span><br><span class="line">e2.seed(<span class="number">32767</span>);</span><br><span class="line"><span class="comment">//创建后再设置种子</span></span><br></pre></td></tr></table></figure>

<p>如果要设置时间为种子，方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">//设置当前时间为引擎种子</span></span><br></pre></td></tr></table></figure>

<p>time 返回时间的单位是秒，所以如果是自动过程的一部分反复运行，比如用在循环中，那么因为间隔时间不够，所以设置的种子其实是一样的。</p>
<h4 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h4><p>enable_shared_from_this 是一个模板类，定义于头文件 &lt; memory &gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">enable_shared_from_this</span>;</span></span><br></pre></td></tr></table></figure>

<p>std::enable_shared_from_this 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, … ），它们与 pt 共享对象 t 的所有权。</p>
<p>若一个类 T 继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数 shared_from_this。当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。</p>
<p><strong>1、使用场合</strong></p>
<p>当类 A 被 share_ptr 管理，且在类 A 的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的 share_ptr。</p>
<ol>
<li><p>为何不直接传递this指针<br>使用智能指针的初衷就是为了方便资源管理，如果在某些地方使用智能指针，某些地方使用原始指针，很容易破坏智能指针的语义，从而产生各种错误。</p>
</li>
<li><p>可以直接传递 share_ptr<this> 么？<br>答案是不能，因为这样会造成2个非共享的 share_ptr 指向同一个对象，未增加引用计数导对象被析构两次。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Bad() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad::~Bad() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; <span class="title">bp1</span><span class="params">(<span class="keyword">new</span> Bad())</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">	<span class="comment">// 打印bp1和bp2的引用计数</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bp1.use_count() = "</span> &lt;&lt; bp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bp2.use_count() = "</span> &lt;&lt; bp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;  <span class="comment">// Bad 对象将会被删除两次</span></span><br></pre></td></tr></table></figure>

<p>正确的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span> :</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Good&gt; <span class="comment">// 注意：继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">	~Good() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Good::~Good() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 大括号用于限制作用域，这样智能指针就能在system("pause")之前析构</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; <span class="title">gp1</span><span class="params">(<span class="keyword">new</span> Good())</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">		<span class="comment">// 打印gp1和gp2的引用计数</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"gp1.use_count() = "</span> &lt;&lt; gp1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"gp2.use_count() = "</span> &lt;&lt; gp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、为何会出现这种使用场合</strong></p>
<p>因为在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的 share_ptr 给异步函数，这样在异步函数执行期间 share_ptr 所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。</p>
<h3 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h3><h4 id="实现一个不能被继承的类"><a href="#实现一个不能被继承的类" class="headerlink" title="实现一个不能被继承的类"></a>实现一个不能被继承的类</h4><p><strong>1、方法一</strong></p>
<p>最直观的解决方法就是将其构造函数声明为私有的，这样就可以阻止子类构造对象了。但是这样的话，就无法构造本身的对象了，就无法利用了。<br>既然这样，我们又可以想定义一个静态方法来构造类和释放类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">static</span> A* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           A *pa = <span class="keyword">new</span> A;</span><br><span class="line">           pa-&gt;num = n;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"num is:"</span>&lt;&lt;pa-&gt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">return</span> pa;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destruct</span><span class="params">(A * pIntance)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">delete</span> pIntance;</span><br><span class="line">           pIntance = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       A()&#123;&#125;</span><br><span class="line">       ~A()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *f = A::Construct(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f-&gt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    A::Destruct(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样只能在堆上创建，无法再栈上实现创建类。这就是私有的构造函数的局限性。</p>
<p><strong>2、方法二</strong></p>
<p><strong>利用友元不能被继承的特性，可以实现这样的类</strong>。</p>
<p>设计一个模板辅助类 Base，将构造函数声明为私有的；再设计一个不能继承的类 FinalClass，将 FinalClass 作为 Base 的友元类。FinalClass 虚继承 Base。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;FinalClass&gt;&#123;  </span><br><span class="line"> <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FinalClass()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"FinalClass()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> FinalClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;     <span class="comment">//继承时报错，无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FinalClass b;      <span class="comment">//B类无法被继承</span></span><br><span class="line">    <span class="comment">//C c;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 Base 的构造函数和析构函数因为是私有的，只有 Base 类的友元可以访问，FinalClass 类在继承时将模板的参数设置为了 FinalClass 类，所以构造 FinalClass 类对象时们可以直接访问父类（Base）的构造函数。</p>
<p><strong>为什么必须是虚继承呢</strong>？</p>
<p>虚继承的功能是：当出现了菱形继承体系的时候，使用虚继承可以防止二义性，即子孙类不会继承多个原始祖先类。</p>
<p>那么虚继承如何解决这种二义性的呢？从<strong>具有虚基类的类继承的类</strong>在初始化时进行了特殊处理，在虚派生中，由<strong>最低层次的派生类的构造函数初始化虚基类</strong>。</p>
<p>结合上面的代码来解释：C 在调用构造函数时，不会先调用 FinalClass 的构造函数，而是直接调用 Base 的构造函数，C 不是 Base 的友元类，所以无法访问。这样的话 C 就不能继承 FinalClass。</p>
<p><strong>注 C++11 的已经加入了 final 关键字，直接在类后面加上 final 关键字，就可以防止该类被继承</strong>。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>死锁发生的条件</strong></p>
<ul>
<li><p>互斥条件：线程对资源的访问是排他性的，如果一个线程占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。</p>
</li>
<li><p>请求和保持条件：线程 T1 至少已经保持了对一个资源 R1 的占用，但又提出对另一个资源 R2 的请求，而此时，资源 R2 被其他线程 T2 占用，于是该线程 T1 也必须等待，但又对自己保持的资源 R1 不释放。</p>
</li>
<li><p>不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</p>
</li>
<li><p>环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即 {p0,p1,p2,…pn}，进程 p0（或线程）等待 p1 占用的资源，p1 等待 p2 占用的资源，pn 等待 p0 占用的资源。（最直观的理解是，p0 等待 p1 占用的资源，而 p1 在等待 p0 占用的资源，于是两个进程就相互等待）。</p>
</li>
</ul>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>是指线程 1 可以使用资源，但它很礼貌，让其他线程先使用资源，线程 2 也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 活锁例子</span></span><br><span class="line"><span class="comment"> * 创建一个勺子类，有且只有一个。</span></span><br><span class="line"><span class="comment"> * 丈夫和妻子用餐时，需要使用勺子，这时只能有一人持有，也就是说同一时刻只有一个人能够进餐。</span></span><br><span class="line"><span class="comment"> * 但是丈夫和妻子互相谦让，都想让对方先吃，所以勺子一直传递来传递去，谁都没法用餐。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveLockTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个勺子，ower 表示这个勺子的拥有者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> &#123;</span></span><br><span class="line">        Diner owner;<span class="comment">//勺子的拥有者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取拥有者</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getOwnerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> owner.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置拥有者</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOwner</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = diner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Spoon</span><span class="params">(Diner diner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.owner = diner;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示正在用餐</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(owner.getName() + <span class="string">" use this spoon and finish eat."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个晚餐类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diner</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diner</span><span class="params">(boolean isHungry, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isHungry = isHungry;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> boolean isHungry;<span class="comment">//是否饿了</span></span><br><span class="line">        <span class="keyword">private</span> String name;<span class="comment">//定义当前用餐者的名字</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="comment">//获取当前用餐者</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以理解为和某人吃饭</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatWith</span><span class="params">(Diner spouse, Spoon sharedSpoon)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synchronized (sharedSpoon) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (isHungry) &#123;</span><br><span class="line">                        <span class="comment">//当前用餐者和勺子拥有者不是同一个人，则进行等待</span></span><br><span class="line">                        <span class="keyword">while</span> (!sharedSpoon.getOwnerName().equals(name)) &#123;</span><br><span class="line">                            sharedSpoon.wait();</span><br><span class="line">                            <span class="comment">//System.out.println("sharedSpoon belongs to" + sharedSpoon.getOwnerName())</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//spouse此时是饿了，把勺子分给他，并通知他可以用餐</span></span><br><span class="line">                        <span class="keyword">if</span> (spouse.isHungry) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"I am "</span> + name + <span class="string">", and my "</span> + spouse.getName() + <span class="string">" is hungry, I should give it to him(her).\n"</span>);</span><br><span class="line">                            sharedSpoon.setOwner(spouse);</span><br><span class="line">                            sharedSpoon.notifyAll();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//用餐</span></span><br><span class="line">                            sharedSpoon.use();</span><br><span class="line">                            sharedSpoon.setOwner(spouse);</span><br><span class="line">                            isHungry = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">" is interrupted."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Diner husband = <span class="keyword">new</span> Diner(<span class="literal">true</span>, <span class="string">"husband"</span>);<span class="comment">//创建一个丈夫用餐类</span></span><br><span class="line">        <span class="keyword">final</span> Diner wife = <span class="keyword">new</span> Diner(<span class="literal">true</span>, <span class="string">"wife"</span>);<span class="comment">//创建一个妻子用餐类</span></span><br><span class="line">        <span class="keyword">final</span> Spoon sharedSpoon = <span class="keyword">new</span> Spoon(wife);<span class="comment">//创建一个勺子，初始状态并由妻子持有</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个 线程，由丈夫进行用餐</span></span><br><span class="line">        Thread h = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="comment">//表示和妻子用餐，这个过程判断妻子是否饿了，如果是，则会把勺子分给妻子，并通知她</span></span><br><span class="line">                husband.eatWith(wife, sharedSpoon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个 线程，由妻子进行用餐</span></span><br><span class="line">        Thread w = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="comment">//表示和妻子用餐，这个过程判断丈夫是否饿了，如果是，则会把勺子分给丈夫，并通知他</span></span><br><span class="line">                wife.eatWith(husband, sharedSpoon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        w.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        h.interrupt();</span><br><span class="line">        w.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h.join();<span class="comment">//join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。</span></span><br><span class="line">            w.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>是指如果线程 T1 占用了资源 R，线程 T2 又请求封锁 R，于是 T2 等待。T3 也请求资源 R，当 T1 释放了 R上 的封锁后，系统首先批准了T3 的请求，T2 仍然等待。然后 T4 又请求封锁 R，当 T3 释放了 R 上的封锁之后，系统又批准了 T4 的请求…，T2 可能永远等待。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="C-语言实现-itoa-函数"><a href="#C-语言实现-itoa-函数" class="headerlink" title="C 语言实现 itoa 函数"></a>C 语言实现 itoa 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A C++ program to implement itoa() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* A utility function to reverse a string  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> end = length <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) </span><br><span class="line">    &#123; </span><br><span class="line">        swap(*(str+start), *(str+end)); </span><br><span class="line">        start++; </span><br><span class="line">        end--; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of itoa() </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">itoa</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span>* str, <span class="keyword">int</span> base)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">bool</span> isNegative = <span class="literal">false</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Handle 0 explicitely, otherwise empty string is printed for 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        str[i++] = <span class="string">'0'</span>; </span><br><span class="line">        str[i] = <span class="string">'\0'</span>; </span><br><span class="line">        <span class="keyword">return</span> str; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// In standard itoa(), negative numbers are handled only with  </span></span><br><span class="line">    <span class="comment">// base 10. Otherwise numbers are considered unsigned. </span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        isNegative = <span class="literal">true</span>; </span><br><span class="line">        num = -num; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Process individual digits </span></span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> rem = num % base; </span><br><span class="line">        str[i++] = (rem &gt; <span class="number">9</span>) ? (rem<span class="number">-10</span>) + <span class="string">'a'</span> : rem + <span class="string">'0'</span>; </span><br><span class="line">        num = num/base; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If number is negative, append '-' </span></span><br><span class="line">    <span class="keyword">if</span> (isNegative) </span><br><span class="line">        str[i++] = <span class="string">'-'</span>; </span><br><span class="line">  </span><br><span class="line">    str[i] = <span class="string">'\0'</span>; <span class="comment">// Append string terminator </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Reverse the string </span></span><br><span class="line">    reverse(str, i); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> str; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test implementation of itoa() </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>]; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:10 "</span> &lt;&lt; itoa(<span class="number">1567</span>, str, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:10 "</span> &lt;&lt; itoa(<span class="number">-1567</span>, str, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:2 "</span> &lt;&lt; itoa(<span class="number">1567</span>, str, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:8 "</span> &lt;&lt; itoa(<span class="number">1567</span>, str, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:16 "</span> &lt;&lt; itoa(<span class="number">1567</span>, str, <span class="number">16</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考原文</strong><br>1、<a href="https://www.cnblogs.com/sixue/p/4046168.html">C++内存对象布局</a><br>2、<a href="https://www.cnblogs.com/skynet/p/3343726.html">C++对象模型</a><br>3、<a href="https://mp.weixin.qq.com/s/xnsSfGNhNHsmdjuDHS2nlQ">网络同步在游戏历史中的发展变化（一）—— 网络同步与网络架构</a><br>4、<a href="https://blog.csdn.net/caoshangpa/article/details/79392878">C++11新特性之十：enable_shared_from_this</a></p>
</div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://www.beyondhxl.com/post/70ae5d6.html">C++游戏服务器知识点散记</a></li><li><strong>本文作者：</strong><a href="https://www.beyondhxl.com">beyondhxl</a></li><li><strong>本文链接：</strong><a href="https://www.beyondhxl.com/post/70ae5d6.html">https://www.beyondhxl.com/post/70ae5d6.html</a></li><li><strong>版权声明：</strong><span>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span></li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/post/70ae5d6.html" target="_blank">C++游戏服务器知识点散记</a><br></span><span>  2.<a class="is-size-6" href="/post/a9472e98.html" target="_blank">游戏服务器端开发要点</a><br></span><span>  3.<a class="is-size-6" href="/post/1c48c532.html" target="_blank">Golang游戏服务器知识点散记</a><br></span><span>  4.<a class="is-size-6" href="/post/baad55eb.html" target="_blank">Linux的epoll使用LT+非阻塞IO和ET+非阻塞IO的区别(转载)</a><br></span><span>  5.<a class="is-size-6" href="/post/1d3a59e7.html" target="_blank">博客-Markdown使用笔记</a><br></span><span>  6.<a class="is-size-6" href="/post/85be90d7.html" target="_blank">数据库系统概论</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%94%AF%E4%BB%98%E5%AE%9D/zhifubao.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%BE%AE%E4%BF%A1/weixin.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/baad55eb.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Linux的epoll使用LT+非阻塞IO和ET+非阻塞IO的区别(转载)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/a82c6dfe.html"><span class="level-item">Mysql中MyISAM和InnoDB的区别</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '892333c0078af8fc79d32c584033eaa1',
            repo: 'blogcomment',
            owner: 'beyondhxl',
            clientID: '6e19ff696a6246d4da8b',
            clientSecret: '1518ab0356e2eeaecbdbd5efd9b654cd5c224c93',
            admin: ["beyondhxl"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Static" href="#Static"><span>Static</span></a></li><li><a class="is-flex toc-item" id="toc-item-多态" href="#多态"><span>多态</span></a></li><li><a class="is-flex toc-item" id="toc-item-转型" href="#转型"><span>转型</span></a></li><li><a class="is-flex toc-item" id="toc-item-C-隐式类型转换和关键字-explicit" href="#C-隐式类型转换和关键字-explicit"><span>C++ 隐式类型转换和关键字 explicit</span></a></li><li><a class="is-flex toc-item" id="toc-item-编译" href="#编译"><span>编译</span></a></li><li><a class="is-flex toc-item" id="toc-item-GatewayServer" href="#GatewayServer"><span>GatewayServer</span></a></li><li><a class="is-flex toc-item" id="toc-item-英语" href="#英语"><span>英语</span></a></li><li><a class="is-flex toc-item" id="toc-item-Effective-C" href="#Effective-C"><span>Effective C++</span></a></li><li><a class="is-flex toc-item" id="toc-item-More-Effective-C" href="#More-Effective-C"><span>More Effective C++</span></a></li><li><a class="is-flex toc-item" id="toc-item-结构体-Struct" href="#结构体-Struct"><span>结构体 Struct</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-字节对齐" href="#字节对齐"><span>字节对齐</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-范式" href="#范式"><span>范式</span></a></li><li><a class="is-flex toc-item" id="toc-item-inline" href="#inline"><span>inline</span></a></li><li><a class="is-flex toc-item" id="toc-item-STL" href="#STL"><span>STL</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1、lower-bound-和-upper-bound-实现" href="#1、lower-bound-和-upper-bound-实现"><span>1、lower_bound 和 upper_bound 实现</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-SessionServer" href="#SessionServer"><span>SessionServer</span></a></li><li><a class="is-flex toc-item" id="toc-item-游戏服务器中的数据库异步操作技术和游戏数据的保存机制" href="#游戏服务器中的数据库异步操作技术和游戏数据的保存机制"><span>游戏服务器中的数据库异步操作技术和游戏数据的保存机制</span></a></li><li><a class="is-flex toc-item" id="toc-item-服务器传输层在异步模型下的基本使用序列" href="#服务器传输层在异步模型下的基本使用序列"><span>服务器传输层在异步模型下的基本使用序列</span></a></li><li><a class="is-flex toc-item" id="toc-item-RAII" href="#RAII"><span>RAII</span></a></li><li><a class="is-flex toc-item" id="toc-item-fork" href="#fork"><span>fork()</span></a></li><li><a class="is-flex toc-item" id="toc-item-Signal信号" href="#Signal信号"><span>Signal信号</span></a></li><li><a class="is-flex toc-item" id="toc-item-文件描述符fd" href="#文件描述符fd"><span>文件描述符fd</span></a></li><li><a class="is-flex toc-item" id="toc-item-MySQL" href="#MySQL"><span>MySQL</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Mysql-联合索引最左匹配原则" href="#Mysql-联合索引最左匹配原则"><span>Mysql 联合索引最左匹配原则</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-HTTP" href="#HTTP"><span>HTTP</span></a></li><li><a class="is-flex toc-item" id="toc-item-网络同步" href="#网络同步"><span>网络同步</span></a></li><li><a class="is-flex toc-item" id="toc-item-游戏服务器基础组件-Java" href="#游戏服务器基础组件-Java"><span>游戏服务器基础组件(Java)</span></a></li><li><a class="is-flex toc-item" id="toc-item-游戏逻辑模块-Java" href="#游戏逻辑模块-Java"><span>游戏逻辑模块(Java)</span></a></li><li><a class="is-flex toc-item" id="toc-item-进程和线程" href="#进程和线程"><span>进程和线程</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-资源" href="#资源"><span>资源</span></a></li><li><a class="is-flex toc-item" id="toc-item-进程和线程区别" href="#进程和线程区别"><span>进程和线程区别</span></a></li><li><a class="is-flex toc-item" id="toc-item-用户级线程与核心级线程（线程的切换）" href="#用户级线程与核心级线程（线程的切换）"><span>用户级线程与核心级线程（线程的切换）</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-Redis" href="#Redis"><span>Redis</span></a></li><li><a class="is-flex toc-item" id="toc-item-分布式事务" href="#分布式事务"><span>分布式事务</span></a></li><li><a class="is-flex toc-item" id="toc-item-const" href="#const"><span>const</span></a></li><li><a class="is-flex toc-item" id="toc-item-重载" href="#重载"><span>重载</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-为什么函数重载不可以根据返回类型区分？" href="#为什么函数重载不可以根据返回类型区分？"><span>为什么函数重载不可以根据返回类型区分？</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-sizeof" href="#sizeof"><span>sizeof</span></a></li><li><a class="is-flex toc-item" id="toc-item-Socket" href="#Socket"><span>Socket</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-socket-选项" href="#socket-选项"><span>socket 选项</span></a></li><li><a class="is-flex toc-item" id="toc-item-Accept-发生在三次握手的哪个阶段？" href="#Accept-发生在三次握手的哪个阶段？"><span>Accept 发生在三次握手的哪个阶段？</span></a></li><li><a class="is-flex toc-item" id="toc-item-惊群" href="#惊群"><span>惊群</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-指针" href="#指针"><span>指针</span></a></li><li><a class="is-flex toc-item" id="toc-item-mutable" href="#mutable"><span>mutable</span></a></li><li><a class="is-flex toc-item" id="toc-item-函数" href="#函数"><span>函数</span></a></li><li><a class="is-flex toc-item" id="toc-item-C-11" href="#C-11"><span>C++11</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-enable-shared-from-this" href="#enable-shared-from-this"><span>enable_shared_from_this</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-类-Class" href="#类-Class"><span>类 Class</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-实现一个不能被继承的类" href="#实现一个不能被继承的类"><span>实现一个不能被继承的类</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-操作系统" href="#操作系统"><span>操作系统</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-死锁" href="#死锁"><span>死锁</span></a></li><li><a class="is-flex toc-item" id="toc-item-活锁" href="#活锁"><span>活锁</span></a></li><li><a class="is-flex toc-item" id="toc-item-饥饿" href="#饥饿"><span>饥饿</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-String" href="#String"><span>String</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-C-语言实现-itoa-函数" href="#C-语言实现-itoa-函数"><span>C 语言实现 itoa 函数</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/avatar.png" alt="宇宙の騎士"></figure><p class="title is-size-4 is-block line-height-inherit">宇宙の騎士</p><p class="is-size-6 is-block">博学之，审问之，慎思之，明辩之，笃行之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>罗生门</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">86</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">113</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">126</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://beyondhxl.com/about/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/beyondhxl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:459898432@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Note" href="http://beyondhxl.com/mydocs/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/post/784ee20b.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%93%86%E5%95%A6A%E6%A2%A6/ChMkJ1bKxwqIcn_mAANXBz3B3OEAALHuQCNRZEAA1cf424.jpg" alt="WSL-Windows上的Linux子系统"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-28T18:35:31.000Z">2021-01-28</time></p><p class="title is-6"><a class="link-muted" href="/post/784ee20b.html">WSL-Windows上的Linux子系统</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> / <a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WSL/">WSL</a></p></div></article><article class="media"><a class="media-left" href="/post/977a8d62.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wguYKIOjHjAARfEgchsmAAAt9XgKb_1EABF8q200.jpg" alt="TCP网络编程常用工具(转载)"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-15T00:03:46.000Z">2020-08-15</time></p><p class="title is-6"><a class="link-muted" href="/post/977a8d62.html">TCP网络编程常用工具(转载)</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> / <a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">网络工具命令</a></p></div></article><article class="media"><a class="media-left" href="/post/3294d6b6.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJlwslleIACs_AAiLFiW8JwMAAuITgDEZnEACIsu836.jpg" alt="数据结构与算法-二叉搜索树"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-13T23:52:30.000Z">2020-08-13</time></p><p class="title is-6"><a class="link-muted" href="/post/3294d6b6.html">数据结构与算法-二叉搜索树</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a></p></div></article><article class="media"><a class="media-left" href="/post/43ed0d63.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wslluIDUsWAAJOteVG-6YAAuITgEOUE4AAk7N608.jpg" alt="如何优雅地关闭Go语言的通道channel"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-11T00:07:23.000Z">2020-08-11</time></p><p class="title is-6"><a class="link-muted" href="/post/43ed0d63.html">如何优雅地关闭Go语言的通道channel</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Golang/">Golang</a> / <a class="link-muted" href="/categories/Golang/%E9%80%9A%E9%81%93channel/">通道channel</a></p></div></article><article class="media"><a class="media-left" href="/post/8ce5f219.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wg0UuIMmMwAAdhOUUDAxwAAt9dgGqYjcAB2FR003.jpg" alt="深度探索C++对象模型（DataMember的布局）"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-08T00:21:09.000Z">2020-08-08</time></p><p class="title is-6"><a class="link-muted" href="/post/8ce5f219.html">深度探索C++对象模型（DataMember的布局）</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/C/">C++</a> / <a class="link-muted" href="/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">对象模型</a> / <a class="link-muted" href="/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%B8%83%E5%B1%80/">对象成员布局</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/C-11/"><span class="level-start"><span class="level-item">C++11</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/C-11/initializer-list/"><span class="level-start"><span class="level-item">initializer_list</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/String/"><span class="level-start"><span class="level-item">String</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/epoll/"><span class="level-start"><span class="level-item">epoll</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/"><span class="level-start"><span class="level-item">内存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="level-start"><span class="level-item">内存分配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/malloc%E3%80%81new/"><span class="level-start"><span class="level-item">malloc、new</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E6%A6%82%E5%BF%B5/"><span class="level-start"><span class="level-item">概念</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/epoll/"><span class="tag">epoll</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B/"><span class="tag">进程</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span class="tag">面向对象</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=beyondhxl/XZjz&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="beyondhxl/XZjz" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/logo1.png" alt="宇宙の騎士" height="28"></a><p class="size-small"><span>&copy; 2024 beyondhxl</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2020/04/15 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="8044353" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.beyondhxl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('6e19ff696a6246d4da8b','1518ab0356e2eeaecbdbd5efd9b654cd5c224c93','beyondhxl','blogcomment',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('6e19ff696a6246d4da8b','1518ab0356e2eeaecbdbd5efd9b654cd5c224c93','beyondhxl','blogcomment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>