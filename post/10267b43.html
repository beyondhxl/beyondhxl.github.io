<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="categories-java"><meta name="description" content="进程间通信方式与线程间通信方式"><meta name="author" content="beyondhxl"><title>进程间通信方式与线程间通信方式 - 宇宙の騎士</title><meta description="进程间通信方式与线程间通信方式"><meta property="og:type" content="article"><meta property="og:title" content="进程间通信方式与线程间通信方式"><meta property="og:url" content="https://www.beyondhxl.com/post/10267b43.html"><meta property="og:site_name" content="宇宙の騎士"><meta property="og:description" content="进程间通信方式与线程间通信方式"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E7%8E%A9%E5%85%B7%E6%80%BB%E5%8A%A8%E5%91%98/toy3.jpg"><meta property="article:published_time" content="2020-05-28T23:35:51.000Z"><meta property="article:modified_time" content="2024-08-02T20:36:09.808Z"><meta property="article:author" content="beyondhxl"><meta property="article:tag" content="categories-java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E7%8E%A9%E5%85%B7%E6%80%BB%E5%8A%A8%E5%91%98/toy3.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.beyondhxl.com/post/10267b43.html"},"headline":"进程间通信方式与线程间通信方式","image":["https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E7%8E%A9%E5%85%B7%E6%80%BB%E5%8A%A8%E5%91%98/toy3.jpg"],"datePublished":"2020-05-28T23:35:51.000Z","dateModified":"2024-08-02T20:36:09.808Z","author":{"@type":"Person","name":"beyondhxl"},"description":"进程间通信方式与线程间通信方式"}</script><link rel="alternative" href="/atom.xml" title="宇宙の騎士" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/logo1.png" alt="宇宙の騎士" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">专辑</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">说说</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/steamgames">Steam</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E7%8E%A9%E5%85%B7%E6%80%BB%E5%8A%A8%E5%91%98/toy3.jpg" alt="进程间通信方式与线程间通信方式"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-05-28  <a class="commentCountImg" href="/post/10267b43.html#comment-container"><span class="display-none-class">e16755d6dd945cad09a0849363fc5849</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="e16755d6dd945cad09a0849363fc5849">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 分钟  <i class="fas fa-pencil-alt"> </i>0.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">进程间通信方式与线程间通信方式</h1><div class="content"><blockquote>
<p>进程间通信方式与线程间通信方式</p>
</blockquote>
<a id="more"></a>

<h2 id="零、进程通信的应用场景"><a href="#零、进程通信的应用场景" class="headerlink" title="零、进程通信的应用场景"></a>零、进程通信的应用场景</h2><ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)。</li>
<li>资源共享：多个进程之间共享同样的资源。需要内核提供锁和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行(如 Debug 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<h2 id="一、进程间通信方式"><a href="#一、进程间通信方式" class="headerlink" title="一、进程间通信方式"></a>一、进程间通信方式</h2><h3 id="1-1、管道-pipe"><a href="#1-1、管道-pipe" class="headerlink" title="1.1、管道(pipe)"></a>1.1、管道(pipe)</h3><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程间的亲缘关系通常是指父子进程关系。如通过 fork 操作生成的两个进程。</p>
<h4 id="1-1-1、通信"><a href="#1-1-1、通信" class="headerlink" title="1.1.1、通信"></a>1.1.1、通信</h4><p>管道是由内核管理的一个缓冲区，相当于放入内存中的一个纸条。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。缓冲区不要太大，设计成为环形的数据结构。当管道中没有消息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满消息时，尝试放入消息的进程会等待，直到另一端的进程取出消息。当两个进程都终结的时候，管道也自动消失。(有点类似 Golang 的 Channel，但是 Channel 是可以主动 Close 的)。</p>
<h4 id="1-1-2、创建"><a href="#1-1-2、创建" class="headerlink" title="1.1.2、创建"></a>1.1.2、创建</h4><p>管道利用 fork 机制建立，从而让两个进程可以连接到同一个 PIPE 上。</p>
<p>在 Linux 中，管道借助了文件系统的 file 结构和 VFS 的索引节点 inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面实现的。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/pipe.png" alt=""></p>
<h4 id="1-1-3、读写"><a href="#1-1-3、读写" class="headerlink" title="1.1.3、读写"></a>1.1.3、读写</h4><p>管道读函数 pipe_read() 和 管道写函数 pipe_write()。写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，读函数则通过复制物理内存中的字节而读出数据。内核必须利用一定的机制同步对管道的访问，如锁、等待队列、信号。写入函数必须检查 VFS 索引节点中的信息，需要同时满足如下条件，才能进行实际的内存复制工作：</p>
<ul>
<li>内存中有足够的空间可容纳所有要写入的数据；</li>
<li>内存没有被读程序锁定</li>
</ul>
<p>写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核讲调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p>
<p>管道的读取过程和写入过程类似，但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页被释放。</p>
<h4 id="1-1-4、程序实例"><a href="#1-1-4、程序实例" class="headerlink" title="1.1.4、程序实例"></a>1.1.4、程序实例</h4><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>filedes[0]用于读出数据，读取时必须关闭写入端，即 close(filedes[1]);<br>filedes[1]用于写入数据，写入时必须关闭读取端，即 close(filedes[0]);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pipe[fd] == <span class="number">0</span>)	<span class="comment">// 先建立管道得到一对文件描述符</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)		<span class="comment">// 父进程把文件描述符复制给子进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)			<span class="comment">// 父进程写</span></span><br><span class="line">	&#123;							</span><br><span class="line">		close(fd[<span class="number">0</span>]);			<span class="comment">// 关闭读描述符</span></span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"\nhello world\n"</span>, <span class="number">14</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>						<span class="comment">// 子进程读</span></span><br><span class="line">	&#123;						<span class="comment">// 关闭写端</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">		write(STDOUT_FILENO, line, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、命名管道-named-pipe-FIFO"><a href="#1-2、命名管道-named-pipe-FIFO" class="headerlink" title="1.2、命名管道(named pipe/FIFO)"></a>1.2、命名管道(named pipe/FIFO)</h3><p>命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode | S_IFIFO, (<span class="keyword">dev_t</span>)<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>filename 是被创建的文件名称，mode 表示将在文件上设置的权限位和被创建的文件类型，dev 是当创建设备特殊文件时使用的一个值。</p>
<p><strong>程序实例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_PATH <span class="meta-string">"/root/fifo"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mkfifo(FIFO_PATH, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno != EEXIST)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"create fifo failed."</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> readfd = open(FIFO_PATH, O_RDONLY);  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"child open fifo success."</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>];  </span><br><span class="line">  </span><br><span class="line">        read(readfd, buf, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message from pipe: "</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">        close(readfd);  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    sleep(<span class="number">3</span>);  </span><br><span class="line">    <span class="keyword">int</span> writefd = open(FIFO_PATH, O_WRONLY);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"parent open fifo success."</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> *temp = <span class="string">"hello world"</span>;  </span><br><span class="line">    write(writefd, temp, <span class="built_in">strlen</span>(temp) + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    close(writefd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、信号量-semaphore"><a href="#1-3、信号量-semaphore" class="headerlink" title="1.3、信号量(semaphore)"></a>1.3、信号量(semaphore)</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一个锁机制，防止某进程在访问共享资源时，其他进程也访问此资源。主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h4 id="1-3-1、工作原理"><a href="#1-3-1、工作原理" class="headerlink" title="1.3.1、工作原理"></a>1.3.1、工作原理</h4><p>由于信号量只能进行两种操作等待和发送信号，即 P(sv) 和 V(sv)</p>
<ul>
<li>P(sv)：如果 sv 的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</li>
<li>V(sv)：如果有其他进程因等待 sv 而被挂起，就让它恢复运行，如果没有进程因等待 sv 而挂起，就给它加1</li>
</ul>
<h4 id="1-3-2、信号量机制"><a href="#1-3-2、信号量机制" class="headerlink" title="1.3.2、信号量机制"></a>1.3.2、信号量机制</h4><p><strong>semget函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一个参数 key 是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用 semget 函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有 semget 函数才直接使用信号量键，所有其他的信号量函数使用由 semget 函数返回的信号量标识符。如果多个程序使用相同的 key 值，key 将负责协调工作。</p>
</li>
<li><p>第二个参数 num_sems 指定需要的信号量数目，它的值几乎总是1。</p>
</li>
<li><p>第三个参数 sem_flags 是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值 IPC_CREAT 做按位或操作。设置了 IPC_CREAT 标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而 IPC_CREAT | IPC_EXCL 则可以创建一个新的、唯一的信号量，如果信号量已存在，返回一个错误。</p>
</li>
</ul>
<p><strong>semop函数</strong><br>它的作用是改变信号量的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf *sem_opa, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sem_id 是由 semget 返回的信号量标识符，sembuf 结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    short sem_num;	<span class="comment">//除非使用一组信号量，否则它为0  </span></span><br><span class="line">    short sem_op;	<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，一个是+1，即V（发送信号）操作。  </span></span><br><span class="line">    short sem_flg;	<span class="comment">//通常为SEM_UNDO，使操作系统跟踪信号，并在进程没有释放该信号量而终止时，操作系统释放信号量  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>semctl函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果有第四个参数，它通常是一个 union semum 结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> val;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> short *arry;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>command 通常是下面两个值中的其中一个</p>
<ol>
<li>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过 union semun 中的 val 成员设置，其作用是在信号量第一次使用前对它进行设置。</li>
<li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。</li>
</ol>
<h3 id="1-4、消息队列-message-queue"><a href="#1-4、消息队列-message-queue" class="headerlink" title="1.4、消息队列(message queue)"></a>1.4、消息队列(message queue)</h3><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号量传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。包括 Posix 消息队列 system V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。</p>
<p>结构 msg_queue 用来描述消息队列头，存在于系统空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> q_stime;        <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime;        <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime;        <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;    <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;      <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;    <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid;          <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid;          <span class="comment">/* last receive pid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构 msqid_ds 用来设置或返回消息队列的信息，存在于用户空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_first</span>;</span>      <span class="comment">/* first message on queue,unused  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_last</span>;</span>      <span class="comment">/* last message in queue,unused */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_stime;  <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_rtime;  <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short msg_cbytes;  <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short msg_qnum;    <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short msg_qbytes;  <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lspid;  <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lrpid;  <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-1、消息队列与内核的联系"><a href="#1-4-1、消息队列与内核的联系" class="headerlink" title="1.4.1、消息队列与内核的联系"></a>1.4.1、消息队列与内核的联系</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/pipe.png" alt=""></p>
<p>从上图可以看出，全局数据结构 struct ipc_ids msg_ids 可以访问到每个消息队列头的第一个成员 struct kern_ipc_perm；而每个 struct kern_ipc_perm 能够与具体的消息队列对应起来，因为在该结构中，有一个 key_t 类型成员 key，而 key 则唯一确定一个消息队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span>  				<span class="comment">//内核中记录消息队列的全局数据结构 msg_ids 能够访问到该结构；</span></span><br><span class="line"><span class="keyword">key_t</span>  key;    	<span class="comment">//该键值则唯一对应一个消息队列</span></span><br><span class="line"><span class="keyword">uid_t</span>  uid;</span><br><span class="line"><span class="keyword">gid_t</span>  gid;</span><br><span class="line"><span class="keyword">uid_t</span>  cuid;</span><br><span class="line"><span class="keyword">gid_t</span>  cgid;</span><br><span class="line"><span class="keyword">mode_t</span>  mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2、消息队列的操作"><a href="#1-4-2、消息队列的操作" class="headerlink" title="1.4.2、消息队列的操作"></a>1.4.2、消息队列的操作</h4><ul>
<li><p>打开或创建消息队列<br>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以要获得一个消息队列的描述字，只需提供该消息队列的键值即可；<br>消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。</p>
</li>
<li><p>读写操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mtype 成员代表消息类型，从消息队列中读取消息的一个重要依据就是消息的类型；mtext 是消息内容，当然长度不一定为1。因此，对于发送消息来说，首先预置一个 msgbuf 缓冲区并写入消息类型和内容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个 msgbuf 缓冲区，然后把消息读入该缓冲区即可。</p>
</li>
<li><p>获得或设置消息队列属性<br>消息队列的信息基本上都保存在消息队列头中，因此，可以分配一个类似于消息队列头的结构，来返回消息队列的属性，同样可以设置该数据结构。</p>
</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/msq1.png" alt=""></p>
<h3 id="1-5、信号-signal"><a href="#1-5、信号-signal" class="headerlink" title="1.5、信号(signal)"></a>1.5、信号(signal)</h3><p>信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生。</p>
<p>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</p>
<p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过 POSIX 实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</p>
<h4 id="1-5-1、信号来源、种类"><a href="#1-5-1、信号来源、种类" class="headerlink" title="1.5.1、信号来源、种类"></a>1.5.1、信号来源、种类</h4><p>信号事件的发生有两个来源</p>
<ol>
<li>硬件来源(比如我们按下了键盘或者其它硬件故障)；</li>
<li>软件来源，最常用发送信号的系统函数是 kill, raise, alarm 和 setitimer 以及 sigqueue 函数，软件来源还包括一些非法运算等操作。</li>
</ol>
<h4 id="1-5-2、信号种类"><a href="#1-5-2、信号种类" class="headerlink" title="1.5.2、信号种类"></a>1.5.2、信号种类</h4><p>可以从两个不同的分类角度对信号进行分类：</p>
<ol>
<li>可靠性方面：可靠信号与不可靠信号；</li>
<li>与时间的关系上：实时信号与非实时信号。</li>
</ol>
<p><strong>不可靠信号</strong></p>
<p>Linux 信号机制基本上是从 Unix 系统中继承过来的。早期 Unix 系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做“不可靠信号”，信号值小于 SIGRTMIN (Red hat 7.2中，SIGRTMIN=32，SIGRTMAX=63)的信号都是不可靠信号。这就是“不可靠信号”的来源。它的主要问题是：</p>
<ul>
<li>进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用 signal()，重新安装该信号。</li>
<li>信号可能丢失。因此，早期 unix 下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。</li>
<li>Linux 支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，Linux 下的不可靠信号问题主要指的是信号可能丢失。</li>
</ul>
<p><strong>可靠信号</strong></p>
<ul>
<li>随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充，力图实现“可靠信号”。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。</li>
<li>信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux 在支持新版本的信号安装函数sigation() 以及信号发送函数 sigqueue() 的同时，仍然支持早期的 signal() 信号安装函数，支持信号发送函数 kill()。</li>
</ul>
<p><strong>注意</strong>：可靠信号是指后来添加的新信号（信号值位于 SIGRTMIN 及 SIGRTMAX 之间）；不可靠信号是信号值小于 SIGRTMIN 的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。</p>
<p><strong>实时信号与非实时信号</strong></p>
<p>非实时信号都不支持排队，都是不可靠信号，编号是1-31，0是空信号；实时信号都支持排队，都是可靠信号。</p>
<p><strong>进程对信号的响应</strong></p>
<ul>
<li>忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL 及 SIGSTOP；</li>
<li>捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数；</li>
<li>执行缺省操作，Linux 对每种信号都规定了默认操作</li>
</ul>
<p><strong>注意</strong>：进程对实时信号的缺省反应是进程终止。</p>
<p><strong>信号的发送和安装</strong></p>
<ul>
<li>发送信号的主要函数有：kill()、raise()、sigqueue()、alarm()、setitimer() 以及 abort()。</li>
<li>如果进程要处理某一信号，那么就要在进程中安装该信号。安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，即进程将要处理哪个信号；该信号被传递给进程时，将执行何种操作。</li>
</ul>
<p><strong>注意</strong>： linux 主要有两个函数实现信号的安装：signal()、sigaction()。其中 signal() 在可靠信号系统调用的基础上实现，是库函数。它只有两个参数，不支持信号传递信息，主要是用于前32种非实时信号的安装；而 sigaction() 是较新的函数（由两个系统调用实现：sys_signal以及sys_rt_sigaction），有三个参数，支持信号传递信息，主要用来与 sigqueue() 系统调用配合使用，当然，sigaction() 同样支持非实时信号的安装。sigaction() 优于 signal() 主要体现在支持信号带有参数。</p>
<h3 id="1-6、共享内存-shared-memory"><a href="#1-6、共享内存-shared-memory" class="headerlink" title="1.6、共享内存(shared memory)"></a>1.6、共享内存(shared memory)</h3><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 通信方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往和其他通信方式(如信号量)配合使用来实现进程间的同步和通信。</p>
<h4 id="1-6-1、系统V共享内存原理"><a href="#1-6-1、系统V共享内存原理" class="headerlink" title="1.6.1、系统V共享内存原理"></a>1.6.1、系统V共享内存原理</h4><p>进程间需要共享的数据被放在一个叫做 IPC 共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统 V 共享内存通过 shmget 获得或创建一个 IPC 共享内存区域，并返回相应的标识符。内核在保证 shmget 获得或创建一个共享内存区，初始化该共享内存区相应的 shmid_kernel 结构体的同时，还将在特殊文件系统 shm 中，创建并打开一个同名文件，并在内存中建立起该文件的相应 dentry 及inode 结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用 shmget 完成的。</p>
<h4 id="1-6-2、系统V共享内存API"><a href="#1-6-2、系统V共享内存API" class="headerlink" title="1.6.2、系统V共享内存API"></a>1.6.2、系统V共享内存API</h4><p>shmget() 用来获得共享内存区域的 ID，如果不存在指定的共享区域就创建相应的区域。shmat() 把共享内存区域映射到调用进程的地址空间中去，这样，进程就可以方便地对共享区域进行访问操作。shmdt() 调用用来解除进程对共享内存区域的映射。shmctl() 实现对共享内存区域的控制操作。</p>
<h3 id="1-7、套接字-socket"><a href="#1-7、套接字-socket" class="headerlink" title="1.7、套接字(socket)"></a>1.7、套接字(socket)</h3><p>套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备间的进程通信。</p>
<h3 id="1-8、全双工管道"><a href="#1-8、全双工管道" class="headerlink" title="1.8、全双工管道"></a>1.8、全双工管道</h3><p>共享内存、信号量、消息队列、管道和命名管道只适用于本地进程间通信，套接字和全双工管道可用于远程通信，因此可用于网络编程。</p>
<h2 id="二、线程间通信"><a href="#二、线程间通信" class="headerlink" title="二、线程间通信"></a>二、线程间通信</h2><h3 id="2-1、锁机制"><a href="#2-1、锁机制" class="headerlink" title="2.1、锁机制"></a>2.1、锁机制</h3><p>包括互斥锁、条件变量、读写锁。</p>
<h3 id="2-2、互斥锁"><a href="#2-2、互斥锁" class="headerlink" title="2.2、互斥锁"></a>2.2、互斥锁</h3><p>提供了以排他方式防止数据结构被并发修改的方法。</p>
<h3 id="2-3、读写锁"><a href="#2-3、读写锁" class="headerlink" title="2.3、读写锁"></a>2.3、读写锁</h3><p>允许多个线程同时共享数据，而对写操作是互斥的。</p>
<h3 id="2-4、条件变量"><a href="#2-4、条件变量" class="headerlink" title="2.4、条件变量"></a>2.4、条件变量</h3><p>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<h3 id="2-5、信号量机制-Semaphore"><a href="#2-5、信号量机制-Semaphore" class="headerlink" title="2.5、信号量机制(Semaphore)"></a>2.5、信号量机制(Semaphore)</h3><p>包括无名线程信号量和命名进程信号量。</p>
<p>无名信号量一般用于线程间同步或互斥，而有名信号量一般用于进程间同步或互斥。它们的区别和管道及命名管道的区别类似，无名信号量则直接保存在内存中，而有名信号量要求创建一个文件。</p>
<p>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。</p>
<p>编程时可根据操作信号量值的结果判断是否对公共资源有访问的权限，当信号量值大于0时，则可以访问，否则将阻塞。PV 原语是对信号量的操作，一次 P 操作使信号量减1，一次 V 操作使信号量加1。</p>
<p>信号量主要用于进程或线程间的同步和互斥这两种典型情况。</p>
<p>信号量用于互斥：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F/sem1.png" alt=""></p>
<p>信号量用于同步：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F/sem2.png" alt=""></p>
<p>无名信号量基本操作：</p>
<p>需包含的头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>注意：编译信号量操作函数时，编译选项需加上参数 <code>-lpthread</code> 。</p>
<p>信号量数据类型为：<code>sem_t</code> 。</p>
<p>1）初始化信号量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<blockquote>
<p>创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>sem：信号量的地址。</li>
<li>pshared：等于0，信号量在线程间共享(常用)；不等于0，信号量在进程间共享。</li>
<li>value：信号量的初始值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0；失败：-1</li>
</ul>
<p>2）信号量 P 操作(减 1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<blockquote>
<p>将信号量的值减1。操作前，先检查信号量 sem 的值是否为0，若信号量为0，此函数会阻塞，直到信号量大于0时才进行减1操作。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>sem：信号量的地址。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0；失败：-1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以非阻塞的方式来对信号量进行减1操作。若操作前，信号量的值等于0，则对信号量的操作失败，函数立即返回。</p>
<p>3）信号量 V 操作(加 1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<blockquote>
<p>将信号量的值加1并发出信号唤醒等待线程(sem_wait())。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>sem：信号量的地址。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0；失败：-1</li>
</ul>
<p>4）获取信号量的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<blockquote>
<p>获取 sem 标识的信号量的值，保存在 sval 中。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>sem：信号量地址。</li>
<li>sval：保存信号量值的地址。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0；失败：-1</li>
</ul>
<p>5）销毁信号量 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<blockquote>
<p>删除 sem 标识的信号量。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>sem：信号量地址。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0；失败：-1</li>
</ul>
<p><strong>互斥实例</strong>:</p>
<figure class="highlight c++"><figcaption><span>>folded sem1.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sem_t</span> sem; <span class="comment">//信号量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sem_wait(&amp;sem);<span class="comment">//减一</span></span><br><span class="line">	<span class="keyword">while</span>(*str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str);	</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		str++;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	</span><br><span class="line">	sem_post(&amp;sem);<span class="comment">//加一</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str1 = <span class="string">"hello"</span>;</span><br><span class="line">	printer(str1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str2 = <span class="string">"world"</span>;</span><br><span class="line">	printer(str2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">	</span><br><span class="line">	sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//初始化信号量，初始值为 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建 2 个线程</span></span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_fun1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_fun2, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//等待线程结束，回收其资源</span></span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>); </span><br><span class="line">	</span><br><span class="line">	sem_destroy(&amp;sem); <span class="comment">//销毁信号量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步实例</strong>:</p>
<figure class="highlight c++"><figcaption><span>>folded sem2.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sem_t</span> sem_g, sem_p;     	<span class="comment">//定义两个信号量</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_g</span><span class="params">(<span class="keyword">void</span> *arg)</span>  <span class="comment">//此线程改变字符ch的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;sem_g);</span><br><span class="line">		ch++;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		sem_post(&amp;sem_p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_p</span><span class="params">(<span class="keyword">void</span> *arg)</span>  <span class="comment">//此线程打印ch的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;sem_p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,ch);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		sem_post(&amp;sem_g);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">	sem_init(&amp;sem_g, <span class="number">0</span>, <span class="number">0</span>);     <span class="comment">//初始化信号量</span></span><br><span class="line">	sem_init(&amp;sem_p, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;tid1, <span class="literal">NULL</span>, pthread_g, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;tid2, <span class="literal">NULL</span>, pthread_p, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="2-6、信号机制-signal"><a href="#2-6、信号机制-signal" class="headerlink" title="2.6、信号机制(signal)"></a>2.6、信号机制(signal)</h3><p>类似进程间的信号处理</p>
<p>参考文章:<br><a href="https://www.cnblogs.com/fmqdblog/p/10680077.html">1、进程间通信方式+线程间通信方式</a><br><a href="https://blog.csdn.net/tennysonsky/article/details/46496201">2、Linux系统编程——线程同步与互斥：POSIX无名信号量</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485649&idx=1&sn=8c1f4acceb6db2a3c5e024f17649187a&scene=21#wechat_redirect">3、记一次面试：进程之间究竟有哪些通信方式？ —- 告别死记硬背</a><br><a href="https://blog.csdn.net/c15522627353/article/details/52972941">4、Linux进程间的通信方式和原理</a></p>
</div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://www.beyondhxl.com/post/10267b43.html">进程间通信方式与线程间通信方式</a></li><li><strong>本文作者：</strong><a href="https://www.beyondhxl.com">beyondhxl</a></li><li><strong>本文链接：</strong><a href="https://www.beyondhxl.com/post/10267b43.html">https://www.beyondhxl.com/post/10267b43.html</a></li><li><strong>版权声明：</strong><span>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span></li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/post/70ae5d6.html" target="_blank">C++游戏服务器知识点散记</a><br></span><span>  2.<a class="is-size-6" href="/post/a9472e98.html" target="_blank">游戏服务器端开发要点</a><br></span><span>  3.<a class="is-size-6" href="/post/1c48c532.html" target="_blank">Golang游戏服务器知识点散记</a><br></span><span>  4.<a class="is-size-6" href="/post/baad55eb.html" target="_blank">Linux的epoll使用LT+非阻塞IO和ET+非阻塞IO的区别(转载)</a><br></span><span>  5.<a class="is-size-6" href="/post/1d3a59e7.html" target="_blank">博客-Markdown使用笔记</a><br></span><span>  6.<a class="is-size-6" href="/post/85be90d7.html" target="_blank">数据库系统概论</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%94%AF%E4%BB%98%E5%AE%9D/zhifubao.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%BE%AE%E4%BF%A1/weixin.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/4347273b.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">B+Tree索引</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/a9472e98.html"><span class="level-item">游戏服务器端开发要点</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'e16755d6dd945cad09a0849363fc5849',
            repo: 'blogcomment',
            owner: 'beyondhxl',
            clientID: '6e19ff696a6246d4da8b',
            clientSecret: '1518ab0356e2eeaecbdbd5efd9b654cd5c224c93',
            admin: ["beyondhxl"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-零、进程通信的应用场景" href="#零、进程通信的应用场景"><span>零、进程通信的应用场景</span></a></li><li><a class="is-flex toc-item" id="toc-item-一、进程间通信方式" href="#一、进程间通信方式"><span>一、进程间通信方式</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-1、管道-pipe" href="#1-1、管道-pipe"><span>1.1、管道(pipe)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-1-1、通信" href="#1-1-1、通信"><span>1.1.1、通信</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-1-2、创建" href="#1-1-2、创建"><span>1.1.2、创建</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-1-3、读写" href="#1-1-3、读写"><span>1.1.3、读写</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-1-4、程序实例" href="#1-1-4、程序实例"><span>1.1.4、程序实例</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-2、命名管道-named-pipe-FIFO" href="#1-2、命名管道-named-pipe-FIFO"><span>1.2、命名管道(named pipe&amp;#x2F;FIFO)</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-3、信号量-semaphore" href="#1-3、信号量-semaphore"><span>1.3、信号量(semaphore)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-3-1、工作原理" href="#1-3-1、工作原理"><span>1.3.1、工作原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-3-2、信号量机制" href="#1-3-2、信号量机制"><span>1.3.2、信号量机制</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-4、消息队列-message-queue" href="#1-4、消息队列-message-queue"><span>1.4、消息队列(message queue)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-4-1、消息队列与内核的联系" href="#1-4-1、消息队列与内核的联系"><span>1.4.1、消息队列与内核的联系</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-4-2、消息队列的操作" href="#1-4-2、消息队列的操作"><span>1.4.2、消息队列的操作</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-5、信号-signal" href="#1-5、信号-signal"><span>1.5、信号(signal)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-5-1、信号来源、种类" href="#1-5-1、信号来源、种类"><span>1.5.1、信号来源、种类</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-5-2、信号种类" href="#1-5-2、信号种类"><span>1.5.2、信号种类</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-6、共享内存-shared-memory" href="#1-6、共享内存-shared-memory"><span>1.6、共享内存(shared memory)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-6-1、系统V共享内存原理" href="#1-6-1、系统V共享内存原理"><span>1.6.1、系统V共享内存原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-6-2、系统V共享内存API" href="#1-6-2、系统V共享内存API"><span>1.6.2、系统V共享内存API</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-7、套接字-socket" href="#1-7、套接字-socket"><span>1.7、套接字(socket)</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-8、全双工管道" href="#1-8、全双工管道"><span>1.8、全双工管道</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-二、线程间通信" href="#二、线程间通信"><span>二、线程间通信</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-2-1、锁机制" href="#2-1、锁机制"><span>2.1、锁机制</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-2、互斥锁" href="#2-2、互斥锁"><span>2.2、互斥锁</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-3、读写锁" href="#2-3、读写锁"><span>2.3、读写锁</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-4、条件变量" href="#2-4、条件变量"><span>2.4、条件变量</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-5、信号量机制-Semaphore" href="#2-5、信号量机制-Semaphore"><span>2.5、信号量机制(Semaphore)</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-6、信号机制-signal" href="#2-6、信号机制-signal"><span>2.6、信号机制(signal)</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/avatar.png" alt="宇宙の騎士"></figure><p class="title is-size-4 is-block line-height-inherit">宇宙の騎士</p><p class="is-size-6 is-block">博学之，审问之，慎思之，明辩之，笃行之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>罗生门</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">86</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">113</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">126</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://beyondhxl.com/about/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/beyondhxl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:459898432@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Note" href="http://beyondhxl.com/mydocs/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/post/784ee20b.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%93%86%E5%95%A6A%E6%A2%A6/ChMkJ1bKxwqIcn_mAANXBz3B3OEAALHuQCNRZEAA1cf424.jpg" alt="WSL-Windows上的Linux子系统"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-28T18:35:31.000Z">2021-01-28</time></p><p class="title is-6"><a class="link-muted" href="/post/784ee20b.html">WSL-Windows上的Linux子系统</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> / <a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WSL/">WSL</a></p></div></article><article class="media"><a class="media-left" href="/post/977a8d62.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wguYKIOjHjAARfEgchsmAAAt9XgKb_1EABF8q200.jpg" alt="TCP网络编程常用工具(转载)"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-15T00:03:46.000Z">2020-08-15</time></p><p class="title is-6"><a class="link-muted" href="/post/977a8d62.html">TCP网络编程常用工具(转载)</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> / <a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">网络工具命令</a></p></div></article><article class="media"><a class="media-left" href="/post/3294d6b6.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJlwslleIACs_AAiLFiW8JwMAAuITgDEZnEACIsu836.jpg" alt="数据结构与算法-二叉搜索树"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-13T23:52:30.000Z">2020-08-13</time></p><p class="title is-6"><a class="link-muted" href="/post/3294d6b6.html">数据结构与算法-二叉搜索树</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a></p></div></article><article class="media"><a class="media-left" href="/post/43ed0d63.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wslluIDUsWAAJOteVG-6YAAuITgEOUE4AAk7N608.jpg" alt="如何优雅地关闭Go语言的通道channel"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-11T00:07:23.000Z">2020-08-11</time></p><p class="title is-6"><a class="link-muted" href="/post/43ed0d63.html">如何优雅地关闭Go语言的通道channel</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Golang/">Golang</a> / <a class="link-muted" href="/categories/Golang/%E9%80%9A%E9%81%93channel/">通道channel</a></p></div></article><article class="media"><a class="media-left" href="/post/8ce5f219.html"><p class="image is-64x64"><img class="thumbnail" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F/ChMkJ1wg0UuIMmMwAAdhOUUDAxwAAt9dgGqYjcAB2FR003.jpg" alt="深度探索C++对象模型（DataMember的布局）"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-08T00:21:09.000Z">2020-08-08</time></p><p class="title is-6"><a class="link-muted" href="/post/8ce5f219.html">深度探索C++对象模型（DataMember的布局）</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/C/">C++</a> / <a class="link-muted" href="/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">对象模型</a> / <a class="link-muted" href="/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%B8%83%E5%B1%80/">对象成员布局</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/C-11/"><span class="level-start"><span class="level-item">C++11</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/C-11/initializer-list/"><span class="level-start"><span class="level-item">initializer_list</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/String/"><span class="level-start"><span class="level-item">String</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/epoll/"><span class="level-start"><span class="level-item">epoll</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/"><span class="level-start"><span class="level-item">内存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><span class="level-start"><span class="level-item">内存分配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/malloc%E3%80%81new/"><span class="level-start"><span class="level-item">malloc、new</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/C/%E5%86%85%E5%AD%98/%E6%A6%82%E5%BF%B5/"><span class="level-start"><span class="level-item">概念</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/epoll/"><span class="tag">epoll</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B/"><span class="tag">进程</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span class="tag">面向对象</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=beyondhxl/XZjz&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="beyondhxl/XZjz" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/logo1.png" alt="宇宙の騎士" height="28"></a><p class="size-small"><span>&copy; 2024 beyondhxl</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2020/04/15 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="8044353" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.beyondhxl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('6e19ff696a6246d4da8b','1518ab0356e2eeaecbdbd5efd9b654cd5c224c93','beyondhxl','blogcomment',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('6e19ff696a6246d4da8b','1518ab0356e2eeaecbdbd5efd9b654cd5c224c93','beyondhxl','blogcomment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>