<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇宙の騎士</title>
  
  <subtitle>千里之行，始于足下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.beyondhxl.com/"/>
  <updated>2024-08-02T20:36:09.804Z</updated>
  <id>https://www.beyondhxl.com/</id>
  
  <author>
    <name>beyondhxl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSL-Windows上的Linux子系统</title>
    <link href="https://www.beyondhxl.com/post/784ee20b.html"/>
    <id>https://www.beyondhxl.com/post/784ee20b.html</id>
    <published>2021-01-28T18:35:31.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对工作环境为 Windows，开发目标环境为 Linux 的人来说是比较合适的。</p></blockquote><a id="more"></a><p>WSL 最大的好处就是整个工作环境可以无缝衔接，比如后台服务在 linux 下开发和部署，前端 app 项目在 win 下调试。</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1-1、官方文档"><a href="#1-1、官方文档" class="headerlink" title="1.1、官方文档"></a>1.1、官方文档</h3><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">适用于 Linux 的 Windows 子系统文档</a></p><h3 id="1-2、安装步骤"><a href="#1-2、安装步骤" class="headerlink" title="1.2、安装步骤"></a>1.2、安装步骤</h3><p>1、打开控制面板——程序和功能——启用或关闭 Windows 功能——适用于 Linux 的 Windows 子系统——重启系统</p><p>2、打开 Microsoft Store —— 搜索并安装 Ubuntu ——启动 Ubuntu —— 输入用户名和两遍密码完成安装</p><h3 id="1-3、root密码"><a href="#1-3、root密码" class="headerlink" title="1.3、root密码"></a>1.3、root密码</h3><p>Ubuntu 的默认 root 密码是随机的，即每次开机都有一个新的 root 密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，回车 Enter，终端会提示我们输入新的密码并确认，此时的密码就是 root 新密码。修改成功后，输入命令 su root，再输入新的密码就可以切换了。</p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><h3 id="2-1、Unable-to-locate-package错误解决办法"><a href="#2-1、Unable-to-locate-package错误解决办法" class="headerlink" title="2.1、Unable to locate package错误解决办法"></a>2.1、Unable to locate package错误解决办法</h3><p>当用 apt-get 更新软件包时，常出现错误提示 Unable to locate package update，尤其是在 ubuntu server 上，解决方法是：先 sudo apt-get update 再 sudo apt-get install 就可以了。</p><p><strong>参考文章</strong>:<br><a href="https://github.com/SuperManito/JD-FreeFuck/wiki/Windows10-Install-WSL-Ubuntu">Windows10 Install WSL Ubuntu</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对工作环境为 Windows，开发目标环境为 Linux 的人来说是比较合适的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="WSL" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WSL/"/>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="https://www.beyondhxl.com/tags/OS/"/>
    
      <category term="WSL" scheme="https://www.beyondhxl.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>TCP网络编程常用工具(转载)</title>
    <link href="https://www.beyondhxl.com/post/977a8d62.html"/>
    <id>https://www.beyondhxl.com/post/977a8d62.html</id>
    <published>2020-08-15T00:03:46.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>ping、ifconfig、netstat、lsof、tcpdump</strong></p></blockquote><a id="more"></a><p>其实在平常使用套接字开发和测试过程中，我们总会碰到这样或那样的问题。学会对这些问题进行诊断和分析，其实需要不断地积累经验。而   Linux 平台下提供的各种网络工具，则为我们进行诊断分析提供了很好的帮助。</p><h3 id="一、ping"><a href="#一、ping" class="headerlink" title="一、ping"></a>一、ping</h3><p>这个命令我想大家都不陌生，“ping” 这个命名来自于声呐探测，在网络上用来完成对网络连通性的探测，这个命名可以说是恰如其分了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">ping</span> <span class="string">www.sina.com.cn</span></span><br><span class="line"><span class="string">PING</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124)</span> <span class="number">56</span><span class="string">(84)</span> <span class="string">bytes</span> <span class="string">of</span> <span class="string">data.</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=1</span> <span class="string">ttl=63</span> <span class="string">time=8.64</span> <span class="string">ms</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=2</span> <span class="string">ttl=63</span> <span class="string">time=11.3</span> <span class="string">ms</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=3</span> <span class="string">ttl=63</span> <span class="string">time=8.66</span> <span class="string">ms</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=4</span> <span class="string">ttl=63</span> <span class="string">time=13.7</span> <span class="string">ms</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=5</span> <span class="string">ttl=63</span> <span class="string">time=8.22</span> <span class="string">ms</span></span><br><span class="line"><span class="number">64</span> <span class="string">bytes</span> <span class="string">from</span> <span class="string">www.sina.com.cn</span> <span class="string">(202.102.94.124):</span> <span class="string">icmp_seq=6</span> <span class="string">ttl=63</span> <span class="string">time=7.99</span> <span class="string">ms</span></span><br><span class="line"><span class="string">^C</span></span><br><span class="line"><span class="string">---</span> <span class="string">www.sina.com.cn</span> <span class="string">ping</span> <span class="string">statistics</span> <span class="string">---</span></span><br><span class="line"><span class="number">6</span> <span class="string">packets</span> <span class="string">transmitted,</span> <span class="number">6</span> <span class="string">received,</span> <span class="number">0</span><span class="string">%</span> <span class="string">packet</span> <span class="string">loss,</span> <span class="string">time</span> <span class="string">5006ms</span></span><br><span class="line"><span class="string">rtt</span> <span class="string">min/avg/max/mdev</span> <span class="string">=</span> <span class="number">7.997</span><span class="string">/9.782/13.795/2.112</span> <span class="string">ms</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我使用 ping 命令探测了和新浪网的网络连通性。可以看到，每次显示是按照 sequence 序列号排序显示的，一并显示的，也包括 TTL（time to live），反映了两个 IP 地址之间传输的时间。最后还显示了 ping 命令的统计信息，如最小时间、平均时间等。</p><p>我们需要经常和 Linux 下的 ping 命令打交道，那么 ping 命令的原理到底是什么呢？它是基于 TCP 还是 UDP 开发的？</p><p>其实，ping 是基于一种叫做 ICMP 的协议开发的，ICMP 又是一种基于 IP 协议的控制协议，翻译为网际控制协议，其报文格式如下图：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/ping.png" alt=""></p><p>ICMP 在 IP 报文后加入了新的内容，这些内容包括：</p><ul><li>类型：即 ICMP 的类型，其中 ping 的请求类型为 0，应答为 8。</li><li>代码：进一步划分 ICMP 的类型, 用来查找产生错误的原因。</li><li>校验和：用于检查错误的数据。</li><li>标识符：通过标识符来确认是谁发送的控制协议，可以是进程 ID。</li><li>序列号：唯一确定的一个报文，前面 ping 名字执行后显示的 icmp_seq 就是这个值。</li></ul><p>当我们发起 ping 命令时，ping 程序实际上会组装成如图的一个 IP 报文。报文的目的地址为 ping 的目标地址，源地址就是发送 ping 命令时的主机地址，同时按照 ICMP 报文格式填上数据，在可选数据上可以填上发送时的时间戳。</p><p>IP 报文通过 ARP 协议，源地址和目的地址被翻译成 MAC 地址，经过数据链路层后，报文被传输出去。当报文到达目的地址之后，目的地址所在的主机也按照 ICMP 协议进行应答。之所以叫做协议，是因为双方都会遵守这个报文格式，并且也会按照格式进行发送 - 应答。</p><p>应答数据到达源地址之后，ping 命令可以通过再次解析 ICMP 报文，对比序列号，计算时间戳等来完成每个发送 - 应答的显示，最终显示的格式就像前面的例子中展示的一样。</p><p>可以说，ICMP 协议为我们侦测网络问题提供了非常好的支持。另外一种对路由的检测命令 Traceroute 也是通过 ICMP 协议来完成的，这里就不展开讲了。</p><h3 id="二、ifconfig"><a href="#二、ifconfig" class="headerlink" title="二、ifconfig"></a>二、ifconfig</h3><p>很多熟悉 Windows 的同学都知道 Windows 有一个 ipconfig 命令，用来显示当前的网络设备列表。事实上，Linux 有一个对应的命令叫做 ifconfig，也用来显示当前系统中的所有网络设备，通俗一点的说，就是网卡列表。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">vagrant@ubuntu-xenial-01:~$</span> <span class="string">ifconfig</span></span><br><span class="line"><span class="string">cni0</span>      <span class="string">Link</span> <span class="string">encap:Ethernet</span>  <span class="string">HWaddr</span> <span class="string">0a:58:0a:f4:00:01</span></span><br><span class="line">          <span class="string">inet</span> <span class="string">addr:10.244.0.1</span>  <span class="string">Bcast:0.0.0.0</span>  <span class="string">Mask:255.255.255.0</span></span><br><span class="line">          <span class="attr">inet6 addr:</span> <span class="string">fe80::401:b4ff:fe51:bcf9/64</span> <span class="string">Scope:Link</span></span><br><span class="line">          <span class="string">UP</span> <span class="string">BROADCAST</span> <span class="string">RUNNING</span> <span class="string">MULTICAST</span>  <span class="string">MTU:1450</span>  <span class="string">Metric:1</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">packets:2133</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">frame:0</span></span><br><span class="line">          <span class="string">TX</span> <span class="string">packets:2216</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">carrier:0</span></span><br><span class="line">          <span class="string">collisions:0</span> <span class="string">txqueuelen:1000</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">bytes:139381</span> <span class="string">(139.3</span> <span class="string">KB)</span>  <span class="string">TX</span> <span class="string">bytes:853302</span> <span class="string">(853.3</span> <span class="string">KB)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">docker0</span>   <span class="string">Link</span> <span class="string">encap:Ethernet</span>  <span class="string">HWaddr</span> <span class="number">02</span><span class="string">:42:93:0f:f7:11</span></span><br><span class="line">          <span class="string">inet</span> <span class="string">addr:172.17.0.1</span>  <span class="string">Bcast:0.0.0.0</span>  <span class="string">Mask:255.255.0.0</span></span><br><span class="line">          <span class="attr">inet6 addr:</span> <span class="string">fe80::42:93ff:fe0f:f711/64</span> <span class="string">Scope:Link</span></span><br><span class="line">          <span class="string">UP</span> <span class="string">BROADCAST</span> <span class="string">RUNNING</span> <span class="string">MULTICAST</span>  <span class="string">MTU:1500</span>  <span class="string">Metric:1</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">packets:653</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">frame:0</span></span><br><span class="line">          <span class="string">TX</span> <span class="string">packets:685</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">carrier:0</span></span><br><span class="line">          <span class="string">collisions:0</span> <span class="string">txqueuelen:0</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">bytes:49542</span> <span class="string">(49.5</span> <span class="string">KB)</span>  <span class="string">TX</span> <span class="string">bytes:430826</span> <span class="string">(430.8</span> <span class="string">KB)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">enp0s3</span>    <span class="string">Link</span> <span class="string">encap:Ethernet</span>  <span class="string">HWaddr</span> <span class="number">02</span><span class="string">:54:ad:ea:60:2e</span></span><br><span class="line">          <span class="string">inet</span> <span class="string">addr:10.0.2.15</span>  <span class="string">Bcast:10.0.2.255</span>  <span class="string">Mask:255.255.255.0</span></span><br><span class="line">          <span class="attr">inet6 addr:</span> <span class="string">fe80::54:adff:feea:602e/64</span> <span class="string">Scope:Link</span></span><br><span class="line">          <span class="string">UP</span> <span class="string">BROADCAST</span> <span class="string">RUNNING</span> <span class="string">MULTICAST</span>  <span class="string">MTU:1500</span>  <span class="string">Metric:1</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">packets:7951</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">frame:0</span></span><br><span class="line">          <span class="string">TX</span> <span class="string">packets:4123</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">carrier:0</span></span><br><span class="line">          <span class="string">collisions:0</span> <span class="string">txqueuelen:1000</span></span><br><span class="line">          <span class="string">RX</span> <span class="string">bytes:5081047</span> <span class="string">(5.0</span> <span class="string">MB)</span>  <span class="string">TX</span> <span class="string">bytes:385600</span> <span class="string">(385.6</span> <span class="string">KB)</span></span><br></pre></td></tr></table></figure><p>我稍微解释一下这里面显示的数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Link</span> <span class="string">encap:Ethernet</span>  <span class="string">HWaddr</span> <span class="number">02</span><span class="string">:54:ad:ea:60:2e</span></span><br></pre></td></tr></table></figure><p>上面这段表明这是一个以太网设备，MAC 地址为 02:54:ad:ea:60:2e。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">inet</span> <span class="string">addr:10.0.2.15</span>  <span class="string">Bcast:10.0.2.255</span>  <span class="string">Mask:255.255.255.0</span></span><br><span class="line"><span class="attr">inet6 addr:</span> <span class="string">fe80::54:adff:feea:602e/64</span> <span class="string">Scope:Link</span></span><br></pre></td></tr></table></figure><p>这里显示的是网卡的 IPv4 和 IPv6 地址，其中 IPv4 还显示了该网络的子网掩码以及广播地址。</p><p>在每个 IPv4 子网中，有一个特殊地址被保留作为子网广播地址，比如这里的 10.0.2.255 就是这个子网的广播地址。当向这个地址发送请求时，就会向以太网网络上的一组主机发送请求。</p><p>通常来说，这种被称作广播（broadcast）的技术，是用 UDP 来实现的。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">UP</span> <span class="string">BROADCAST</span> <span class="string">RUNNING</span> <span class="string">MULTICAST</span>  <span class="string">MTU:1500</span>  <span class="string">Metric:1</span></span><br></pre></td></tr></table></figure><p>这里显示的是网卡的状态，MTU 是最大传输单元的意思，表示的是链路层包的大小。1500 表示的是字节大小。</p><p>Metric 大家可能不知道是干啥用的，这里解释下，Linux 在一台主机上可以有多个网卡设备，很可能有这么一种情况，多个网卡可以路由到目的地。一个简单的例子是在同时有无线网卡和有线网卡的情况下，网络连接是从哪一个网卡设备上出去的？Metric 就是用来确定多块网卡的优先级的，数值越小，优先级越高，1 为最高级。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">RX</span> <span class="string">packets:7951</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">frame:0</span></span><br><span class="line"><span class="string">TX</span> <span class="string">packets:4123</span> <span class="string">errors:0</span> <span class="string">dropped:0</span> <span class="string">overruns:0</span> <span class="string">carrier:0</span></span><br><span class="line"><span class="string">collisions:0</span> <span class="string">txqueuelen:1000</span></span><br><span class="line"><span class="string">RX</span> <span class="string">bytes:5081047</span> <span class="string">(5.0</span> <span class="string">MB)</span>  <span class="string">TX</span> <span class="string">bytes:385600</span> <span class="string">(385.6</span> <span class="string">KB)</span></span><br></pre></td></tr></table></figure><h3 id="三、netstat-和-lsof"><a href="#三、netstat-和-lsof" class="headerlink" title="三、netstat 和 lsof"></a>三、netstat 和 lsof</h3><p>在平时的工作中，我们最常碰到的问题就是某某进程对应的网络状况如何？是不是连接被打爆了？还是有大量的 TIME_WAIT 连接？</p><p>netstat 可以帮助我们了解当前的网络连接状况，比如我想知道当前所有的连接详情，就可以使用下面这行命令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">netstat</span> <span class="string">-alepn</span></span><br></pre></td></tr></table></figure><p>可能的结果为：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/netstat.jpg" alt=""></p><p>netstat 会把所有 IPv4 形态的 TCP，IPV6 形态的 TCP、UDP 以及 UNIX 域的套接字都显示出来。</p><p>对于 TCP 类型来说，最大的好处是可以清楚地看到一条 TCP 连接的四元组（源地址、源端口、目的地地址和目的端口）。</p><p>例如这里的一条信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcp</span>        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2379</span>          <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:52464</span>         <span class="string">ESTABLISHED</span> <span class="number">0</span>          <span class="number">27710</span>       <span class="number">3496</span><span class="string">/etcd</span></span><br></pre></td></tr></table></figure><p>它表达的意思是本地 127.0.0.1 的端口 52464 连上本地 127.0.0.1 的端口 2379，状态为 ESTABLISHED，本地进程为 etcd，进程为 3496。</p><p>这在实战分析的时候非常有用，比如你可以很方便地知道，在某个时候是不是有很多 TIME_WAIT 的 TCP 连接，导致端口号被占用光，以致新的连接分配不了。</p><p>当然，我们也可以只对 UNIX 套接字进行筛查。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">netstat</span> <span class="string">Socket</span> <span class="string">-x</span> <span class="string">-alepn</span></span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/netstat1.jpg" alt=""></p><p>UNIX 套接字的结果稍有不同，最关键的信息是 Path，这个信息显示了本地套接字监听的文件路径，比如这条：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">unix</span>  <span class="number">3</span>      <span class="string">[</span> <span class="string">]</span>         <span class="string">STREAM</span>     <span class="string">CONNECTED</span>     <span class="number">23209</span>    <span class="number">1400</span><span class="string">/dockerd</span>        <span class="string">/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><p>这其实就是大名鼎鼎的 Docker 在本地套接字的监听路径。/var/run/docker.sock 是本地套接字监听地址，dockerd 是进程名称，1400 是进程号。</p><p>netstat 命令可以选择的参数非常之多，这里只关注了几个简单的场景，你可以通过帮助命令或者查阅文档获得更多的信息。</p><p>lsof 的常见用途之一是帮助我们找出在指定的 IP 地址或者端口上打开套接字的进程，而 netstat 则告诉我们 IP 地址和端口使用的情况，以<br>及各个 TCP 连接的状态。lsof 和 netstst 可以结合起来一起使用。</p><p>比如说，我们可以通过 lsof 查看到底是谁打开了这个文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsof</span> <span class="string">/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><p>下面这张图显示了是 dockerd 打开了这个本地文件套接字：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/lsof.jpg" alt=""></p><p>lsof 还有一个非常常见的用途。如果我们启动了一个服务器程序，发现这个服务器需要绑定的端口地址已经被占用，内核报出“该地址已在使用”的出错信息，我们可以使用 lsof 找出正在使用该端口的那个进程。比如下面这个代码，就帮我们找到了使用 8080 端口的那个进程，从而帮助我们定位问题。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsof</span> <span class="string">-i</span> <span class="string">:8080</span></span><br></pre></td></tr></table></figure><h3 id="四、tcpdump"><a href="#四、tcpdump" class="headerlink" title="四、tcpdump"></a>四、tcpdump</h3><p>tcpdump 这样的抓包工具对于网络编程而言是非常有用的，特别是在一些“山重水复疑无路”的情形下，通过 tcpdump 这样的抓包工具，往往可以达到“柳暗花明又一村”的效果。</p><p>tcpdump 具有非常强大的过滤和匹配功能。</p><p>比如说指定网卡：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcpdump</span> <span class="string">-i</span> <span class="string">eth0</span></span><br></pre></td></tr></table></figure><p>再比如说指定来源：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcpdump</span> <span class="string">src</span> <span class="string">host</span> <span class="string">hostname</span></span><br></pre></td></tr></table></figure><p>我们再来一个复杂一点的例子。这里抓的包是 TCP，且端口是 80，包来自 IP 地址为 192.168.1.25 的主机地址。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcpdump</span> <span class="string">'tcp and port 80 and src host 192.168.1.25'</span></span><br></pre></td></tr></table></figure><p>如果我们对 TCP 协议非常熟悉，还可以写出这样的 tcpdump 命令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tcpdump</span> <span class="string">'tcp and port 80 and tcp[13:1]&amp;2 != 0'</span></span><br></pre></td></tr></table></figure><p>这里 tcp[13:1] 表示的是 TCP 头部开始处偏移为 13 的字节，如果这个值为 2，说明设置了 SYN 分节，当然，我们也可以设置成其他值来获取希望类型的分节。注意，这里的偏移是从 0 开始算起的，tcp[13]其实是报文里的第 14 个字节。</p><p>tcpdump 在开启抓包的时候，会自动创建一个类型为 AF_PACKET 的网络套接口，并向系统内核注册。当网卡接收到一个网络报文之后，它会遍历系统中所有已经被注册的网络协议，包括其中已经注册了的 AF_PACKET 网络协议。系统内核接下来就会将网卡收到的报文发送给该协议的回调函数进行一次处理，回调函数可以把接收到的报文完完整整地复制一份，假装是自己接收到的报文，然后交给 tcpdump 程序，进行各种条件的过滤和判断，再对报文进行解析输出。</p><p>下面这张图显示的是 tcpdump 的输出格式：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/tcpdump.jpg" alt=""></p><p>首先我们看到的是时间戳，之后类似 192.168.33.11.41388 &gt; 192.168.33.11.6443 这样的，显示的是源地址（192.168.33.11.41388）到目的地址（192.168.33.11.6443）；然后 Flags [ ]是包的标志，[P]表示是数据推送，比较常见的包格式如下：</p><ul><li>[S]：SYN，表示开始连接</li><li>[.]：没有标记，一般是确认</li><li>[P]：PSH，表示数据推送</li><li>[F]：FIN，表示结束连接</li><li>[R] ：RST，表示重启连接</li></ul><p>我们可以看到最后有几个数据，它们代表的含义如下：</p><ul><li>seq：包序号，就是 TCP 的确认分组</li><li>cksum：校验码</li><li>win：滑动窗口大小</li><li>length：承载的数据（payload）长度 length，如果没有数据则为 0</li></ul><p>此外，tcpdump 还可以对每条 TCP 报文的细节进行显示，让我们可以看到每条报文的详细字节信息。这在对报文进行排查的时候很有用。</p><h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><p>我再来总结一下这几个命令的作用：</p><ul><li>ping 可以用来帮助我们进行网络连通性的探测。</li><li>ifconfig，用来显示当前系统中的所有网络设备。</li><li>netstat 和 lsof 可以查看活动的连接状况。</li><li>tcpdump 可以对各种奇怪的环境进行抓包，进而帮我们了解报文，排查问题。</li></ul><h3 id="六、问答"><a href="#六、问答" class="headerlink" title="六、问答"></a>六、问答</h3><p>1、tcpdump 这个工具还可以对 UDP 包进行抓包处理吗？</p><ul><li>tcpdump 可以抓 UDP，指定端口就可以。</li><li>tcpdump 还可以导出文件 pcap，放到 wireshark 中进一步分析。</li></ul><p>2、Foreign Address 显示的 <em>.</em> 表示的是什么意思呢？</p><p>这个套接字正在监听端口等待连接进来，允许任何地址、任何端口来建立连接。</p><p><strong>参考文章</strong>:<br><a href="https://time.geekbang.org/column/article/118990">工欲善其事必先利其器：学会使用各种工具</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ping、ifconfig、netstat、lsof、tcpdump&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://www.beyondhxl.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络工具命令" scheme="https://www.beyondhxl.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="计算机网络" scheme="https://www.beyondhxl.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://www.beyondhxl.com/tags/TCP/"/>
    
      <category term="ping" scheme="https://www.beyondhxl.com/tags/ping/"/>
    
      <category term="ifconfig" scheme="https://www.beyondhxl.com/tags/ifconfig/"/>
    
      <category term="netstat" scheme="https://www.beyondhxl.com/tags/netstat/"/>
    
      <category term="lsof" scheme="https://www.beyondhxl.com/tags/lsof/"/>
    
      <category term="tcpdump" scheme="https://www.beyondhxl.com/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二叉搜索树</title>
    <link href="https://www.beyondhxl.com/post/3294d6b6.html"/>
    <id>https://www.beyondhxl.com/post/3294d6b6.html</id>
    <published>2020-08-13T23:52:30.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>二叉搜索树</strong></p></blockquote><a id="more"></a><h3 id="一、什么是二叉搜索树"><a href="#一、什么是二叉搜索树" class="headerlink" title="一、什么是二叉搜索树"></a>一、什么是二叉搜索树</h3><p>二叉搜索树（binary search tree, BST）也叫排序的二叉树，根节点比左边子树的所有节点都大，比右边子树上的所有节点都小，如下图就是一个二叉搜索树:</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/bst.png" alt=""></p><p>要实现一个二叉搜索树，我们需要实现节点的插入和删除，要实现节点的查找（搜索），要实现前序遍历、中序遍历和后序遍历，要实现最大节点和最小节点的查找。</p><h3 id="二、定义基本数据结构"><a href="#二、定义基本数据结构" class="headerlink" title="二、定义基本数据结构"></a>二、定义基本数据结构</h3><p>常规地，我们定义节点的类型，每个节点包含它的值以及左右节点。因为目前 Go 泛型还没有发布，所以这里我们实现一个元素为 int 类型的具体的二叉搜索树，等泛型实现后可以改成抽象的二叉搜索树。</p><p>树只要包含根节点可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node 定义节点</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int</span>   <span class="comment">// 因为目前Go的泛型还没有发布，所以我们这里以一个int具体类型为例</span></span><br><span class="line">left  *Node <span class="comment">// 左子节点</span></span><br><span class="line">right *Node <span class="comment">// 右子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 是一个节点的值为int类型的二叉搜索树</span></span><br><span class="line"><span class="keyword">type</span> BST <span class="keyword">struct</span> &#123;</span><br><span class="line">root *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、插入和删除"><a href="#三、插入和删除" class="headerlink" title="三、插入和删除"></a>三、插入和删除</h3><p>既然是一棵树，就需要增加节点用来构造树，大部分情况下也需要删除节点。</p><p>增加节点的时候，需要判断应该往左边子树上添加，还是往右边子树上添加。天然地，既然二叉搜索树是一个有序的，那么我们就可以进行比较，然后递归的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert 插入一个元素.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Insert</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;value, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">// 如果二叉树为空，那么这个节点就当作跟节点</span></span><br><span class="line"><span class="keyword">if</span> bst.root == <span class="literal">nil</span> &#123;</span><br><span class="line">bst.root = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(bst.root, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根节点依次比较</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertNode</span><span class="params">(root, newNode *Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> newNode.value &lt; root.value &#123; <span class="comment">// 应该放到根节点的左边</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123;</span><br><span class="line">root.left = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(root.left, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> newNode.value &gt; root.value &#123; <span class="comment">// 应该放到根节点的右边</span></span><br><span class="line"><span class="keyword">if</span> root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">root.right = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insertNode(root.right, newNode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则等于根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除有些麻烦，如果是删除叶节点就比较容易，删除即可。但是如果不是删除叶节点，那么就需要将子节点提升。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove 删除一个元素.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Remove</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, existed := remove(bst.root, value)</span><br><span class="line"><span class="keyword">return</span> existed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来递归移除节点的辅助方法.</span></span><br><span class="line"><span class="comment">// 返回替换root的新节点，以及元素是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(root *Node, value <span class="keyword">int</span>)</span> <span class="params">(*Node, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> existed <span class="keyword">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从左边找</span></span><br><span class="line">    <span class="keyword">if</span> value &lt; root.value &#123;</span><br><span class="line">root.left, existed = remove(root.left, value)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从右边找</span></span><br><span class="line">    <span class="keyword">if</span> value &gt; root.value &#123;</span><br><span class="line">root.right, existed = remove(root.right, value)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此节点正是要移除的节点,那么返回此节点，同时返回之前可能需要调整.</span></span><br><span class="line">    existed = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此节点没有孩子，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> root, existed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子节点为空, 提升右子节点</span></span><br><span class="line">    <span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = root.right</span><br><span class="line">        <span class="keyword">return</span> root, existed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果右子节点为空, 提升左子节点</span></span><br><span class="line">    <span class="keyword">if</span> root.right == <span class="literal">nil</span> &#123;</span><br><span class="line">root = root.left</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左右节点都存在,那么从右边节点找到一个最小的节点提升，这个节点肯定比左子树所有节点都大.</span></span><br><span class="line">    <span class="comment">// 也可以从左子树节点中找一个最大的提升，道理一样.</span></span><br><span class="line">    smallestInRight, _ := min(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提升</span></span><br><span class="line">    root.value = smallestInRight</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从右边子树中移除此节点</span></span><br><span class="line">    root.right, _ = remove(root.right, smallestInRight)</span><br><span class="line"><span class="keyword">return</span> root, existed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、搜索"><a href="#四、搜索" class="headerlink" title="四、搜索"></a>四、搜索</h3><p>检查一个节点是否存在比较简单，因为二叉搜索树是有序的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search 搜索元素(检查元素是否存在)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Search</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> search(bst.root, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(n *Node, value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value &lt; n.value &#123;</span><br><span class="line"><span class="keyword">return</span> search(n.left, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value &gt; n.value &#123;</span><br><span class="line"><span class="keyword">return</span> search(n.right, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们还可以实现查找一个二叉搜索树的最大最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Min 二叉搜索树中的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Min</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> min(bst.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(node *Node)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">n := node</span><br><span class="line"><span class="comment">// 从左边找</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.left == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">n = n.left</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 二叉搜索树中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">Max</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> max(bst.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(node *Node)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">n := node</span><br><span class="line"><span class="comment">// 从右边找</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">n = n.right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、遍历"><a href="#五、遍历" class="headerlink" title="五、遍历"></a>五、遍历</h3><p>可以实现先序遍历、中序遍历和后序遍历，先中后指的是根节点相对子节点的处理顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreOrderTraverse 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">PreOrderTraverse</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">preOrderTraverse(bst.root, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrderTraverse</span><span class="params">(n *Node, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">f(n.value) <span class="comment">// 前</span></span><br><span class="line">preOrderTraverse(n.left, f)</span><br><span class="line">preOrderTraverse(n.right, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostOrderTraverse 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bst *BST)</span> <span class="title">PostOrderTraverse</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">postOrderTraverse(bst.root, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postOrderTraverse</span><span class="params">(n *Node, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">postOrderTraverse(n.left, f)</span><br><span class="line">postOrderTraverse(n.right, f)</span><br><span class="line">f(n.value) <span class="comment">// 后</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考原文</strong>:<br><a href="https://colobu.com/2020/07/15/implement-bst-in-Go/">用Go撸一个二叉搜索树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.beyondhxl.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉搜索树" scheme="https://www.beyondhxl.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    
      <category term="二叉搜索树" scheme="https://www.beyondhxl.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="数据结构" scheme="https://www.beyondhxl.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地关闭Go语言的通道channel</title>
    <link href="https://www.beyondhxl.com/post/43ed0d63.html"/>
    <id>https://www.beyondhxl.com/post/43ed0d63.html</id>
    <published>2020-08-11T00:07:23.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Go channel的关闭</strong></p></blockquote><a id="more"></a><h3 id="一、Go-channel设计和规范的问题"><a href="#一、Go-channel设计和规范的问题" class="headerlink" title="一、Go channel设计和规范的问题"></a>一、Go channel设计和规范的问题</h3><ol><li>在不能更改 channel 状态的情况下，没有简单普遍的方式来检查 channel 是否已经关闭了</li><li>关闭已经关闭的 channel 会导致 panic，所以在 closer（关闭者）不知道 channel 是否已经关闭的情况下去关闭 channel 是很危险的</li><li>发送值到已经关闭的 channel 会导致 panic，所以如果 sender（发送者）在不知道 channel 是否已经关闭的情况下去向 channel 发送值是很危险的</li></ol><p>是的，没有一个内置函数可以检查一个 channel 是否已经关闭。如果你能确定不会向 channel 发送任何值，那么也确实需要一个简单的方法来检查 channel 是否已经关闭：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">    fmt.Println(IsClosed(c)) <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    fmt.Println(IsClosed(c)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经提到了，没有一种适用的方式来检查 channel 是否已经关闭了。但是，就算有一个简单的 <code>closed(chan T) bool</code> 函数来检查 channel 是否已经关闭，它的用处还是很有限的，就像内置的 <code>len</code> 函数用来检查缓冲 channel 中元素数量一样。<strong>原因就在于，已经检查过的 channel 的状态有可能在调用了类似的方法返回之后就修改了，因此返回来的值已经不能够反映刚才检查的 channel 的当前状态了</strong>。</p><p>尽管在调用 closed(ch) 返回 true 的情况下停止向 channel 发送值是可以的，但是如果调用 closed(ch) 返回 false，那么关闭 channel 或者继续向 channel 发送值就不安全了（会 panic）。</p><h3 id="二、The-Channel-Closing-Principle"><a href="#二、The-Channel-Closing-Principle" class="headerlink" title="二、The Channel Closing Principle"></a>二、The Channel Closing Principle</h3><p>在使用 Go channel 的时候，一个适用的原则是不要从接收端关闭 channel，也不要关闭有多个并发发送者的 channel。换句话说，如果 sender（发送者）只是 channel 唯一的 sender 或者是 channel 最后一个活跃的 sender，那么你应该在 sender 的 goroutine 关闭 channel，从而通知 receiver(s)（接收者们）已经没有值可以读了。维持这条原则将保证永远不会发生向一个已经关闭的 channel 发送值或者关闭一个已经关闭的 channel。</p><h3 id="三、打破-channel-closing-principle-的解决方案"><a href="#三、打破-channel-closing-principle-的解决方案" class="headerlink" title="三、打破 channel closing principle 的解决方案"></a>三、打破 channel closing principle 的解决方案</h3><p>如果你因为某种原因从接收端（receiver side）关闭 channel 或者在多个发送者中的一个关闭 channel，那么你应该使用列在 <a href="https://go101.org/article/panic-and-recover-use-cases.html">Golang panic/recover Use Cases</a> 的函数来安全地发送值到 channel 中（假设 channel 的元素类型是 T）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// the return result can be altered </span></span><br><span class="line">            <span class="comment">// in a defer function call</span></span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    ch &lt;- value <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 channel ch 没有被关闭的话，那么这个函数的性能将和 <code>ch &lt;- value</code> 接近。对于 channel 关闭的时候，SafeSend 函数只会在每个 sender goroutine 中调用一次，因此程序不会有太大的性能损失。</p><p>同样的想法也可以用在从多个 goroutine 关闭 channel 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// assume ch != nil here.</span></span><br><span class="line">    <span class="built_in">close</span>(ch) <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人喜欢用 sync.Once 来关闭 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，我们也可以用 sync.Mutex 来避免多次关闭 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    mc.mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该要理解为什么 Go 不支持内置 SafeSend 和 SafeClose 函数，原因就在于并不推荐从接收端或者多个并发发送端关闭 channel。Golang 甚至禁止关闭只接收（receive-only）的 channel。</p><h3 id="四、保持-channel-closing-principle-的优雅方案"><a href="#四、保持-channel-closing-principle-的优雅方案" class="headerlink" title="四、保持 channel closing principle 的优雅方案"></a>四、保持 channel closing principle 的优雅方案</h3><p>上面的 SafeSend 函数有一个缺点，在 select 语句的 case 关键字后不能作为发送操作被调用（类似于 case SafeSend(ch, t):）。</p><ul><li>M 个 receivers，一个 sender，sender 通过关闭 data channel 说“不再发送”</li></ul><p>这是最简单的场景了，就只是当 sender 不想再发送的时候让 sender 关闭 data 来关闭 channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the sender</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// the only sender can close the channel safely.</span></span><br><span class="line">                <span class="built_in">close</span>(dataCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">                dataCh &lt;- value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// receivers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// receive values until dataCh is closed and</span></span><br><span class="line">            <span class="comment">// the value buffer queue of dataCh is empty.</span></span><br><span class="line">            <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">                log.Println(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 receiver，N 个 sender，receiver 通过关闭一个额外的 signal channel 说“请停止发送”</li></ul><p>这种场景比上一个要复杂一点。我们不能让 receiver 关闭 data channel，因为这么做将会打破 channel closing principle。但是我们可以让 receiver 关闭一个额外的 signal channel 来通知 sender 停止发送值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">        <span class="comment">// Its sender is the receiver of channel dataCh.</span></span><br><span class="line">        <span class="comment">// Its reveivers are the senders of channel dataCh.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// the receiver of the dataCh channel is</span></span><br><span class="line">                <span class="comment">// also the sender of the stopCh cahnnel.</span></span><br><span class="line">                <span class="comment">// It is safe to close the stop channel here.</span></span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            log.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>M 个 receiver，N 个 sender，它们当中任意一个通过通知一个 moderator（仲裁者）关闭额外的 signal channel 来说“让我们结束游戏吧”</li></ul><p>这是最复杂的场景了。我们不能让任意的 receivers 和 senders 关闭 data channel，也不能让任何一个 receivers 通过关闭一个额外的 signal channel 来通知所有的 senders 和 receivers 退出游戏。这么做的话会打破 channel closing principle。但是，我们可以引入一个 moderator 来关闭一个额外的 signal channel。这个例子的一个技巧是怎么通知 moderator 去关闭额外的 signal channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">        <span class="comment">// Its sender is the moderator goroutine shown below.</span></span><br><span class="line">        <span class="comment">// Its reveivers are all senders and receivers of dataCh.</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// the channel toStop is used to notify the moderator</span></span><br><span class="line">        <span class="comment">// to close the additional signal channel (stopCh).</span></span><br><span class="line">        <span class="comment">// Its senders are any senders and receivers of dataCh.</span></span><br><span class="line">        <span class="comment">// Its reveiver is the moderator goroutine shown below.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// moderator</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;- toStop <span class="comment">// part of the trick used to notify the moderator</span></span><br><span class="line">                              <span class="comment">// to close the additional signal channel.</span></span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// here, a trick is used to notify the moderator</span></span><br><span class="line">                    <span class="comment">// to close the additional signal channel.</span></span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">"sender#"</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// the first select here is to try to exit the</span></span><br><span class="line">                <span class="comment">// goroutine as early as possible.</span></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// receivers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">// same as senders, the first select here is to </span></span><br><span class="line">                <span class="comment">// try to exit the goroutine as early as possible.</span></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="comment">// the same trick is used to notify the moderator </span></span><br><span class="line">                        <span class="comment">// to close the additional signal channel.</span></span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">"receiver#"</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    log.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">    log.Println(<span class="string">"stopped by"</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，仍然遵守着 channel closing principle。<strong>请注意 channel toStop 的缓冲大小是1，这是为了避免当 mederator goroutine 准备好之前第一个通知就已经发送了，导致丢失</strong>。</p><p><strong>参考文章</strong>:<br><a href="https://www.jianshu.com/p/d24dfbb33781">如何优雅地关闭Go channel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Go channel的关闭&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.beyondhxl.com/categories/Golang/"/>
    
      <category term="通道channel" scheme="https://www.beyondhxl.com/categories/Golang/%E9%80%9A%E9%81%93channel/"/>
    
    
      <category term="golang" scheme="https://www.beyondhxl.com/tags/golang/"/>
    
      <category term="Go" scheme="https://www.beyondhxl.com/tags/Go/"/>
    
      <category term="Golang" scheme="https://www.beyondhxl.com/tags/Golang/"/>
    
      <category term="channel" scheme="https://www.beyondhxl.com/tags/channel/"/>
    
      <category term="通道" scheme="https://www.beyondhxl.com/tags/%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型（DataMember的布局）</title>
    <link href="https://www.beyondhxl.com/post/8ce5f219.html"/>
    <id>https://www.beyondhxl.com/post/8ce5f219.html</id>
    <published>2020-08-08T00:21:09.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>C++ 对象模型 DataMember 的布局</strong></p></blockquote><a id="more"></a><h3 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">list</span>&lt;Point3d *&gt; *freeList;</span><br><span class="line">        <span class="keyword">float</span> y;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以知道 sizeof(Point3d) 为 12 bytes。一如之前的风格，我们来看一下 class Point3d 的对象模型，如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember.png" alt=""></p><p> C++ Standard 只要求在同一个 access section（也就是 private、public、proctected 等区段），data members 的排列只需要符合“较晚出现的 members 在 class object 中有较高的地址”，也就是说各个 member 并不一定是连续排列的，正如 class Point3d 一样，有可能被其他东西介入。C++ Standard 对布局持放任的态度，也就是说你你 class Point3d 写成下面这个样子，其对象布局也如上图（当然也看编译器，但一般都是相同的），即 access sections 的多少并不会导致额外的负担。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">list</span>&lt;Point3d *&gt; *freeList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSize = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、存取"><a href="#二、存取" class="headerlink" title="二、存取"></a>二、存取</h3><p>再来看一段代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">list</span>&lt;Point3d *&gt; *freeList;</span><br><span class="line">        <span class="keyword">float</span> y;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">        <span class="keyword">float</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Point3d::chunkSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point3d origin;</span><br><span class="line">    Point3d *pt = &amp;origin;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 下面这两天存取语句有什么差异？</span></span><br><span class="line">    origin.x = <span class="number">0.0F</span>;</span><br><span class="line">    pt-&gt;x = <span class="number">0.0F</span>;</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们要分情况讨论，从之前的学习我们知道 class data member 是分为 static 和 nonstatic 两种，我们就此分别进行讨论。</p><h4 id="2-1、static-data-member"><a href="#2-1、static-data-member" class="headerlink" title="2.1、static data member"></a>2.1、static data member</h4><p>正如之前所说，static data member 被视为一个 global 的（但只在 class 声明范围内可见），而不论是存在多少的 class object，static data member 只存在一个实例，并且在没有任何 class object 的情况下，static data member 也是存在的。也就是说其实 static data member 的存取并不需要通过 class object 就可以完成，因为它并不在 class object 中。实际上，我们对 static data member 存取操作时，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.chunkSize = <span class="number">1</span>;   <span class="comment">// 编译器会转化为 Point3d::chunkSize = 1;</span></span><br><span class="line">pt-&gt;chunkSize = <span class="number">2</span>;      <span class="comment">// 编译器会转化为 Point3d::chunkSize = 2;</span></span><br></pre></td></tr></table></figure><p>因此，对于 static data members，这两种存取方式并无差异。</p><h4 id="2-2、nonstatic-data-member"><a href="#2-2、nonstatic-data-member" class="headerlink" title="2.2、nonstatic data member"></a>2.2、nonstatic data member</h4><p>根据对象模型，我们知道 nonstatic data members 的存取是通过 class object 的地址加上 nonstatic data members 的 offset（偏移）进行的。显然这个 offset 必须在编译期间就应该准备妥当，因此如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过寻址进行存取，因此下面两种操作并无差异</span></span><br><span class="line">origin.x = <span class="number">0.0F</span>;        <span class="comment">// 等价于 *(&amp;origin + (&amp;Point3d::x - 1)) = 0.0;</span></span><br><span class="line">pt-&gt;x = <span class="number">0.0F</span>;           <span class="comment">// 等价于 *(pt + (&amp;Point3d::x - 1)) = 0.0;</span></span><br></pre></td></tr></table></figure><p>当然，对于那些单一继承、多重继承来的 data members 也是跟上面的一样，都是寻址+偏移完成。但是，有一个叫 virutal 关键字我们每次看到它的时候心里就应该知道要特殊对待，这就是下面要讲的内容。</p><h3 id="三、继承与-Data-member"><a href="#三、继承与-Data-member" class="headerlink" title="三、继承与 Data member"></a>三、继承与 Data member</h3><p>在 C++ 继承模型中，一个 derived class object 表现出来的东西，是自己的 members 与 base class(es) members 的总和。至于 derived class member 与 base(es) class members 的排列顺序，在 C++ Standard 中并未规定，由编译器自由安排之。但在大部分的编译器中，base class members 总是先出现，但属于 virtual base class 的除外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">char</span> bit1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span> :</span> <span class="keyword">public</span> Concrete1 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> bit2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete3</span> :</span> <span class="keyword">public</span> Concrete2 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> bit3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember1.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember2.png" alt=""></p><p>上面也是我们能够预料到的结果，这样的代码写法，造成许多的内存空间被浪费。</p><h4 id="3-1、加上多态"><a href="#3-1、加上多态" class="headerlink" title="3.1、加上多态"></a>3.1、加上多态</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// has a virtual function</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _x;</span><br><span class="line">        <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// override or hide the function</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember3.png" alt=""></p><h4 id="3-2、多重继承"><a href="#3-2、多重继承" class="headerlink" title="3.2、多重继承"></a>3.2、多重继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// has virtual functions</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _x;</span><br><span class="line">        <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// has virtual functions</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Vertex* next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d, <span class="keyword">public</span> Vertex </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember4.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember5.png" alt=""></p><p>上图便是多重继承的 data members 的布局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vertex3d v3d;</span><br><span class="line">Vertex *pv;</span><br><span class="line"><span class="comment">// 当发生这样的操作时</span></span><br><span class="line">pv = &amp;v3d;</span><br><span class="line"><span class="comment">// 其内部发生的操作伪代码为：pv = (Vertex*) ( ((char*)&amp;v3d) + sizeof(Point3d) );</span></span><br></pre></td></tr></table></figure><p>由于 data members 的位置（offset）在编译时就已经准备妥当了，当我们要存取某个 base class 中的 data member 也就是计算 offset 这样简单的操作。</p><h4 id="3-3、虚拟继承"><a href="#3-3、虚拟继承" class="headerlink" title="3.3、虚拟继承"></a>3.3、虚拟继承</h4><p> 再来看一段 virtual inheritance 的代码，如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// has virtual functions</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _x;</span><br><span class="line">        <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d <span class="comment">// virtual inheritance</span></span><br><span class="line">&#123;        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d <span class="comment">// virtual inheritance</span></span><br><span class="line">&#123;         </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// has virtual functions</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d, <span class="keyword">public</span> Vertex </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember6png.png" alt=""></p><p>对于 virtual inheritance，它的存在就必须要支持某种形式的 “shared subobject”，也就是说它只会存在一个 virtual base class subobject。一般来说其对象模型会划分成两个部分：<strong>不变区域部分、共享区域部分</strong>。</p><p>不变区域部分指的是，不管后继如何衍化，总是拥有固定的 offset，所以这一部分区域可以被直接存取；共享区域部分，很显然指的是 virtual base class subobject，这一部分其位置会因派生操作而有变化，所以只能被间接存取。</p><p>一般来说，各家编译器的差异就在于间接存取（共享部分）的策略不同。一般的布局策略是先安排好 derived class 的不变部分，然后再建立起共享部分。对于共享部分的存取策略，下面介绍两种策略：指针策略（pointer strategy）、虚表策略（virtual table offset strategy）。以上面 class 的虚拟继承关系，对于 pointer strategy 而言，它们的对象模型如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember7.png" alt=""></p><p> 可以从上面的对象模型中看到，virtual base class subobject 部分在最后面，而 base class 根据继承的顺序依次排列，并且在每一个derived class object 中安插了一个指针，这个指针用来指向 virtual base class subobject（共享部分），因此要对共享部分进行存取，可以通过相关指针间接完成。</p><p>很明显，我们通过观察分析，发现这种 pointer strategy 对象模型存在缺点：对于每一个对象都会背负一个指向 virtual base class 的指针，这会导致 class object 的负担随着 virtual base class 的增加而真多，也就是说这些额外的负担是会变化的，我们并不能掌控其大小。</p><p>针对这个问题，一般而言有两种方法：</p><ul><li><p>我们可以借鉴表格驱动模型来解决（即 Microsoft 编译器的方案），也就是说为有一个或多个 virtual base classes 的 class object 安插一个指针，指向 virtual base class table 表格，而表格中存放的是真正的 virtual base class 的地址。（注意也就是说，不论有多少个 virtual base class，都只安插一个指针）。</p></li><li><p>第二种办法也是建立 virtual base class table，但 table 中存放的不是地址，而是 virtual base class 的 offset（如下图）。</p></li></ul><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/DataMember8.png" alt=""></p><p>上面的每一种方法都是一种实现模型，而不是一种标准。</p><p>一般而言，virtual base class 最有效的一种运用形式就是：一个抽象的 virtual base class，没有任何的 data member。</p><p><strong>参考原文</strong>:<br><a href="https://blog.csdn.net/hujingshuang/article/details/52886607">《深度探索C++对象模型》：Data member的布局</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C++ 对象模型 DataMember 的布局&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/categories/C/"/>
    
      <category term="对象模型" scheme="https://www.beyondhxl.com/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="对象成员布局" scheme="https://www.beyondhxl.com/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/tags/C/"/>
    
      <category term="对象模型" scheme="https://www.beyondhxl.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Go语言实战》阅读笔记再看看</title>
    <link href="https://www.beyondhxl.com/post/a470d515.html"/>
    <id>https://www.beyondhxl.com/post/a470d515.html</id>
    <published>2020-08-05T23:49:28.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>《Go语言实战》阅读笔记</strong></p></blockquote><a id="more"></a><h2 id="一、关于Go语言的介绍"><a href="#一、关于Go语言的介绍" class="headerlink" title="一、关于Go语言的介绍"></a>一、关于Go语言的介绍</h2><h3 id="1-1、Go解决现代编程难题"><a href="#1-1、Go解决现代编程难题" class="headerlink" title="1.1、Go解决现代编程难题"></a>1.1、Go解决现代编程难题</h3><p>Go 语言开发团队花了很长时间来解决当今软件开发人员面对的问题。开发人员在为项目选择语言时，不得不在快速开发和性能之间做出选择。C 和 C++ 这类语言提供了很快的执行速度，而 Ruby 和 Python 这类语言则擅长快速开发。Go 语言在这两者间架起了桥梁，不仅提供了高性能的语言，同时也让开发更快速。</p><p>Go 语言的编译器速度非常快，有时甚至会让人感觉不到在编译。所以，Go 开发者能显著减少等待项目构建的时间。</p><p>因为 <strong>Go 语言内置并发机制</strong>，所以不用被迫使用特定的线程库，就能让软件扩展，使用更多的资源。Go 语言的类型系统简单且高效，不需要为面向对象开发付出额外的心智，让开发者能专注于代码复用。<strong>Go 语言还自带垃圾回收器，不需要用户自己管理内存</strong>。</p><p>因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出。代价是，<strong>动态语言不提供静态语言提供的类型安全特性</strong>，不得不经常用大量的测试套件来避免在运行的时候出现类型错误这类 bug。</p><p><strong>goroutine 使用的内存比线程更少，Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine</strong>。每个逻辑处理器绑定到一个操作系统线程上。</p><p>通道是一种数据结构，可以让 goroutine 之间进行安全的数据通信。通道可以帮用户避免其他语言里常见的共享内存访问的问题。在其他语言中，如果使用全局变量或者共享内存，必须使用复杂的锁规则来防止对同一个变量的不同步修改。通道这一模式保证同一时刻只会有一个 goroutine 修改数据。</p><p><strong>在两个 goroutine 间传输数据是同步的，一旦传输完成，两个 goroutine 都会知道数据已经完成传输</strong>。</p><p>需要强调的是，<strong>通道并不提供跨 goroutine 的数据访问保护机制</strong>。如果通过通道传输数据的一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的是指向数据的指针时，如果读和写是由不同的 goroutine 完成的，每个 goroutine 依旧需要额外的同步动作。</p><h3 id="1-2、类型系统"><a href="#1-2、类型系统" class="headerlink" title="1.2、类型系统"></a>1.2、类型系统</h3><p>Go 开发者使用组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，就能复用所有的功能。</p><p>在 Go 语言中，不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口。</p><p>在 Go 语言中，如果一个类型实现了一个接口的所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。</p><h2 id="二、Go语言读取不同数据源实例"><a href="#二、Go语言读取不同数据源实例" class="headerlink" title="二、Go语言读取不同数据源实例"></a>二、Go语言读取不同数据源实例</h2><p>main 函数保存在名为 main 的包里。如果 main 函数不在 main 包里，构建工具就不会生成可执行的文件。</p><p>一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。这个特性可以把不同包中定义的同名标识符区别开。</p><p>关键字 import 就是导入一段代码，让用户可以访问其中的标识符，如类型、函数、常量和接口。</p><p><strong>所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名</strong>。</p><p>导入的路径前面有一个下划线，这个是为了让 Go 语言对包做初始化操作（即调用对应包内的所有代码文件里定义的 init() 函数），但是并不使用包里的标识符。程序中每个代码文件里定义的 init() 函数都会在 main() 函数执行之前调用。</p><p>从标准库中导入代码时，只需要提供包名。编译器总是从 GOROOT 和 GOPATH 环境变量引用的位置去查找。（目前最新的包管理是使用 <strong>go mod</strong>）</p><p>以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matchers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Matcher)</span><br></pre></td></tr></table></figure><p>matchers 是包级变量。</p><p>在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，所引用的底层数据结构会被初始化为对应的零值。<strong>但是被声明为其零值的引用类型的变量，会返回 nil 作为其值。</strong></p><p>切片是一种实现了一个动态数组的引用类型。</p><p><strong>简化变量声明运算符（:=）声明一个变量，同时给这个变量赋予初始值</strong>。编译器使用函数返回值的类型来确定每个变量的类型。如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符。</p><p>通道（channel）、映射（map）、切片（slice）都是引用类型。</p><p><strong>在 main 函数返回前，清理并终止所有之前启动的 goroutine。编写启动和终止时的状态都很清晰的程序，有助减少 bug，防止资源异常</strong>。</p><p>WaitGroup 是一个计数信号量，我们可以利用它来统计所有的 goroutine 是不是都完成了工作。</p><p>关键字 range 可以用于迭代数组、字符串、切片、映射和通道。使用 for range 迭代切片时，每次迭代会返回两个值。第一个值是迭代的元素在切片里的索引位置，第二个值是元素值的一个副本。</p><p><strong>下划线还有占位符的作用</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> , _ := <span class="keyword">range</span> feeds &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找 map 里的键时，有两个选择：要么赋值给一个变量，要么为了精确查找，赋值给两个变量。<strong>赋值给两个变量时，第一个值和赋值给一个变量时的值一样，是 map 查找的结果值。如果指定了第二个值，就会返回一个布尔标志，来表示查找的键是否存在于 map 里。如果这个键不存在，map 会返回其值类型的零值作为返回值，如果这个键存在，map 会返回键所对应值的副本</strong>。</p><p>一个 goroutine 是一个独立于其他函数运行的函数。使用关键字 go 启动一个 goroutine，并对这个 goroutine 做并发调度。</p><p>匿名函数是指没有明确声明名字的函数。匿名函数也可以接受声明时指定的参数。</p><p><strong>指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变量的状态，而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明</strong>。</p><p>在 Go 语言中，所有的变量都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值，所以依旧被看作以值的方式在传递。</p><p>Go 语言支持闭包，这里就应用了闭包。实际上，在匿名函数内访问 searchTerm 和 results 变量，也是通过闭包的形式访问的。因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。<strong>匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量本身</strong>。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量。</p><p>因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明常量的时候不需要指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFile = <span class="string">"data/data.json"</span></span><br></pre></td></tr></table></figure><p>我们声明了一个名叫 Feed 的结构类型。这个类型会对外暴露。这个类型里面声明了 3 个字段，每个字段的类型都是字符串，对应于数据文件中各个文档的不同字段。每个字段的声明最后` 引号里的部分被称作标记（tag）。这个标记里描述了 JSON 解码的元数据，用于创建 Feed 类型值的切片。每个标记将结构类型里字段对应到 JSON 文档里指定名字的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Feed 包含我们需要处理的数据源的信息</span></span><br><span class="line"><span class="keyword">type</span> Feed <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"site"`</span></span><br><span class="line">URI <span class="keyword">string</span> <span class="string">`json:"link"`</span></span><br><span class="line">Type <span class="keyword">string</span> <span class="string">`json:"type"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"site"</span> : <span class="string">"npr"</span>,</span><br><span class="line">        <span class="attr">"link"</span> : <span class="string">"http://www.npr.org/rss/rss.php?id=1001"</span>,</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"rss"</span></span><br><span class="line">&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"site"</span> : <span class="string">"cnn"</span>,</span><br><span class="line">        <span class="attr">"link"</span> : <span class="string">"http://rss.cnn.com/rss/cnn_world.rss"</span>,</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"rss"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"site"</span> : <span class="string">"foxnews"</span>,</span><br><span class="line">        <span class="attr">"link"</span> : <span class="string">"http://feeds.foxnews.com/foxnews/world?format=xml"</span>,</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"rss"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"site"</span> : <span class="string">"nbcnews"</span>,</span><br><span class="line">        <span class="attr">"link"</span> : <span class="string">"http://feeds.nbcnews.com/feeds/topstories"</span>,</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"rss"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RetrieveFeeds 读取并反序列化源数据文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RetrieveFeeds</span><span class="params">()</span> <span class="params">([]*Feed, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">file, err := os.Open(dataFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数返回时</span></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件解码到一个切片里</span></span><br><span class="line"><span class="comment">// 这个切片的每一项是一个指向一个Feed 类型值的指针</span></span><br><span class="line"><span class="keyword">var</span> feeds []*Feed</span><br><span class="line">err = json.NewDecoder(file).Decode(&amp;feeds)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不需要检查错误，调用者会做这件事</span></span><br><span class="line"><span class="keyword">return</span> feeds, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个返回值是一个切片，其中每一项指向一个 Feed 类型的值（指针类型）。第二个返回值是一个 error 类型的值，用来表示函数是否调用成功。在这个代码示例里，会经常看到返回 error 类型值来表示函数是否调用成功。这种用法在标准库里也很常见。</p><p>现在让我们看看第 4 行到第 7 行。在这几行里，我们使用 os 包打开了数据文件。我们使用相对路径调用 Open 方法，并得到两个返回值。第一个返回值是一个指针，指向 File 类型的值，第二个返回值是 error 类型的值，检查 Open 调用是否成功。紧接着第 21 行就检查了返回的 error 类型错误值，如果打开文件真的有问题，就把这个错误值返回给调用者。</p><p>关键字 defer 会安排随后的函数调用在函数返回时才执行。在使用完文件后，需要主动关闭文件。使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函<br>数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。关键字 defer 可以缩短打开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。（申请资源、释放资源要匹配）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dec *Decoder)</span> <span class="title">Decode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Decode 方法接受一个类型为 interface{} 的值作为参数。这个类型在 Go 语言里很特殊，一般会配合 reflect 包里提供的反射功能一起使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matcher 定义了要实现的</span></span><br><span class="line"><span class="comment">// 新搜索类型的行为</span></span><br><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Search(feed *Feed, searchTerm <span class="keyword">string</span>) ([]*Result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 关键字声明了一个接口，这个接口声明了结构类型或者具名类型需要实现的行为。一个接口的行为最终由在这个接口类型中声明的方法决定。如果接口类型只包含一个方法，那么这个类型的名字以 er 结尾。如果接口类型内部声明了多个方法，其名字需要与其行为关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search</span><br><span class="line"></span><br><span class="line"><span class="comment">// defaultMatcher 实现了默认匹配器</span></span><br><span class="line"><span class="keyword">type</span> defaultMatcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init 函数将默认匹配器注册到程序里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> matcher defaultMatcher</span><br><span class="line">Register(<span class="string">"default"</span>, matcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search 实现了默认匹配器的行为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span> <span class="params">([]*Result, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 04 行，我们使用一个空结构声明了一个名叫 defaultMatcher 的结构类型。空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span></span></span><br></pre></td></tr></table></figure><p>如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的类型绑在一起。在我们的例子里，Search 方法与 defaultMatcher 类型的值绑在一起。这意味着我们可以使用 defaultMatcher 类型的值或者指向这个类型值的指针来调用 Search 方法。无论我们是使用接收者类型的值来调用这个方，还是使用接收者类型值的指针来调用这个方法，编译器都会正确地引用或者解引用对应的值，作为接收者传递给 Search 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明为使用 defaultMatcher 类型的值作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向 defaultMatcher 类型值的指针</span></span><br><span class="line">dm := <span class="built_in">new</span>(defaultMatch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会解开dm 指针的引用，使用对应的值调用方法</span></span><br><span class="line">dm.Search(feed, <span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 defaultMatcher 类型的值</span></span><br><span class="line"><span class="keyword">var</span> dm defaultMatch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会自动生成指针引用 dm 值，使用指针调用方法</span></span><br><span class="line">dm.Search(feed, <span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。对于 defaultMatcher 类型来说，使用值作为接收者是因为创建一个 defaultMatcher 类型的值不需要分配内存。由于 defaultMatcher 不需要维护状态，所以不需要指针形式的接收者。</p><p>与直接通过值或者指针调用方法不同，如果通过接口类型的值调用方法，规则有很大不同，使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明为使用指向defaultMatcher 类型值的指针作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过interface 类型的值来调用方法</span></span><br><span class="line"><span class="keyword">var</span> dm defaultMatcher</span><br><span class="line"><span class="keyword">var</span> matcher Matcher = dm <span class="comment">// 将值赋值给接口类型</span></span><br><span class="line">matcher.Search(feed, <span class="string">"test"</span>) <span class="comment">// 使用值来调用接口方法</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">go</span> build</span><br><span class="line">cannot use dm (<span class="keyword">type</span> defaultMatcher) as <span class="keyword">type</span> Matcher in assignment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法声明为使用defaultMatcher 类型的值作为接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过interface 类型的值来调用方法</span></span><br><span class="line"><span class="keyword">var</span> dm defaultMatcher</span><br><span class="line"><span class="keyword">var</span> matcher Matcher = &amp;dm <span class="comment">// 将指针赋值给接口类型</span></span><br><span class="line">matcher.Search(feed, <span class="string">"test"</span>) <span class="comment">// 使用指针来调用接口方法</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">go</span> build</span><br><span class="line">Build Successful</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match 函数，为每个数据源单独启动goroutine 来执行这个函数</span></span><br><span class="line"><span class="comment">// 并发地执行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(matcher Matcher, feed *Feed, searchTerm <span class="keyword">string</span>, results <span class="keyword">chan</span>&lt;- *Result)</span></span> &#123;</span><br><span class="line"><span class="comment">// 对特定的匹配器执行搜索</span></span><br><span class="line">searchResults, err := matcher.Search(feed, searchTerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果写入通道</span></span><br><span class="line"><span class="keyword">for</span> _, result := <span class="keyword">range</span> searchResults &#123;</span><br><span class="line">results &lt;- result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数使用实现了 Matcher 接口的值或者指针，进行真正的搜索。这个函数接受 Matcher 类型的值作为第一个参数。只有实现了 Matcher 接口的值或者指针能被接受。因为 defaultMatcher 类型使用值作为接收者，实现了这个接口，所以 defaultMatcher 类型的值或者指针可以传入这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Display 从每个单独的 goroutine 接收到结果后</span></span><br><span class="line"><span class="comment">// 在终端窗口输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(results <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line"><span class="comment">// 通道会一直被阻塞，直到有结果写入</span></span><br><span class="line"><span class="comment">// 一旦通道被关闭，for 循环就会终止</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s:\n%s\n\n"</span>, result.Field, result.Content)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当通道被关闭时，通道和关键字 range 的行为，使这个函数在处理完所有结果后才会返回。</p><p>match.go 代码文件的 for range 循环会一直阻塞，直到有结果写入通道。在某个搜索 goroutine 向通道写入结果后，for  range 循环被唤醒，读出这些结果。之后，结果会立刻写到日志中。看上去这个 for range 循环会无限循环下去，但其实不然。一旦 search.go 代码文件关闭了通道，for range 循环就会终止，Display 函数也会返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line"><span class="comment">// item 根据 item 字段的标签，将定义的字段</span></span><br><span class="line"><span class="comment">// 与 rss 文档的字段关联起来</span></span><br><span class="line">item <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"item"`</span></span><br><span class="line">PubDate <span class="keyword">string</span> <span class="string">`xml:"pubDate"`</span></span><br><span class="line">Title <span class="keyword">string</span> <span class="string">`xml:"title"`</span></span><br><span class="line">Description <span class="keyword">string</span> <span class="string">`xml:"description"`</span></span><br><span class="line">Link <span class="keyword">string</span> <span class="string">`xml:"link"`</span></span><br><span class="line">GUID <span class="keyword">string</span> <span class="string">`xml:"guid"`</span></span><br><span class="line">GeoRssPoint <span class="keyword">string</span> <span class="string">`xml:"georss:point"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// image 根据 image 字段的标签，将定义的字段</span></span><br><span class="line"><span class="comment">// 与 rss 文档的字段关联起来</span></span><br><span class="line">image <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"image"`</span></span><br><span class="line">URL <span class="keyword">string</span> <span class="string">`xml:"url"`</span></span><br><span class="line">Title <span class="keyword">string</span> <span class="string">`xml:"title"`</span></span><br><span class="line">Link <span class="keyword">string</span> <span class="string">`xml:"link"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel 根据 channel 字段的标签，将定义的字段</span></span><br><span class="line"><span class="comment">// 与 rss 文档的字段关联起来</span></span><br><span class="line">channel <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"channel"`</span></span><br><span class="line">Title <span class="keyword">string</span> <span class="string">`xml:"title"`</span></span><br><span class="line">Description <span class="keyword">string</span> <span class="string">`xml:"description"`</span></span><br><span class="line">Link <span class="keyword">string</span> <span class="string">`xml:"link"`</span></span><br><span class="line">PubDate <span class="keyword">string</span> <span class="string">`xml:"pubDate"`</span></span><br><span class="line">LastBuildDate <span class="keyword">string</span> <span class="string">`xml:"lastBuildDate"`</span></span><br><span class="line">TTL <span class="keyword">string</span> <span class="string">`xml:"ttl"`</span></span><br><span class="line">Language <span class="keyword">string</span> <span class="string">`xml:"language"`</span></span><br><span class="line">ManagingEditor <span class="keyword">string</span> <span class="string">`xml:"managingEditor"`</span></span><br><span class="line">WebMaster <span class="keyword">string</span> <span class="string">`xml:"webMaster"`</span></span><br><span class="line">Image image <span class="string">`xml:"image"`</span></span><br><span class="line">Item []item <span class="string">`xml:"item"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rssDocument 定义了与 rss 文档关联的字段</span></span><br><span class="line">rssDocument <span class="keyword">struct</span> &#123;</span><br><span class="line">XMLName xml.Name <span class="string">`xml:"rss"`</span></span><br><span class="line">Channel channel <span class="string">`xml:"channel"`</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search 在文档中查找特定的搜索项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m rssMatcher)</span> <span class="title">Search</span><span class="params">(feed *search.Feed, searchTerm <span class="keyword">string</span>)</span> <span class="params">([]*search.Result, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> results []*search.Result</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"Search Feed Type[%s] Site[%s] For Uri[%s]\n"</span>, feed.Type, feed.Name, feed.URI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取要搜索的数据</span></span><br><span class="line">document, err := m.retrieve(feed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, channelItem := <span class="keyword">range</span> document.Channel.Item&#123;</span><br><span class="line"><span class="comment">// 检查标题部分是否包含搜索项</span></span><br><span class="line">matched, err := regexp.MatchString(searchTerm, channelItem.Title)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到匹配的项，将其作为结果保存</span></span><br><span class="line"><span class="keyword">if</span> matched &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, &amp;search.Result&#123;</span><br><span class="line">Field: <span class="string">"Title"</span>,</span><br><span class="line">Content: channelItem.Title,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查描述部分是否包含搜索项</span></span><br><span class="line">matched, err = regexp.MatchString(searchTerm, channelItem.Description)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到匹配的项，将其作为结果保存</span></span><br><span class="line"><span class="keyword">if</span> matched &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, &amp;search.Result&#123;</span><br><span class="line">Field: <span class="string">"Description"</span>,</span><br><span class="line">Content: channelItem.Description,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, channelItem := <span class="keyword">range</span> document.Channel.Item &#123;</span><br><span class="line"><span class="comment">// 检查标题部分是否包含搜索项</span></span><br><span class="line">matched, err := regexp.MatchString(searchTerm, channelItem.Title)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然 document.Channel.Item 是一个 item 类型值的切片，我们对其使用 for range 循环，依次访问其内部的每一项。我们使用 regexp 包里的 MatchString 函数，对 channelItem 值里的 Title 字段进行搜索，查找是否有匹配的搜索项，之后检查错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果找到匹配的项，将其作为结果保存</span></span><br><span class="line"><span class="keyword">if</span> matched &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, &amp;search.Result&#123;</span><br><span class="line">Field: <span class="string">"Title"</span>,</span><br><span class="line">Content: channelItem.Title,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 MatchString 方法返回的 matched 的值为真，我们使用内置的 append 函数，将搜索结果加入到 results 切片里。append 这个内置函数会根据切片需要，决定是否要增加切片的长度和容量。这个函数的第一个参数是希望追加到的切片，第二个参数是要追加的值。在这个例子里，追加到切片的值是一个指向 Result 类型值的指针。这个值直接使用字面声明的方式，初始化为 Result 类型的值。之后使用取地址运算符（&amp;），获得这个新值的地址。最终将这个指针存入了切片。</p><h2 id="三、打包和工具链"><a href="#三、打包和工具链" class="headerlink" title="三、打包和工具链"></a>三、打包和工具链</h2><h3 id="3-1、包"><a href="#3-1、包" class="headerlink" title="3.1、包"></a>3.1、包</h3><p>在 Go 语言里，包是个非常重要的概念。其设计理念是使用包来封装不同语义单元的功能。这样做，能够更好地复用代码，并对每个包内的数据的使用有更好的控制。</p><p>所有的 .go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。这意味着，同一个目录下的所有 .go 文件必须声明同一个包名。</p><p>给包及其目录命名时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。</p><p>一般情况下，包被导入后会使用你的包名作为默认的名字，不过这个导入后的名字可以修改。这个特性在需要导入不同目录的同名包时很有用。</p><p><strong>main包</strong></p><p>在 Go 语言里，命名为 main 的包具有特殊的含义。Go 语言的编译程序会试图把这种名字的包编译为二进制可执行文件。</p><p>当编译器发现某个包的名字为 main 时，它一定也会发现名为 main() 的函数，否则不会创建可执行文件。main() 函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</p><p>在 Go 语言里，命令是指任何可执行程序，包更常用来指语义上可导入的功能单元。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;《Go语言实战》阅读笔记&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.beyondhxl.com/categories/Golang/"/>
    
      <category term="读书笔记" scheme="https://www.beyondhxl.com/categories/Golang/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://www.beyondhxl.com/tags/go/"/>
    
      <category term="golang" scheme="https://www.beyondhxl.com/tags/golang/"/>
    
      <category term="Golang" scheme="https://www.beyondhxl.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>本地仓库代码推送到github</title>
    <link href="https://www.beyondhxl.com/post/5cc80e12.html"/>
    <id>https://www.beyondhxl.com/post/5cc80e12.html</id>
    <published>2020-08-05T00:16:52.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本地仓库代码推送到 github 的步骤</strong></p></blockquote><a id="more"></a><p>使用 github 只需要简单的三步：</p><ol><li>初始化本地仓库 git</li><li>将自己的电脑与指定 github 账户关联</li><li>将自己的仓库与 github 上的某个项目关联</li></ol><h3 id="一、初始化本地仓库-git"><a href="#一、初始化本地仓库-git" class="headerlink" title="一、初始化本地仓库 git"></a>一、初始化本地仓库 git</h3><p><strong>1、首先下载 git</strong></p><p>先去 <a href="https://gitforwindows.org/">git 官方地址</a>下载 git。下载后，直接按照默认配置安装。</p><p><strong>2、验证是否安装成功</strong></p><p>回到电脑桌面，鼠标右击如果看到有两个 git 相关的右键菜单栏，则安装成功。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/github/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E5%88%B0github.png" alt=""></p><p>或者 “Win+R” 进入命令行界面，输入 cmd。当输入 git，出现以下界面，则表示安装成功。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/github/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E5%88%B0github1.png" alt=""></p><p><strong>3、git 初始化及仓库创建操作</strong></p><p>新建一个文件夹作为本地仓库，右建，选择 git bash here，在打开的页面中输入 git init（初始化本地仓库）</p><h3 id="二、将自己的电脑与指定-github-账户关联"><a href="#二、将自己的电脑与指定-github-账户关联" class="headerlink" title="二、将自己的电脑与指定 github 账户关联"></a>二、将自己的电脑与指定 github 账户关联</h3><p><strong>1、注册 GitHub 账户</strong></p><ol><li><p>设置用户名：git config –global user.name ‘你在 github上 注册的用户名’;</p></li><li><p>设置用户邮箱：git config –global user.email ‘注册时候的邮箱’;</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'beyond'</span></span><br><span class="line">git config --global user.mail <span class="string">'123456@qq.com'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>检验是否配置成功：git config –list</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=<span class="literal">true</span></span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=D:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=<span class="literal">true</span></span><br><span class="line">core.fscache=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">pull.rebase=<span class="literal">false</span></span><br><span class="line">credential.helper=manager</span><br><span class="line">user.name=beyond</span><br><span class="line">user.mail=123456@qq.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">false</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>2、将 GitHub 上对应的项目复制到本地</strong></p><p>git clone 仓库地址（即 github 上的地址，项目在之前已经在 github 上 new repository 出来了）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/beyondhxl/chatroom.git</span><br><span class="line">Cloning into <span class="string">'chatroom'</span>...</span><br><span class="line">remote: Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 583 bytes | 83.00 KiB/s, <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p><strong>3、将本地项目同步到 GitHub 上：git push</strong></p><ul><li><strong>生成本机的 SSH key</strong><br>输入：<code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code> （注意！双引号里面是你在 github 注册的邮箱）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"123456@qq.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/PCSetupAccount/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/PCSetupAccount/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/PCSetupAccount/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:hPXgDS5RHWD5w0EudhANVvNn3rY54332jzbB+qUB9q0 123456@qq.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|      ..%X=.     |</span></span><br><span class="line"><span class="string">|       O.B+o     |</span></span><br><span class="line"><span class="string">|      o *o=.. o  |</span></span><br><span class="line"><span class="string">|       + o+  + . |</span></span><br><span class="line"><span class="string">|        S  .o.. o|</span></span><br><span class="line"><span class="string">|           . oooo|</span></span><br><span class="line"><span class="string">|             .o*o|</span></span><br><span class="line"><span class="string">|            . +**|</span></span><br><span class="line"><span class="string">|             oE+B|</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>完成上面操作无误后，即可在上面指出的目录下找到两个文件 id_rsa 和 id_rsa_pub。<strong>接着用 Notepad++ 打开 id_rsa_pub 文件，复制 id_rsa_pub 文件里面的所有内容</strong>。打开 github，进入 settings，选择左边的 SSH and GPG keys，把刚才复制的密钥添加进去，title 那里可以自己取一个名字，点击添加，最后就可以看到生成 sshkey 了。下次上传项目时就不需要再配置密钥了。</li></ul><p><strong>4、遇到的问题</strong></p><ul><li><p><strong>推送问题一</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">push</span> <span class="string">-u</span> <span class="string">origin</span> <span class="string">master</span></span><br><span class="line"><span class="attr">error:</span> <span class="string">src</span> <span class="string">refspec</span> <span class="string">master</span> <span class="string">does</span> <span class="string">not</span> <span class="string">match</span> <span class="string">any</span></span><br><span class="line"><span class="attr">error:</span> <span class="string">failed</span> <span class="string">to</span> <span class="string">push</span> <span class="string">some</span> <span class="string">refs</span> <span class="string">to</span> <span class="string">'github.com:beyondhxl/chatroom.git'</span></span><br></pre></td></tr></table></figure><p>引起该错误的原因是，目录中没有文件，空目录是不能提交上去的，而且在 push 之前至少有过一次 commit。解法方法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">init</span> </span><br><span class="line"><span class="string">git</span> <span class="string">touch</span> <span class="string">README</span> </span><br><span class="line"><span class="string">git</span> <span class="string">add</span> <span class="string">README</span> </span><br><span class="line"><span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">'first commit'</span></span><br><span class="line"><span class="string">git</span> <span class="string">remote</span> <span class="string">add</span> <span class="string">origin</span> <span class="string">https://github.com/xxx.github.io.git</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>如果在 github 的 remote 上已经有了文件，会出现错误。此时应当先 pull 一下，即</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">pull</span> <span class="string">origin</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推送问题二</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:beyondhxl/chatroom.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'github.com:beyondhxl/chatroom.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>可以使用如下语句强制推送</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">push</span> <span class="string">-u</span> <span class="string">origin</span> <span class="string">master</span> <span class="string">-f</span></span><br></pre></td></tr></table></figure><p><code>但是这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候</code>。</p></li><li><p><strong>推送问题三</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">remote</span> <span class="string">add</span> <span class="string">origin</span> <span class="string">git@github.com:beyondhxl/somedocs.git</span></span><br><span class="line"><span class="attr">fatal:</span> <span class="string">not</span> <span class="string">a</span> <span class="string">git</span> <span class="string">repository</span> <span class="string">(or</span> <span class="string">any</span> <span class="string">of</span> <span class="string">the</span> <span class="string">parent</span> <span class="string">directories):</span> <span class="string">.git</span></span><br></pre></td></tr></table></figure><p>对应解决方法</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="string">Initialized</span> <span class="string">empty</span> <span class="string">Git</span> <span class="string">repository</span> <span class="string">in</span> <span class="string">D:/somedocs/.git/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推送问题四</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m"更新"</span></span><br><span class="line"></span><br><span class="line"><span class="string">***</span> <span class="string">Please</span> <span class="string">tell</span> <span class="string">me</span> <span class="string">who</span> <span class="string">you</span> <span class="string">are.</span></span><br><span class="line"></span><br><span class="line"><span class="string">Run</span></span><br><span class="line"></span><br><span class="line">  <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"you@example.com"</span></span><br><span class="line">  <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"Your Name"</span></span><br><span class="line"></span><br><span class="line"><span class="string">to</span> <span class="string">set</span> <span class="string">your</span> <span class="string">account's</span> <span class="string">default</span> <span class="string">identity.</span></span><br><span class="line"><span class="string">Omit</span> <span class="string">--global</span> <span class="string">to</span> <span class="string">set</span> <span class="string">the</span> <span class="string">identity</span> <span class="string">only</span> <span class="string">in</span> <span class="string">this</span> <span class="string">repository.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fatal:</span> <span class="string">unable</span> <span class="string">to</span> <span class="string">auto-detect</span> <span class="string">email</span> <span class="string">address</span> <span class="string">(got</span> <span class="string">'PCSetupAccount@L-R90YFQ7W-1223.(none)'</span><span class="string">)</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参考文章</strong>:<br>1、<a href="https://blog.csdn.net/xl_lx/article/details/80676208">github上传时出现error: src refspec master does not match any解决办法</a><br>2、<a href="https://www.jianshu.com/p/40ffdd0654f4">Git 提示error:src refspec master does not match any</a><br>3、<a href="https://zhuanlan.zhihu.com/p/81112053">将本地代码上传到GitHub</a><br>4、<a href="https://blog.csdn.net/zhangkui0418/article/details/82977519">【Git】Updates were rejected because the tip of your current branch is behind</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本地仓库代码推送到 github 的步骤&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://www.beyondhxl.com/categories/github/"/>
    
      <category term="代码推送" scheme="https://www.beyondhxl.com/categories/github/%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="git" scheme="https://www.beyondhxl.com/tags/git/"/>
    
      <category term="github" scheme="https://www.beyondhxl.com/tags/github/"/>
    
      <category term="代码推送" scheme="https://www.beyondhxl.com/tags/%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>进程结构和内存布局</title>
    <link href="https://www.beyondhxl.com/post/4b36a800.html"/>
    <id>https://www.beyondhxl.com/post/4b36a800.html</id>
    <published>2020-08-03T00:30:14.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>进程结构和内存布局</strong></p></blockquote><a id="more"></a><h3 id="一、进程和程序"><a href="#一、进程和程序" class="headerlink" title="一、进程和程序"></a>一、进程和程序</h3><p>进程（process）是一个可执行程序（program）的实例。</p><p>程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，包含如下内容：</p><ul><li><strong>二进制格式标识</strong>：每个程序文件都包含用于描述可执行文件格式的元信息（meta information）。</li><li><strong>机器语言指令</strong>：对程序算法进行编码。</li><li><strong>程序入口地址</strong>：标识程序开始执行时的起始指令位置。</li><li><strong>数据</strong>：程序文件包含的变量初始值和程序使用的字面常量值（比如字符串）。</li><li><strong>符号表及重定位表</strong>：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包含调试和运行时的符号解析（动态链接）。</li><li><strong>共享库和动态链接信息</strong>：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li><li><strong>其它信息</strong>：程序文件还包含许多其它信息，用以描述如何创建进程。</li></ul><p>从内核角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</p><p>记录在内核数据结构中的信息包括许多与进程相关的标识号、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其它信息。</p><p>每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。</p><p>Linux 内核限制进程号需小于等于 32767。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号达到 32767 的限制时，内核将重置进程号计数器，以便从小整数开始分配。（实际上，一旦进程号达到 32767，会将进程号计数器重置为 300，而不是 1。因为低数值的进程号为系统进程和守护进程所长期占用。）</p><p>在 Linux2.4 版本及更早的版本，进程号的上限是 32767，有内核常量 PID_MAX 所定义。在 Linux2.6 中，情况有所改变，尽管进程号的默认上限仍为 32767，但可以通过 Linux 系统中特有的 /proc/sys/kernel/pid_max 文件来进行调整（其值=最大进程号+1）。在 32 位平台中，pid_max 文件的最大值为 32768，但是在 64 位平台中，该文件的最大值可以高达 2<sup>22</sup>（约400万），系统可能容纳的进程数量会非常庞大。</p><p>每个进程都有一个创建自己的进程，每个进程的父进程号属性反应了系统上所有进程间的树状关系。每个进程的父进程又有自己的父进程，以此类推，回溯到 1 号进程 –init 进程，即所有进程的始祖。</p><p>如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程。</p><h3 id="二、进程内存布局"><a href="#二、进程内存布局" class="headerlink" title="二、进程内存布局"></a>二、进程内存布局</h3><p>每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”：</p><ul><li><strong>文本段</strong>：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。</li><li><strong>初始化数据段</strong>：包含显示初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。</li><li><strong>未初始化数据段</strong>：包含了未进行显示初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为 0。出于历史原因，此段常被称为 BSS 段，这源于老版本的汇编语言助记符 “block started by symbol”。将经过初始化的全局变量和静态变量与未初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配空间。</li><li><strong>栈（stack）</strong>：是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。</li><li><strong>堆（heap）</strong>：是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称为 program break。</li></ul><p>对于初始化和未初始化的数据段而言，不太常用、但表达更清晰的称谓分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%86%85%E5%AD%98/710068-20151223161742359-947623183.png" alt=""></p><p>在大多数 Unix（包括 Linux）中的 C 语言编程环境提供了 3 个全局符号（symbol）：etext、edata、end，可以在程序中使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。</p><p>使用这些符号，必须显式声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> etext, edata, end; <span class="comment">// For example, &amp;etext gives the address of the end of the program text / start of initialized data</span></span><br></pre></td></tr></table></figure><p>图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）。</p><h3 id="三、虚拟内存管理"><a href="#三、虚拟内存管理" class="headerlink" title="三、虚拟内存管理"></a>三、虚拟内存管理</h3><p>Linux 采用了虚拟内存管理技术。该技术利用了大多数程序的一个典型特征，即访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存）资源。</p><p>大多数程序都展现了两种类型的局部性：</p><ul><li>空间局部性（Spatial locality）：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。</li><li>时间局部性（Temporal locality）：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。</li></ul><p>正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于 RAM 中，依然可能得以执行。</p><p>虚拟内存的规划之一是将每个程序使用的内存分割成小型的、固定大小的“页（page）”单元。相应地，将 RAM 划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓的驻留集（resident set）。程序未使用的页拷贝保存在交换区（swap area）内 – 这是磁盘空间中的保留区域，作为计算机 RAM 的补充 – 仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。（程序可调用 sysconf(_SC_PAGESIZE) 来获取系统虚拟内存的页面大小）。</p><p>为支持这一组织方式，内核需要为每个进程维护一张页表（page table）。该页表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚拟内存页面的集合）。页表中的每个条目要么指出一个虚拟页面在 RAM 中的所在位置，要么表明其当前驻留在磁盘上。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%86%85%E5%AD%98/710068-20160120110423468-1834433106.png" alt=""></p><p>在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个 SIGSEGV 信号。</p><p>由于内核能够为进程分配和释放页（和页表条目），所以进程的有效虚拟地址范围在其生命周期中可以发生变化。这可能会发生于如下场景：</p><ul><li>由于栈向下增长超出之前曾达到的位置。</li><li>当在堆中分配或释放内存时，通过调用 brk()、sbrk() 或 malloc 函数族来提升 program break 的位置。</li><li>当调用 shmat() 连接 System V 共享内存区时，或者当调用 shmdt() 脱离共享内存区时。</li><li>当调用 mmap() 创建内存映射时，或者当调用 munmap() 解除内存映射时。</li></ul><p>虚拟内存管理是使进程的虚拟地址空间与 RAM 物理地址空间隔离开来，这带来许多优点：</p><ul><li>进程与进程、进程与内核相互隔离，所以一个进程不能读取或修改另一个进程或内核的内存。这是因为每个进程的页表条目指向 RAM（或交换区）中截然不同的物理页面集合。</li><li>适当情况下，两个或更多进程能够共享内存。这是由于内核可以使不同进程的页表条目指向相同的 RAM 页。内存共享常发生于如下两种场景：</li></ul><ol><li>执行同一程序的多个进程，可共享一份（只读的）程序代码副本。当多个程序执行相同的程序文件（或加载相同的共享库）时，会隐式地实现这一类型的共享。</li><li>进程可以使用 shmget() 和 mmap() 系统调用显示地请求与其他进程共享内存区。这么做是出于进程间通信的目的。</li></ol><ul><li>便于实现内存保护机制：也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。多个进程共享 RAM 页面时，允许每个进程对内存采取不同的保护措施。例如：一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。</li><li>程序员和编译器、链接器之类的工具无需关注程序在 RAM 中的物理布局。</li><li>因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存（即虚拟内存大小）能够超出 RAM 的容量。</li></ul><p>虚拟内存管理的最后一个优点是：由于每个进程使用的 RAM 减少了，RAM 中同时可以容纳的进程数量就增多了。这增大了如下事件的概率：在任一时刻，CPU 都可执行至少一个进程，因而往往也会提高 CPU 的利用率。</p><p><strong>参考文章</strong>:<br><a href="https://www.cnblogs.com/jingyg/p/5069964.html">进程结构和内存布局</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;进程结构和内存布局&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="内存布局" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://www.beyondhxl.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="内存" scheme="https://www.beyondhxl.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Go面向对象简述</title>
    <link href="https://www.beyondhxl.com/post/be20ec3e.html"/>
    <id>https://www.beyondhxl.com/post/be20ec3e.html</id>
    <published>2020-08-02T21:38:24.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Go 是一个完全面向对象的语言。例如，它允许基于我们的类型定义方法，而没有像其他语言一样的装箱/拆箱操作。</p></blockquote><a id="more"></a><p>Go 没有使用 classes，但提供很多相似的功能：</p><ul><li>通过嵌入实现的自动消息委托</li><li>通过接口实现多态</li><li>通过 exports 实现的命名空间</li></ul><p>Go 语言中没有继承。忘记 is-a 的关系，Go 采用组合的方式面向对象设计。</p><blockquote><p>“使用经典的继承始终是可选的；每个问题都可以通过其他方法得到解决” - Sandi Metz</p></blockquote><h3 id="1、例子说明组合"><a href="#1、例子说明组合" class="headerlink" title="1、例子说明组合"></a>1、例子说明组合</h3><p>维修工需要知道自行车出行需要带上的备件，决定哪一辆自行车出租出去。问题可以通过经典的继承来解决，山地车和公路自行车是自行车基类的一个特殊化例子。</p><h3 id="2、Packages（包）"><a href="#2、Packages（包）" class="headerlink" title="2、Packages（包）"></a>2、Packages（包）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure><p>包提供了命名空间概念，main() 函数是这个包的入口函数，fmt 包提供格式化功能。</p><h3 id="3、Types（类型）"><a href="#3、Types（类型）" class="headerlink" title="3、Types（类型）"></a>3、Types（类型）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name        <span class="keyword">string</span></span><br><span class="line">    Description <span class="keyword">string</span></span><br><span class="line">    NeedsSpare  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个新的类型名为 Part，非常像 C 的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parts []Part</span><br></pre></td></tr></table></figure><p>Parts 类型是包含 Part 类型的数组切片，Slice 可以理解为动态增长的数组，在 Go 中是很常见的。</p><p>我们可以在任何类型上声明方法，所以我们不需要要再去封装 []Part，这意味着 Parts 会拥有 slice 的所有行为，再加上我们自己定义的行为方法。</p><h3 id="4、方法"><a href="#4、方法" class="headerlink" title="4、方法"></a>4、方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parts Parts)</span> <span class="title">Spares</span><span class="params">()</span> <span class="params">(spares Parts)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">        <span class="keyword">if</span> part.NeedsSpare &#123;</span><br><span class="line">            spares = <span class="built_in">append</span>(spares, part)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spares</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中定义方法就像一个函数，除了它有一个显式的接收者，紧接着 func 之后定义。</p><p>方法的主体十分简单。我们重复 parts，忽略索引的位置 (_)，过滤 parts 后返回。append builtin 需要分配和返回一个大的切片，因为我们并没有预先分配好它的容量。</p><p>这段代码没有 ruby 代码来得优雅。在 Go 语言中有过滤函数，但它并非是 builtin。</p><h3 id="5、内嵌"><a href="#5、内嵌" class="headerlink" title="5、内嵌"></a>5、内嵌</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bicycle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">string</span></span><br><span class="line">    Parts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行车由 Size 和 Parts 组成。没有给 Parts 指定一个名称，我们是要保证实现<strong>内嵌</strong>。这样可以提供自动的委托，不需特殊的声明，例如 bike.Spares() 和 bike.Parts.Spares() 是等同的。</p><p>如果我们向 Bicycle 增加一个 Spares() 方法，它会得到优先权，但是我们仍然引用嵌入的 Parts.Spares()。这跟继承十分相似，但是内嵌并不提供多态。Parts 的方法的接收者通常是 Parts 类型，甚至是通过 Bicycle 委托的。</p><p>与继承一起使用的模式，就像模板方法模式，并不适合于内嵌。</p><h3 id="6、Composite-Literals（复合语义）"><a href="#6、Composite-Literals（复合语义）" class="headerlink" title="6、Composite Literals（复合语义）"></a>6、Composite Literals（复合语义）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    RoadBikeParts = Parts&#123;</span><br><span class="line">        &#123;<span class="string">"chain"</span>, <span class="string">"10-speed"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"tire_size"</span>, <span class="string">"23"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"tape_color"</span>, <span class="string">"red"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MountainBikeParts = Parts&#123;</span><br><span class="line">        &#123;<span class="string">"chain"</span>, <span class="string">"10-speed"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"tire_size"</span>, <span class="string">"2.1"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"front_shock"</span>, <span class="string">"Manitou"</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"rear_shock"</span>, <span class="string">"Fox"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RecumbentBikeParts = Parts&#123;</span><br><span class="line">        &#123;<span class="string">"chain"</span>, <span class="string">"9-speed"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"tire_size"</span>, <span class="string">"28"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"flag"</span>, <span class="string">"tall and orange"</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go 提供优美的语法，来初始化对象，叫做 composite literals。使用像数组初始化一样的语法，来初始化一个结构，使得我们不再需要 ruby 例子中的 Parts 工厂。</p><p>Composite literals（复合语义）同样可以用于<code>字段:值</code>的语法，所有的字段都是可选的。</p><p>简短的定义操作符 (:=) 通过 Bicycle 类型，使用类型推论来初始化 roadBike 和其他。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    roadBike := Bicycle&#123;Size: <span class="string">"L"</span>, Parts: RoadBikeParts&#125;</span><br><span class="line">    mountainBike := Bicycle&#123;Size: <span class="string">"L"</span>, Parts: MountainBikeParts&#125;</span><br><span class="line">    recumbentBike := Bicycle&#123;Size: <span class="string">"L"</span>, Parts: RecumbentBikeParts&#125;</span><br></pre></td></tr></table></figure><h3 id="7、输出"><a href="#7、输出" class="headerlink" title="7、输出"></a>7、输出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(roadBike.Spares())</span><br><span class="line">fmt.Println(mountainBike.Spares())</span><br><span class="line">fmt.Println(recumbentBike.Spares())</span><br></pre></td></tr></table></figure><p>我们将以默认格式打印 Spares 的调用结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;chain <span class="number">10</span>-speed <span class="literal">true</span>&#125; &#123;tire_size <span class="number">23</span> <span class="literal">true</span>&#125; &#123;tape_color red <span class="literal">true</span>&#125;]</span><br><span class="line">[&#123;chain <span class="number">10</span>-speed <span class="literal">true</span>&#125; &#123;tire_size <span class="number">2.1</span> <span class="literal">true</span>&#125; &#123;rear_shock Fox <span class="literal">true</span>&#125;]</span><br><span class="line">[&#123;chain <span class="number">9</span>-speed <span class="literal">true</span>&#125; &#123;tire_size <span class="number">28</span> <span class="literal">true</span>&#125; &#123;flag tall and orange <span class="literal">true</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="8、组合-Parts"><a href="#8、组合-Parts" class="headerlink" title="8、组合 Parts"></a>8、组合 Parts</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    comboParts := Parts&#123;&#125;</span><br><span class="line">    comboParts = <span class="built_in">append</span>(comboParts, mountainBike.Parts...)</span><br><span class="line">    comboParts = <span class="built_in">append</span>(comboParts, roadBike.Parts...)</span><br><span class="line">    comboParts = <span class="built_in">append</span>(comboParts, recumbentBike.Parts...)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(comboParts), comboParts[<span class="number">9</span>:])</span><br><span class="line">    fmt.Println(comboParts.Spares())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parts 的行为类似于 slice。按照长度获取切片，或者将数个切片结合。Ruby 中的类似解决方案就数组的子类，但是当两个 Parts 连接在一起时，Ruby 将会“错置” spares 方法。</p><blockquote><p>“……在一个完美的面向对象的语言，这种解决方案是完全正确的。不幸的是，Ruby 语言并没有完美的实现……” —— Sandi Metz</p></blockquote><p>在 Ruby 中有一个难看的解决方法，使用 Enumerable、forwardable，以及 def_delegators。Go 没有这样的缺陷，[]Part 正是我们所需要的，且更为简洁（更新：Ruby 的 SimpleDelegator 看上去好了一点）。</p><h3 id="9、接口-Interfaces"><a href="#9、接口-Interfaces" class="headerlink" title="9、接口 Interfaces"></a>9、接口 Interfaces</h3><p>Go 的多态性由接口提供。不像 JAVA 和 C#，它们是隐含实现的，所以接口可以为不属于我们的代码定义。</p><p>和动态类型比较，接口是在它们声明过程中静态检查和说明的，而不是通过写一系列响应（respond_to）测试完成的。</p><blockquote><p>“不可能不知不觉的或者偶然的创建一个抽象；在静态类型语言中定义的接口总是有倾向性的。” - Sandi Metz</p></blockquote><p>给个简单的例子，假设我们不需要打印 Part 的 NeedsSpare 标记。我们可以写这样的字符串方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(part Part)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %s"</span>, part.Name, part.Description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对上述 Print 的调用将会输出这样的替代结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[chain: <span class="number">10</span>-speed tire_size: <span class="number">23</span> tape_color: red]</span><br><span class="line">[chain: <span class="number">10</span>-speed tire_size: <span class="number">2.1</span> rear_shock: Fox]</span><br><span class="line">[chain: <span class="number">9</span>-speed tire_size: <span class="number">28</span> flag: tall and orange]</span><br></pre></td></tr></table></figure><p>这个机理是因为我们实现了 fmt 包会用到的 Stringer 接口。它是这么定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型在同一个地方可以用作其它类型。变量与参数可以携带一个 Stringer，可以是任何实现 String() string 方法签名的接口。</p><h3 id="10、Exports-导出"><a href="#10、Exports-导出" class="headerlink" title="10、Exports 导出"></a>10、Exports 导出</h3><p>Go 使用包来管理命名空间，要使某个符号对其他包（package ）可见（即可以访问），需要将该符号定义为以大写字母开头，当然如果以小写字母开头，那就是私有的，包外不可见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part <span class="keyword">struct</span> &#123;</span><br><span class="line">    name        <span class="keyword">string</span></span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">    needsSpare  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了对 Part 类型应用统一的访问原则（uniform access principle），我们可以改变 Part 类型的定义并提供 setter/getter 方法，就像这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(part Part)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> part.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(part *Part)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    part.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以很容易的确定哪些是 public API，哪些是私有的属性和方法，只要通过字母的大小写。（例如 part.Name() vs .part.name）</p><p>注意，我们不必要对 getters 加前 Get，（例如.GetName），Getter 不是必需，特别是对于字符串，当我们有需要时，我们可以使用满足Stringer 类型接口的自定义的类型去改变 Name 字段。</p><h3 id="11、找到一些私有性"><a href="#11、找到一些私有性" class="headerlink" title="11、找到一些私有性"></a>11、找到一些私有性</h3><p>私有命名（小写字母）可以从同一个包的任何地方访问到，即使是包含了跨越多个文件的多个结构。如果你觉得这令人不安，包也可以像你希望的那么小。</p><p>可能的情况下用（更稳固的）公共 API 是一个好的实践，即使是来自经典语言的同样的类中。这需要一些约定，当然这些约定可以应用在 GO 中。</p><h3 id="12、最大的好处"><a href="#12、最大的好处" class="headerlink" title="12、最大的好处"></a>12、最大的好处</h3><p>组合、内嵌和接口提供了 Go 语言中面向对象设计的强大工具。</p><p>习惯 Go 需要思维的改变，当触及到 Go 对象模型的力量时，我非常高兴的吃惊于 Go 代码的简单和简洁。</p><p><strong>参考文章</strong>:<br><a href="https://www.oschina.net/translate/go-object-oriented-design?print">Go 面向对象</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Go 是一个完全面向对象的语言。例如，它允许基于我们的类型定义方法，而没有像其他语言一样的装箱/拆箱操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.beyondhxl.com/categories/Golang/"/>
    
      <category term="面向对象" scheme="https://www.beyondhxl.com/categories/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="面向对象" scheme="https://www.beyondhxl.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="go" scheme="https://www.beyondhxl.com/tags/go/"/>
    
      <category term="golang" scheme="https://www.beyondhxl.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://www.beyondhxl.com/post/69e7b86f.html"/>
    <id>https://www.beyondhxl.com/post/69e7b86f.html</id>
    <published>2020-08-02T21:03:33.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>单例模式</strong></p></blockquote><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span>* once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>功能是本函数使用初值为 PTHREAD_ONCE_INIT 的 once_control 变量保证 init_routine() 函数在本进程执行序列中仅执行一次。</p><figure class="highlight cpp"><figcaption><span>C++11 一种实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singlrton</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只调用一次 init()</span></span><br><span class="line">        pthread_once(&amp;once_, &amp;Singleton::init);</span><br><span class="line">        <span class="keyword">return</span> *value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once_;</span><br><span class="line">    <span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::once_ = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>参考文章</strong>:<br><a href="">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.beyondhxl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://www.beyondhxl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.beyondhxl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://www.beyondhxl.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务的四种解决方案</title>
    <link href="https://www.beyondhxl.com/post/75ca4e90.html"/>
    <id>https://www.beyondhxl.com/post/75ca4e90.html</id>
    <published>2020-08-02T20:21:18.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>分布式事务解决方案</strong></p></blockquote><a id="more"></a><p>分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h3 id="一、两阶段提交（2PC）"><a href="#一、两阶段提交（2PC）" class="headerlink" title="一、两阶段提交（2PC）"></a>一、两阶段提交（2PC）</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h4 id="1-1、运行过程"><a href="#1-1、运行过程" class="headerlink" title="1.1、运行过程"></a>1.1、运行过程</h4><p><strong>1、准备阶段</strong></p><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/62cf113cd8c40eaafecb9fc6111beef4480.jpg" alt=""></p><p><strong>2、提交阶段</strong></p><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/6610fc7d97c9277423a9c620487e09db3f8.jpg" alt=""></p><h4 id="1-2、存在的问题"><a href="#1-2、存在的问题" class="headerlink" title="1.2、存在的问题"></a>1.2、存在的问题</h4><p><strong>1、同步阻塞</strong></p><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p><p><strong>2、单点问题</strong> </p><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p><p><strong>3、数据不一致</strong> </p><p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><p><strong>4、太过保守</strong></p><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h3 id="二、补偿事务（TCC）"><a href="#二、补偿事务（TCC）" class="headerlink" title="二、补偿事务（TCC）"></a>二、补偿事务（TCC）</h3><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的。即：只要Try 成功，Confirm 一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p></li></ul><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：我们有一个本地方法，里面依次调用</p><ul><li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li></ul><p><strong>优点</strong></p><p>跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。</p><p><strong>缺点</strong></p><p>缺点还是比较明显的，在 2、3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。</p><h3 id="三、本地消息表（异步确保）"><a href="#三、本地消息表（异步确保）" class="headerlink" title="三、本地消息表（异步确保）"></a>三、本地消息表（异步确保）</h3><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/915a02484990dda820410c8cad2389c5386.jpg" alt=""></p><p><strong>优点</strong></p><p>一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p><strong>缺点</strong></p><p>消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h3 id="四、MQ-事务消息"><a href="#四、MQ-事务消息" class="headerlink" title="四、MQ 事务消息"></a>四、MQ 事务消息</h3><p>有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ul><li>第一阶段 Prepared 消息，会拿到消息的地址。</li><li>第二阶段执行本地事务</li><li>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li></ul><p>也就是说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了，RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/a411ccaf753bdd3c91ab94fe224109044f3.jpg" alt=""></p><p><strong>优点</strong></p><p>实现了最终一致性，不需要依赖本地数据库事务。</p><p><strong>缺点</strong></p><p>实现难度大，主流 MQ 不支持，RocketMQ 事务消息部分代码也未开源。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>通过本文我们总结并对比了几种分布式事务解决方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择。阿里 RocketMQ 实现的分布式事务，现在也有了很多分布式事务的协调器，比如 LCN 等，大家可以多去尝试。</p><p><strong>参考原文</strong>:<br><a href="https://www.cnblogs.com/mayundalao/p/11798502.html">分布式事务的四种解决方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式事务解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.beyondhxl.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://www.beyondhxl.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式" scheme="https://www.beyondhxl.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://www.beyondhxl.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>细说new与malloc的10点区别(转载)</title>
    <link href="https://www.beyondhxl.com/post/31846410.html"/>
    <id>https://www.beyondhxl.com/post/31846410.html</id>
    <published>2020-08-02T15:49:26.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>new 与 malloc 的区别</strong></p></blockquote><a id="more"></a><h3 id="一、申请的内存所在位置"><a href="#一、申请的内存所在位置" class="headerlink" title="一、申请的内存所在位置"></a>一、申请的内存所在位置</h3><p>new 操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，而 malloc 函数从堆上动态分配内存。自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C 语言使用 malloc 从堆上分配内存，使用 free 释放已分配的对应内存。</p><p>那么自由存储区是否能够是堆（问题等价于 new 是否能在堆上动态分配内存），这取决于 operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这要看 operator new 在哪里为对象分配内存。</p><p>特别的，new 甚至可以不为对象分配内存！定位 new 的功能可以办到这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br></pre></td></tr></table></figure><p>place_address 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用 new 操作符时，new 操作符调用特殊的 operator new，也就是下面这个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *)</span> <span class="comment">//不允许重定义这个版本的operator new</span></span></span><br></pre></td></tr></table></figure><p>这个 operator new <strong>不分配任何的内存</strong>，它只是简单地返回指针实参，然后 new 表达式负责在 place_address 指定的地址进行对象的初始化工作。</p><h3 id="二、返回类型安全性"><a href="#二、返回类型安全性" class="headerlink" title="二、返回类型安全性"></a>二、返回类型安全性</h3><p>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 new 是符合<strong>类型安全性</strong>的操作符。而malloc 内存分配成功则是返回 void * ，需要通过强制类型转换将 void * 指针转换成我们需要的类型。</p><p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。</p><h3 id="三、内存分配失败时的返回值"><a href="#三、内存分配失败时的返回值" class="headerlink" title="三、内存分配失败时的返回值"></a>三、内存分配失败时的返回值</h3><p>new 内存分配失败时，会抛出 bac_alloc 异常，它<strong>不会返回 NULL</strong>；malloc 分配内存失败时返回 NULL。</p><p>在使用 C 语言时，我们习惯在 malloc 分配内存后判断分配是否成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a  = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 C 语言走入 C++ 阵营的新手可能会把这个习惯带入 C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这样做一点意义也没有，因为 new 根本不会返回 NULL，而且程序能够执行到 if 语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想顺便了解下异常基础，可以看 <a href="http://www.cnblogs.com/QG-whz/p/5136883.htmlC++">http://www.cnblogs.com/QG-whz/p/5136883.htmlC++</a> 异常机制分析。</p><h3 id="四、是否需要指定内存大小"><a href="#四、是否需要指定内存大小" class="headerlink" title="四、是否需要指定内存大小"></a>四、是否需要指定内存大小</h3><p>使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>...&#125;</span><br><span class="line">A *ptr = <span class="keyword">new</span> A;</span><br><span class="line">A *ptr = (A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">//需要显式指定所需内存大小sizeof(A);</span></span><br></pre></td></tr></table></figure><p>当然了，我这里使用 malloc 来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p><h3 id="五、是否调用构造函数-析构函数"><a href="#五、是否调用构造函数-析构函数" class="headerlink" title="五、是否调用构造函数/析构函数"></a>五、是否调用构造函数/析构函数</h3><p>使用 new 操作符来分配对象内存时会经历三个步骤：</p><ul><li>第一步：调用 operator new 函数（对于数组是 operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li><li>第二步：编译器运行相应的构造函数以<strong>构造对象</strong>，并为其传入初值。</li><li>第三部：对象构造完成后，返回一个指向该对象的指针。</li></ul><p>使用 delete 操作符来释放对象内存时会经历两个步骤：</p><ul><li>第一步：调用对象的析构函数。</li><li>第二步：编译器调用 operator delete（或 operator delete[]）函数释放内存空间。</li></ul><p>总之来说，new/delete 会调用对象的构造函数/析构函数以完成对象的构造/析构。而 malloc 则不会。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() : a(<span class="number">1</span>), b(<span class="number">1.11</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A *ptr = (A*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 return 处设置断点，观看 ptr 所指内存的内容：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/malloc%E4%B8%8Enew/610439-20160119004300406-962244228.png" alt=""></p><p>可以看出 A 的默认构造函数并没有被调用，因为数据成员 a、b 的值并没有得到初始化，这也是上面我为什么说使用 malloc/free 来处理 C++ 的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p><p>而使用 new 来分配对象时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *ptr = <span class="keyword">new</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看程序生成的汇编代码可以发现，A 的默认构造函数被调用了：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/malloc%E4%B8%8Enew/610439-20160119004332328-1197338727.png" alt=""></p><h3 id="六、对数组的处理"><a href="#六、对数组的处理" class="headerlink" title="六、对数组的处理"></a>六、对数组的处理</h3><p>C++ 提供了 new[] 与 delete[] 来专门处理数组类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr = <span class="keyword">new</span> A[<span class="number">10</span>]; <span class="comment">//分配10个A对象</span></span><br></pre></td></tr></table></figure><p>使用 new[] 分配的内存必须使用 delete[] 进行释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure><p>new 对数组的支持体现在它会分别调用构造函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意 delete[] 要与 new[] 配套使用，不然会造成数组对象部分释放的现象，造成内存泄漏。</p><p>至于 malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，再给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);   <span class="comment">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></figure><h3 id="七、new与malloc是否可以相互调用"><a href="#七、new与malloc是否可以相互调用" class="headerlink" title="七、new与malloc是否可以相互调用"></a>七、new与malloc是否可以相互调用</h3><p>operator new /operator delete 的实现可以基于 malloc，而 malloc 的实现不可以去调用 new。下面是编写 operator new /operator delete 的一种简单方式，其他版本也与之类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">sieze_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">void</span> * mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、是否可以被重载"><a href="#八、是否可以被重载" class="headerlink" title="八、是否可以被重载"></a>八、是否可以被重载</h3><p>opeartor new /operator delete 可以被重载。标准库是定义了 operator new 函数和 operator delete 函数的 8 个重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> * )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些版本承诺不抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> *, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载 operator new /operator delete，以决定我们的 new 与 delete 如何为对象分配内存，如何回收对象。</p><p><strong>而 malloc/free 并不允许重载</strong>。</p><h3 id="九、能够直观地重新分配内存"><a href="#九、能够直观地重新分配内存" class="headerlink" title="九、能够直观地重新分配内存"></a>九、能够直观地重新分配内存</h3><p>使用 malloc 分配的内存后，如果在使用过程中发现内存不足，可以使用 realloc 函数进行内存重新分配实现内存的扩充。realloc 先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p><p>new 没有这样直观的配套设施来扩充内存。</p><h3 id="十、客户处理内存分配不足"><a href="#十、客户处理内存分配不足" class="headerlink" title="十、客户处理内存分配不足"></a>十、客户处理内存分配不足</h3><p>在 operator new 抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是 new-handler。new_handler 是一个指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向了一个没有参数没有返回值的函数，即为错误处理函数。为了指定错误处理函数，客户需要调用 set_new_handler，这是一个声明于的一个标准库函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set_new_handler 的参数为 new_handler 指针，指向了 operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler 被调用前正在执行（但马上就要发生替换）的那个 new_handler 函数。</p><p>对于 malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着 malloc 返回 NULL。</p><h3 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h3><table><thead><tr><th align="center"><strong>特征</strong></th><th align="center"><strong>new/delete</strong></th><th align="center"><strong>malloc/free</strong></th></tr></thead><tbody><tr><td align="center">分配内存的位置</td><td align="center">自由存储区</td><td align="center">堆</td></tr><tr><td align="center">内存分配成功的返回值</td><td align="center">完整类型指针</td><td align="center">void*</td></tr><tr><td align="center">内存分配失败的返回值</td><td align="center">默认抛出异常</td><td align="center">返回 NULL</td></tr><tr><td align="center">分配内存的大小</td><td align="center">由编译器根据类型计算得出</td><td align="center">必须显式指定字节数</td></tr><tr><td align="center">处理数组</td><td align="center">有处理数组的 new 版本 new[]</td><td align="center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td align="center">已分配内存的扩充</td><td align="center">无法直观地处理</td><td align="center">使用 realloc 简单完成</td></tr><tr><td align="center">是否相互调用</td><td align="center">可以，看具体的 operator new/delete 实现</td><td align="center">不可调用 new</td></tr><tr><td align="center">分配内存时内存不足</td><td align="center">客户能够指定处理函数或重新制定分配器</td><td align="center">无法通过用户代码进行处理</td></tr><tr><td align="center">函数重载</td><td align="center">允许</td><td align="center">不允许</td></tr><tr><td align="center">构造函数与析构函数</td><td align="center">调用</td><td align="center">不调用</td></tr></tbody></table><p>malloc 给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/malloc%E4%B8%8Enew/610439-20160119011445828-2003774083.jpg" alt=""></p><p>而 new 帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/malloc%E4%B8%8Enew/610439-20160119012007484-749179736.jpg" alt=""></p><p>当然，malloc 并不是说比不上 new，它们各自有适用的地方。在 C++ 这种偏重 OOP 的语言，使用 new/delete 自然是更合适的。</p><p><strong>参考原文</strong>:<br><a href="https://www.cnblogs.com/qg-whz/p/5140930.html">细说new与malloc的10点区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;new 与 malloc 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/categories/C/"/>
    
      <category term="内存" scheme="https://www.beyondhxl.com/categories/C/%E5%86%85%E5%AD%98/"/>
    
      <category term="内存分配" scheme="https://www.beyondhxl.com/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="malloc、new" scheme="https://www.beyondhxl.com/categories/C/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/malloc%E3%80%81new/"/>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/tags/C/"/>
    
      <category term="new" scheme="https://www.beyondhxl.com/tags/new/"/>
    
      <category term="malloc" scheme="https://www.beyondhxl.com/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型（简单对象模型、表格驱动模型、C++对象模型）</title>
    <link href="https://www.beyondhxl.com/post/1787b1c6.html"/>
    <id>https://www.beyondhxl.com/post/1787b1c6.html</id>
    <published>2020-08-02T01:25:53.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>深度探索 C++ 对象模型</strong></p></blockquote><a id="more"></a><h3 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h3><p>对象模型是深层结构知识，关系到“与语言无关、与平台无关、跨网络可执行”软件组件的基础。</p><p>C++ 相对于精瘦的 C 来说，多了许多特性，正因如此，我们更有必要去探索、了解 C++ 对象模型，到底背着我们又发生了什么事情。在了解 C++ 对象模型之前，有必要先从简单一点的两个模型入手：<strong>简单对象模型、表格驱动模型</strong>。</p><h3 id="一、简单对象模型"><a href="#一、简单对象模型" class="headerlink" title="一、简单对象模型"></a>一、简单对象模型</h3><p>现在我们考虑一个 Point 类，其声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++ 中，成员数据（class data member）有两种：<strong>static</strong> 和 <strong>nonstatic</strong>，成员函数（class member function）有三种：<strong>static</strong>、<strong>nonstatic</strong> 和 <strong>virtual</strong>。</p><p>那么上述的 Point 类，用简单对象模型应该怎么塑模这些 data members 和 function members 呢，如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20200802013614.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20200802013811.png" alt=""></p><p>这个对象模型比较简单，在这个简单模型中，object 中存放的并不是 member 而是一系列的 slots，每个 slot 指向一个 member，按 member 在 class 中的声明顺序，即 object 中存放的是“指向 member 的指针”，这就避免了因不同类型的 member 需要不同存储空间所带来的问题。</p><h3 id="二、表格驱动模型"><a href="#二、表格驱动模型" class="headerlink" title="二、表格驱动模型"></a>二、表格驱动模型</h3><p>与简单对象模型类似，但又有所不同。表格驱动对象模型将 class 中的 member 分成 data 和 function 两个部分，一个放在 data member table 中，一个放在 member function table 中，而 class object 则持有指向这两个 table 的指针。在往下划分，data member table 直接存放 data 本身，而 member function table 则是一系列的 slots，每个 slot 指向一个 member function，如下。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20200802014019.png" alt=""></p><p>这种对象模型不会因 class 中 data membe 和 member function 的增减而改变其大小，但在操作 member function 时，比 data member 多了一次寻址。</p><h3 id="三、CPlusPlus-对象模型"><a href="#三、CPlusPlus-对象模型" class="headerlink" title="三、CPlusPlus 对象模型"></a>三、CPlusPlus 对象模型</h3><p>C++ 对象模型是从简单对象模型派生而来的，并对内存空间和存取时间做了优化。在此模型中对 data 而言 nonstatic data member 被置于class object 之内，static data member 被置于 class object 之外；对 function 而言，static 和 nonstatic member function 被置于 class object 之外，virtual member function 则由以下两步支持：</p><ol><li>每一个 class 产生出一堆指向 virtual function 的指针，并存放于表格中，即 virtual table（vtbl）；</li><li>每个 class object 被安插一个指针（vptr），指向相关的 virtual table。 </li></ol><p>上面两点是用以支持 virtual function 的。在 C++ 中，关键字 virtual 的存在只有两处，一出现在 member function 之前形成 virtual function，二出现在 inheritance 时形成 virtual inheritance（虚拟继承），若 base class 或 derived class 不是以上两种情况，也无 virtual table 之说了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/20200802014409.png" alt=""></p><p>另外，在 C++ 对象模型中我们可以看到 vptr 指向的 virtual table 中多了一个 type_info，并且位于 vtbl 的第一个 slot，这是用以支持rumtime type identification（RTTI）的，vptr 这个指针的设定、重置都由每一个 class 的 constructor、destructor 和 copy assignment 运算符自动完成。</p><p>更进一步的说，pt-&gt;vtbl[0] 指向 Point 的 type_info object，pt-&gt;vtbl[1] 指向 Point::~Point()，pt-&gt;vtbl[2] 指向 Point::print()。</p><p><strong>参考原文</strong>:<br><a href="https://blog.csdn.net/hujingshuang/article/details/52856552">《深度探索C++对象模型》：简单对象模型、表格驱动模型、C++对象模型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;深度探索 C++ 对象模型&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/categories/C/"/>
    
      <category term="对象模型" scheme="https://www.beyondhxl.com/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="简单对象模型、表格驱动模型、C++对象模型" scheme="https://www.beyondhxl.com/categories/C/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E3%80%81C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/tags/C/"/>
    
      <category term="对象模型" scheme="https://www.beyondhxl.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>游戏服务器的架构演进(转载)</title>
    <link href="https://www.beyondhxl.com/post/7899d015.html"/>
    <id>https://www.beyondhxl.com/post/7899d015.html</id>
    <published>2020-08-01T23:12:11.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>游戏服务器的架构演进</strong></p></blockquote><a id="more"></a><h2 id="一、游戏服务器特征"><a href="#一、游戏服务器特征" class="headerlink" title="一、游戏服务器特征"></a>一、游戏服务器特征</h2><p>游戏服务器端，是一个会长期运行的程序，并且它还要服务于多个不定时，不定点的网络请求。所以这类软件的特点是要非常关注稳定性和性能。这类程序如果需要多个协作来提高承载能力，则还要关注部署和扩容的便利性；同时，还需要考虑如何实现某种程度容灾需求。由于多进程协同工作，也带来了开发的复杂度，这也是需要关注的问题。</p><p>功能约束，是架构设计决定性因素。基于游戏领域的功能特征，对服务器端系统来说，有以下几个特殊的需求：</p><ol><li>对于游戏数据和玩家数据的存储</li><li>对玩家数据进行数据广播和同步</li><li>把一部分游戏逻辑在服务器上运算，做好验证，防止外挂</li></ol><p>针对以上的需求特征，在服务器端，我们往往会关注对电脑内存和 CPU 的使用，以求在特定业务代码下，能尽量满足承载量和响应延迟的需求。最基本的做法就是“空间换时间”，用各种缓存的方式来以求得 CPU 和内存空间上的平衡。</p><p>在 CPU 和内存之上，是另外一个约束因素<strong>网卡</strong>。网络带宽直接限制了服务器的处理能力，所以游戏服务器架构也必定要考虑这个因素。</p><h2 id="二、游戏服务器架构要素"><a href="#二、游戏服务器架构要素" class="headerlink" title="二、游戏服务器架构要素"></a>二、游戏服务器架构要素</h2><p>对于游戏服务端架构，最重要的三个部分就是，如何使用 CPU、内存、网卡的设计：</p><ul><li><p><strong>内存架构</strong>：主要决定服务器如何使用内存，以最大化利用服务器端内存来提高承载量，降低服务延迟。</p></li><li><p><strong>逻辑架构</strong>：设计如何使用进程、线程、协程这些对于 CPU 调度的方案。选择同步、异步等不同的编程模型，以提高服务器的稳定性和承载量。可以分区分服，也可以采用世界服的方式，将相同功能模块划分到不同的服务器来处理。</p></li><li><p><strong>通信模式</strong>：决定使用何种方式通讯。基于游戏类型不同采用不同的通信模式，比如 http、tcp、udp 等。</p></li></ul><h2 id="三、服务器演化进程"><a href="#三、服务器演化进程" class="headerlink" title="三、服务器演化进程"></a>三、服务器演化进程</h2><h3 id="3-1、卡牌等休闲游戏弱交互游戏"><a href="#3-1、卡牌等休闲游戏弱交互游戏" class="headerlink" title="3.1、卡牌等休闲游戏弱交互游戏"></a>3.1、卡牌等休闲游戏弱交互游戏</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200801232306.png" alt=""></p><p>这种服务器架构和我们常用的 web 服务器架构差不多，也是采用 nginx 负载集群支持服务器的水平扩展，memcache 做缓存。</p><p>唯一不同在于通信层需要对协议再加工和加密，一般每个公司都有自己的一套基于 http 的协议层框架，很少采用开源框架。</p><h3 id="3-2、长链接游戏服务器"><a href="#3-2、长链接游戏服务器" class="headerlink" title="3.2、长链接游戏服务器"></a>3.2、长链接游戏服务器</h3><p>长连接游戏和弱联网游戏不同的地方在于，长连接中，玩家是有状态的，服务器可以时时和 client 交互，数据的传送，不像弱联网一般每次都需要重新创建一个连接，消息传送的频率以及速度上都快于弱联网游戏。</p><h4 id="1、第一代网游服务器（单线程无阻塞）"><a href="#1、第一代网游服务器（单线程无阻塞）" class="headerlink" title="1、第一代网游服务器（单线程无阻塞）"></a>1、第一代网游服务器（单线程无阻塞）</h4><p>最早的游戏服务器是 1978 年，英国著名的财经学校 University of Essex 的学生 Roy Trubshaw 编写了世界上第一个 MUD 程序，叫做《MUD1》。</p><p>《MUD1》程序的源代码在 ARPANET 共享之后，在全世界广泛流行起来。不断完善的 MUD1 的基础上产生了开源的 MudOS（1991），成为众多网游的鼻祖。</p><p>《MUD1》是一款纯文字的世界，没有任何图片，但是不同计算机前的玩家可以在游戏里共同冒险、交流。</p><p>与以往具有网络联机功能的游戏相比，MUD1 是第一款真正意义上的实时多人交互的网络游戏，它最大的特色是能够保证整个虚拟世界和玩家角色的持续发展 —— 无论是玩家退出后重新登录还是服务器重启，游戏中的场景、宝箱、怪物和谜题仍保持不变，玩家的角色也依然是上次的状态。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200801233819.png" alt=""></p><p>MUDOS 使用单线程无阻塞套接字来服务所有玩家，所有玩家的请求都发到同一个线程去处理，主线程每隔 1 秒钟更新一次所有对象（网络收发，对象状态，刷新地图，刷新 NPC）。</p><p>用户使用 Telnet 之类的客户端用 Tcp 协议连接到 MUDOS上，使用纯文字进行游戏，每条指令用回车进行分割。这样的系统在当时每台服务器承载个 4000 人同时游戏。从 1991 年的 MUDOS 发布后，全球各地都在为他改进，扩充，推出新版本。</p><p>MUDOS 中游戏内容通过 LPC 脚本进行定制，逻辑处理采用单线程 tick 轮询，这也是第一款服务端架构模型，后来被应用到不同游戏上。后续很多游戏都是跟《UO》一样，直接在 MUDOS 上进行二次开发，直到如今，一些回合制游戏，以及对运算量小的游戏，依然采用这种服务器架构。</p><p>第一代服务器架构图</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200801234436.png" alt=""></p><p>线程模型</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200801234443.png" alt=""></p><h4 id="2、第二代网游服务器（分区分服）"><a href="#2、第二代网游服务器（分区分服）" class="headerlink" title="2、第二代网游服务器（分区分服）"></a>2、第二代网游服务器（分区分服）</h4><p>2000 年左右，随着图形界面的出现，游戏更多的采用图形界面与用户交互。此时随着在线人数的增加和游戏数据的增加，服务器变得不堪重负。于是就有了分服模型。分服模型结构如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200801235044.pn" alt=""></p><p>分服模型是游戏服务器中最典型，也是历久最悠久的模型。在早期服务器的承载量达到上限的时候，游戏开发者就通过架设更多的服务器来解决。这样提供了很多个游戏的“平行世界”，让游戏中的人与人之间的比较，产生了更多的空间。</p><p>其特征是游戏服务器是一个个单独的世界。每个服务器的帐号是独立的，每台服务器用户的状态都是不一样的，一个服就是一个世界，大家各不牵扯。</p><p>后来游戏玩家呼吁要跨服打架，于是出现了跨服战，再加上随着游戏的运行，单个服务器的游戏活跃玩家越来越少，所以后期就有了服务器的合并以及迁移，慢慢的以服务器的开放、合并形成了一套成熟的运营手段。目前多数游戏还采用分服的结构来架设服务器，多数页游还是采用这种模式。</p><p><strong>线程调度</strong></p><p>分服虽然可以解决服务器扩展的瓶颈，但单台服务器在以前单线程的方式来运行，没办法充分利用服务器资源，于是又演变出了以下2种线程模型。</p><ul><li><strong>异步-多线程</strong></li></ul><ol><li>基于每个场景（或者房间），分配一个线程。每个场景的玩家同属于一个线程。游戏的场景是固定的，不会很多，如此线程的数量可以保证不会不断增大。每个场景线程，同样采用 tick 轮询的方式，来定时更新该场景内的（对象状态，刷新地图，刷新 NPC）数据状态。玩家如果跨场景的话，就采用投递和通知的方式，告知两个场景线程，以此更新两个场景的玩家数据。</li></ol><ul><li><strong>多进程</strong></li></ul><ol><li>由于单进程架构下，总会存在承载量的极限，越是复杂的游戏，其单进程承载量就越低，因此一定要突破进程的限制，才能支撑更复杂的游戏。多进程系统的其他一些好处：能够利用上多核 CPU 能力、更容易进行容灾处理。</li><li>多进程系统比较经典的模型是“三层架构”，比如，基于之前的场景线程再做改进，把网络部分和数据库部分分离为单独的进程来处理，逻辑进程专心处理逻辑任务，不合 IO 打交道，网络 IO 和磁盘 IO分 别交由网路进程和 DB 进程处理。</li></ol><h4 id="3、第三代网游服务器"><a href="#3、第三代网游服务器" class="headerlink" title="3、第三代网游服务器"></a>3、第三代网游服务器</h4><p>之前的网游服务器都是分区分服，玩家都被划分在不同的服务器上，每台服务器运行的逻辑相同，玩家不能在不同服务器之间交互。想要更多的玩家在同一世界，保持玩家的活跃度，于是就有了世界服模型了。世界服类型也有以下 3 种演化:</p><p><strong>一类型（三层架构）</strong></p><p>网关部分分离成单独的 gate 服务器，DB 部分分离为 DB 服务器，把网络功能单独提取出来，让用户统一去连接一个网关服务器，再由网关服务器转发数据到后端游戏服务器。而游戏服务器之间数据交换也统一连接到网关进行交换。所有有 DB 交互的，都连接到 DB 服务器来代理处理。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200802000433.png" alt=""></p><p><strong>二类型（cluster）</strong></p><p>有了一类型的经验，后续肯定是拆分的越细，性能越好，就类似现在微服务，每个相同的模块分布到一台服务器处理，多组服务器集群共同组成一个游戏服务端。</p><p>一般地，我们可以将一个组内的服务器简单地分成两类：场景相关的（如行走、战斗等）以及场景不相关的（如公会聊天、不受区域限制的贸易等）。经常可以见到的一种方案是：gate 服务器、场景服务器、非场景服务器、聊天管理器、AI 服务器以及数据库代理服务器。如下模型:</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200802000611.png" alt=""></p><p>我们简单的讲下服务器的三种类型功能：</p><ul><li><p><strong>场景服务器</strong>：它负责完成主要的游戏逻辑，这些逻辑包括：角色在游戏场景中的进入与退出、角色的行走与跑动、角色战斗（包括打怪）、任务的认领等。场景服务器设计的好坏是整个游戏世界服务器性能差异的主要体现，它的设计难度不仅仅在于通信模型方面，更主要的是整个服务器的体系架构和同步机制的设计。</p></li><li><p><strong>非场景服务器</strong>：它主要负责完成与游戏场景不相关的游戏逻辑，这些逻辑不依靠游戏的地图系统也能正常进行，比如公会聊天或世界聊天，之所以把它从场景服务器中独立出来，是为了节省场景服务器的 CPU 和带宽资源，让场景服务器能够尽可能快地处理那些对游戏流畅性影响较大的游戏逻辑。</p></li><li><p><strong>网关服务器</strong>: 在类型一种的架构中，玩家在多个地图跳转或者场景切换的时候采用跳转的模式，以此进行跳转不同的服务器。还有一种方式是把这些服务器的节点都通过网关服务器管理，玩家和网关服务器交互，每个场景或者服务器切换的时候，也有网关服务器统一来交换数据，如此玩家操作会比较流畅。</p></li></ul><p>通过这种类型服务器架构，因为压力分散了，性能会有明显提升，负载也更大了，包括目前一些大型的 MMORPG 游戏就是采用此架构。不过每增加一级服务器，状态机复杂度可能会翻倍，导致研发和找 bug 的成本上升，这个对开发组挑战比较大，没有经验，很容易出错。</p><p><strong>三类型（无缝地图）</strong></p><p>魔兽世界的中无缝地图，想必大家印象深刻。整个世界的移动没有像以往的游戏一样，在切换场景的时候需要 loading 等待，而是直接行走过去，体验流畅。</p><p>现在的游戏大地图采用无缝地图多数采用的是 9 宫格的样式来处理，由于地图没有魔兽世界那么大，所以采用单台服务器多进程处理即可，不过类似魔兽世界这种大世界地图，必须考虑 2 个问题：</p><ol><li>多个地图节点如何无缝拼接，特别是当地图节点比较多的时候，如何保证无缝拼接</li><li>如何支持动态分布，有些区域人多，有些区域人少，保证服务器资源利用的最大化</li></ol><p>为了解决这个问题，比较以往按照地图来切割游戏而言，无缝世界并不存在一块地图上面的人有且只由一台服务器处理了，此时需要一组服务器来处理，每台 Node 服务器用来管理一块地图区域，由 NodeMaster（NM）来为他们提供总体管理。更高层次的 World 则提供大陆级别的管理服务。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200802004137.png" alt=""></p><p>一个 Node 所负责的区域，地理上没必要连接在一起，可以统一交给一个 Node 去管理，而这些区块在地理上并没有联系在一起的必要性。一个 Node 到底管理哪些区块，可以根据游戏实时运行的负载情况，定时维护的时候进行更改 NodeMaster 上面的配置。</p><p><strong>对象的无缝迁移</strong></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200802004254.png" alt=""></p><p>玩家 A、B、C 分别代表 3 种不同的状态，以及不同的迁移方式，我们分别来看。</p><p><strong>玩家 A</strong>：玩家 A 在 node1 地图服务器上，由 node1 控制，如果迁移到 node2 上，需要将其数据复制到 node2 上，然后从 node1 移除。</p><p><strong>玩家 B</strong>：玩家 B 在 node1 和 node2 中间，此时由 node1 和 node2 维护，若是从 node1 行走到 node2 的过程中，会向 1 请求，同时向 2 请求，待全部移动过去了再移除。</p><p><strong>玩家 C</strong>：玩家 C 在 node2 地图服务器上，由 node2 控制，如果迁移到 node1 上，需要将其数据复制到 node1 上，然后从 node2 移除。</p><h3 id="3-3、房间服务器（游戏大厅）"><a href="#3-3、房间服务器（游戏大厅）" class="headerlink" title="3.3、房间服务器（游戏大厅）"></a>3.3、房间服务器（游戏大厅）</h3><p>房间类玩法和 MMORPG 有很大的不同，在于其在线广播单元的不确定性和广播数量很小。而且需要匹配一台房间服务器让少数人进入一个服务器。</p><p>这一类游戏最重要的是其“游戏大厅”的承载量，每个“游戏房间”受逻辑所限，需要维持和广播的玩家数据是有限的，但是“游戏大厅”需要维持相当高的在线用户数，所以一般来说，这种游戏还是需要做“分服”的。典型的游戏就是《英雄联盟》这一类游戏了。而“游戏大厅”里面最有挑战性的任务，就是“自动匹配”玩家进入一个“游戏房间”，这需要对所有在线玩家做搜索和过滤。</p><p>玩家先登录“大厅服务器”，然后选择组队游戏的功能，服务器会通知参与的所有游戏客户端，新开一条连接到房间服务器上，这样所有参与的用户就能在房间服务器里进行游戏交互了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/20200802004752.png" alt=""></p><p><strong>参考原文</strong>:<br><a href="https://juejin.im/entry/6844903488422412295">游戏服务器的架构演进(完整版)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;游戏服务器的架构演进&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏服务器" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="架构" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="游戏开发" scheme="https://www.beyondhxl.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏服务器" scheme="https://www.beyondhxl.com/tags/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="架构" scheme="https://www.beyondhxl.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Google-C++编程代码风格(转载)</title>
    <link href="https://www.beyondhxl.com/post/d5d5709a.html"/>
    <id>https://www.beyondhxl.com/post/d5d5709a.html</id>
    <published>2020-07-31T22:44:00.000Z</published>
    <updated>2024-08-02T20:36:09.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Google C++ Code Style</strong></p></blockquote><a id="more"></a><h2 id="零、序"><a href="#零、序" class="headerlink" title="零、序"></a>零、序</h2><p>C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的，C++ 有很多强大的特性，但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug， 难以阅读和维护。</p><p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时，也能高效使用 C++ 的语言特性。</p><p>风格亦被称作可读性，也就是指导 C++ 编程的约定。使用术语 “风格” 有些用词不当，因为这些习惯远不止源代码文件格式化这么简单。</p><p>使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用、必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格，但我们还是应该遵循一致性原则，尽量不这么做。</p><h2 id="一、预编译"><a href="#一、预编译" class="headerlink" title="一、预编译"></a>一、预编译</h2><h3 id="1-1、头文件"><a href="#1-1、头文件" class="headerlink" title="1.1、头文件"></a>1.1、头文件</h3><p>一个 .cc/.cpp 文件都应该对应一个 .h 文件。也有些常见例外，例如单元测试代码和只包含 main() 入口函数的源文件。</p><h4 id="1-1-1、Self-contained-头文件"><a href="#1-1-1、Self-contained-头文件" class="headerlink" title="1.1.1、Self-contained 头文件"></a>1.1.1、Self-contained 头文件</h4><blockquote><p>头文件应该能够自给自足（self-contained，也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在 .cc 文件中调整引入顺序解决依赖。</p></blockquote><p>如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 .cc 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。</p><p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。</p><h4 id="1-1-2、-define-保护"><a href="#1-1-2、-define-保护" class="headerlink" title="1.1.2、#define 保护"></a>1.1.2、#define 保护</h4><blockquote><p>所有头文件都应该使用 #define 来防止头文件被多重包含，命名格式当是：<strong>&lt; PROJECT &gt; _ &lt; PATH &gt; _ &lt; FILE &gt; _ H _</strong>。</p></blockquote><p>为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。例如项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure><p><strong>#define 与 #pragma once 区别</strong></p><p><code>#pragma once</code> 是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。所以尽量使用 #ifndef 来避免头文件重复引用。</p><h4 id="1-1-3、前置声明"><a href="#1-1-3、前置声明" class="headerlink" title="1.1.3、前置声明"></a>1.1.3、前置声明</h4><blockquote><p>尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。</p></blockquote><p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没有伴随着定义。</p><ul><li><strong>优点</strong></li></ul><ol><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。#include 使代码因为头文件中无关的改动而被重新编译多次。</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li><p>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p></li><li><p>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API。例如扩大形参类型，加个自带默认参数的模板形参等等。</p></li><li><p>前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。</p></li><li><p>很难判断什么时候该用前置声明，什么时候该用 #include。极端情况下，用前置声明代替 #include 甚至都会暗暗地改变代码的含义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; f(x); &#125;  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></table></figure><p><code>如果 #include 被 B 和 D 的前置声明替代，test() 就会调用 f(void*)。</code></p></li><li><p>前置声明不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。</p></li><li><p>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</p></li></ol><ul><li><strong>结论</strong></li></ul><ol><li>尽量避免前置声明那些定义在其他项目中的实体。</li><li>函数总是使用 #include。</li><li>类模板优先使用 #include。</li></ol><h4 id="1-1-4、内联函数"><a href="#1-1-4、内联函数" class="headerlink" title="1.1.4、内联函数"></a>1.1.4、内联函数</h4><blockquote><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数。</p></blockquote><ul><li><p><strong>定义</strong><br>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p></li><li><p><strong>优点</strong><br>只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。</p></li><li><p><strong>缺点</strong><br>滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。</p></li><li><p><strong>结论</strong><br>一个较为合理的经验准则是，不要内联超过 10 行的函数。谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用。</p></li></ul><p>有些函数即使声明为内联的也不一定会被编译器内联，这点很重要；比如<strong>虚函数</strong>和<strong>递归函数</strong>就不会被正常内联。通常递归函数不应该声明成内联函数，递归调用堆栈的展开并不像循环那么简单，比如递归层数在编译时可能是未知的，大多数编译器都不支持内联递归函数。虚函数内联的主要原因则是想把它的函数体放在类定义内，为了图个方便，抑或是当作文档描述其行为，比如精短的存取函数。</p><h4 id="1-1-5、-include-的路径及顺序"><a href="#1-1-5、-include-的路径及顺序" class="headerlink" title="1.1.5、#include 的路径及顺序"></a>1.1.5、#include 的路径及顺序</h4><blockquote><p>使用标准的头文件包含顺序可增强可读性，避免隐藏依赖相关头文件、C 库、C++ 库、其他库的 .h，本项目内的 .h。</p></blockquote><p>项目内头文件应按照项目源代码目录树结构排列，避免使用 UNIX 特殊的快捷目录 <code>.(当前目录)</code> 或 <code>..(上级目录)</code>。例如， google-awesome-project/src/base/logging.h 应该按如下方式包含:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/logging.h"</span></span></span><br></pre></td></tr></table></figure><p>又如，dir/foo.cc 或 dir/foo_test.cc 的主要作用是实现或测试 dir2/foo2.h 的功能，foo.cc 中包含头文件的次序如下：</p><ol><li>dir2/foo2.h（优先位置，详情如下）</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 .h 文件</li><li>本项目内 .h 文件</li></ol><p>这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时，dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p>您所依赖的符号（symbols）被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。比如您要用到 bar.h 中的某个符号，哪怕您所包含的 foo.h 已经包含了 bar.h，也照样得包含bar.h，除非 foo.h 有明确说明它会自动向您提供bar.h 中的 symbol。不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 foo.cc 只包含foo.h 就够了，不用再管后者所包含的其它内容。</p><p>举例来说，google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/basictypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/commandlineflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/bar.h"</span></span></span><br></pre></td></tr></table></figure><h4 id="1-1-6、小结"><a href="#1-1-6、小结" class="headerlink" title="1.1.6、小结"></a>1.1.6、小结</h4><ol><li>避免多重包含。</li><li>头文件尽量避免使用前置声明，直接 #include。</li><li>内联函数最好少于 10 行。类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cc 文件里。</li><li>包含文件的次序除了美观之外，最重要的是可以减少隐藏依赖，使每个头文件在 “最需要编译” 的地方编译。</li></ol><h3 id="1-2、作用域"><a href="#1-2、作用域" class="headerlink" title="1.2、作用域"></a>1.2、作用域</h3><h4 id="1-2-1、命名空间"><a href="#1-2-1、命名空间" class="headerlink" title="1.2.1、命名空间"></a>1.2.1、命名空间</h4><blockquote><p>鼓励在 .cc 文件内使用匿名命名空间或 static 声明。使用具名的命名空间时，其名称可基于项目名或相对路径。禁止使用 using 指示 （using-directive e.g. using namespace foo;）。禁止使用内联命名空间 (inline namespace)。</p></blockquote><ul><li><strong>定义</strong></li></ul><ol><li>命名空间将全局作用域细分为独立的，具名的作用域，可有效防止全局作用域的命名冲突。</li></ol><ul><li><strong>优点</strong></li></ul><ol><li>类已经提将命名分割在不同类的作用域内，命名空间在这基础上又封装了一层。</li><li>举例来说，两个不同项目的全局作用域都有一个类 Foo，这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中， project1::Foo 和 project2::Foo 作为不同符号自然不会冲突。</li><li>内联命名空间会自动把内部的标识符放到外层作用域，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace Y</span></span><br><span class="line">&#125;  <span class="comment">// namespace X</span></span><br></pre></td></tr></table></figure>X::Y::foo() 与 X::foo() 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>命名空间具有迷惑性，因为它们使得区分两个相同命名所指代的定义更加困难。</li><li>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</li></ol><ul><li><strong>结论</strong></li></ul><ol start="0"><li>根据下文将要提到的策略合理使用命名空间。</li><li>遵守<strong>命名空间命名</strong>中的规则。</li><li>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</li><li>用命名空间把文件包含，以及类的前置声明以外的整个源文件封装起来，以区别于其它命名空间:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure></li><li>不要在命名空间 std 内声明任何东西，包括标准库的类前置声明。在 std 命名空间声明实体是未定义的行为，会导致如不可移植。声明标准库下的实体，需要包含对应的头文件。</li><li>不应该使用 using 指示引入整个命名空间的标识符号。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure></li><li>不要在头文件中使用命名空间别名，除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开 API 的一部分。</li><li>禁止用内联命名空间</li></ol><h4 id="1-2-2、匿名命名空间和静态变量"><a href="#1-2-2、匿名命名空间和静态变量" class="headerlink" title="1.2.2、匿名命名空间和静态变量"></a>1.2.2、匿名命名空间和静态变量</h4><blockquote><p>在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static。但是不要在 .h 文件中这么做。</p></blockquote><ul><li><p><strong>定义</strong><br>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p></li><li><p><strong>结论</strong><br>推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 .h 中使用。</p></li></ul><p>匿名命名空间的声明和具名的格式相同，在最后注释上 namespace:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3、非成员函数、静态成员函数和全局函数"><a href="#1-2-3、非成员函数、静态成员函数和全局函数" class="headerlink" title="1.2.3、非成员函数、静态成员函数和全局函数"></a>1.2.3、非成员函数、静态成员函数和全局函数</h4><blockquote><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。</p></blockquote><ul><li><p><strong>优点</strong><br>某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。</p></li><li><p><strong>缺点</strong><br>将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要的依赖关系时更是如此。</p></li><li><p><strong>结论</strong><br>有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。这样的函数可以被定义成静态成员，或是非成员函数。非成员函数不应依赖于外部变量，应尽量置于某个命名空间内。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。举例而言，对于头文件 myproject/foo_bar.h，应当使用</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line">  <span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">  &#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p>定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。</p><p>如果你必须定义非成员函数，又只是在 .cc 文件中使用它，可使用匿名命名空间或 static 链接关键字 (如 static int Foo() {…}) 限定其作用域。</p><h4 id="1-2-4、局部变量"><a href="#1-2-4、局部变量" class="headerlink" title="1.2.4、局部变量"></a>1.2.4、局部变量</h4><blockquote><p>将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化。</p></blockquote><p>C++ 允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置，了解变量的类型和初始值。特别是应使用初始化的方式替代声明再赋值, 比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = f();            <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = g();        <span class="comment">// 好——初始化时声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> v;</span><br><span class="line">v.push_back(<span class="number">1</span>);     <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// 好—— v 一开始就初始化</span></span><br></pre></td></tr></table></figure><p>属于 if、while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有一个例外，如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数。这会导致效率降低。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;    <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效的实现</span></span><br><span class="line">Foo f;    <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-5、静态和全局变量"><a href="#1-2-5、静态和全局变量" class="headerlink" title="1.2.5、静态和全局变量"></a>1.2.5、静态和全局变量</h4><blockquote><p>禁止定义静态储存周期非 POD 变量，禁止使用含有副作用的函数初始化 POD 全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p></blockquote><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型（POD : Plain Old Data）: 即 int、char 和 float，以及 POD 类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 getenv() 或 getpid()）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector（使用 C 数组替代）和 string（使用 const char []）。</p><h4 id="1-2-6、小结"><a href="#1-2-6、小结" class="headerlink" title="1.2.6、小结"></a>1.2.6、小结</h4><ol><li>.cc 中的匿名命名空间可避免命名冲突、限定作用域，避免直接使用 using 关键字污染命名空间</li><li>尽量不用全局函数和全局变量，考虑作用域和命名空间限制，尽量单独形成编译单元</li><li>多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器)，避免不明确行为导致的 bug</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效</li></ol><h2 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h2><p>类是 C++ 中代码的基本单元。显然，它们被广泛使用。本节列举了在写一个类时的主要注意事项。</p><h3 id="2-1、构造函数的职责"><a href="#2-1、构造函数的职责" class="headerlink" title="2.1、构造函数的职责"></a>2.1、构造函数的职责</h3><ul><li><strong>总述</strong></li></ul><ol><li>不要在构造函数中调用虚函数，也不要在无法报出错误时进行可能失败的初始化。</li></ol><ul><li><strong>定义</strong></li></ul><ol><li>在构造函数中可以进行各种初始化操作。</li></ol><ul><li><strong>优点</strong></li></ul><ol><li>无需考虑类是否被初始化</li><li>经过构造函数完全初始化后的对象可以为 const 类型，也能更方便地被标准容器或算法使用</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>如果在构造函数内调用了自身的虚函数，这类调用是不会重定向到子类的虚函数实现。即使当前没有子类化实现，将来仍是隐患。</li><li>如果执行失败，会得到一个初始化失败的对象，这个对象有可能进入不正常的状态，必须使用 bool isValid() 或类似这样的机制才能检查出来，然而这是一个十分容易被疏忽的方法。</li><li>构造函数的地址是无法被取得的，因此，举例来说，由构造函数完成的工作是无法以简单的方式交给其他线程的。</li></ol><ul><li><strong>结论</strong></li></ul><ol><li>构造函数不允许调用虚函数。如果代码允许，直接终止程序是一个合适的处理错误的方式。否则，考虑用 <strong>Init()</strong> 方法或工厂函数。</li></ol><h3 id="2-2、隐式类型转换"><a href="#2-2、隐式类型转换" class="headerlink" title="2.2、隐式类型转换"></a>2.2、隐式类型转换</h3><ul><li><strong>总述</strong></li></ul><ol><li>不要定义隐式类型转换。对于转换运算符和单参数构造函数，请使用 <strong>explicit</strong> 关键字。</li></ol><ul><li><strong>定义</strong></li></ul><ol><li><p>隐式类型转换允许一个某种类型 (称作源类型) 的对象被用于需要另一种类型 (称作目的类型) 的位置，例如将一个 int 类型的参数传递给需要double 类型的函数。</p></li><li><p>explicit 关键字可以用于构造函数或（在 C++11 引入）类型转换运算符，以保证只有当目的类型在调用点被显式写明时才能进行类型转换，例如使用 cast。这不仅作用于隐式类型转换，还能作用于 C++11 的列表初始化语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure><p>此时下面的代码是不允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func(&#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这一代码从技术上说并非隐式类型转换，但是语言标准认为这是 explicit 应当限制的行为。</p></li></ol><ul><li><strong>优点</strong></li></ul><ol><li>有时目的类型名是一目了然的，通过避免显式地写出类型名，隐式类型转换可以让一个类型的可用性和表达性更强。</li><li>隐式类型转换可以简单地取代函数重载。</li><li>在初始化对象时，列表初始化语法是一种简洁明了的写法。</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>隐式类型转换会隐藏类型不匹配的错误。有时目的类型并不符合用户的期望，甚至用户根本没有意识到发生了类型转换。</li><li>隐式类型转换会让代码难以阅读，尤其是在有函数重载的时候，因为这时很难判断到底是哪个函数被调用。</li><li>单参数构造函数有可能会被无意地用作隐式类型转换。</li><li>如果单参数构造函数没有加上 explicit 关键字，读者无法判断这一函数究竟是要作为隐式类型转换，还是作者忘了加上 explicit 标记。</li><li>并没有明确的方法用来判断哪个类应该提供类型转换，这会使得代码变得含糊不清。</li><li>如果目的类型是隐式指定的，那么列表初始化会出现和隐式类型转换一样的问题，尤其是在列表中只有一个元素的时候。</li></ol><ul><li><strong>结论</strong></li></ul><ol><li>在类型定义中，类型转换运算符和单参数构造函数都应当用 explicit 进行标记. 一个例外是拷贝和移动构造函数不应当被标记为 explicit,，因为它们并不执行类型转换。</li><li>不能以一个参数进行调用的构造函数不应当加上 explicit。接受一个 std::initializer_list 作为参数的构造函数也应当省略  explicit，以便支持拷贝初始化（例如 MyType m = {1, 2};）。</li></ol><h3 id="2-3、可拷贝类型和可移动类型"><a href="#2-3、可拷贝类型和可移动类型" class="headerlink" title="2.3、可拷贝类型和可移动类型"></a>2.3、可拷贝类型和可移动类型</h3><ul><li><strong>总述</strong></li></ul><ol><li>如果你的类型需要，就让它们支持拷贝 / 移动。否则，就把隐式产生的拷贝和移动函数禁用。</li></ol><ul><li><strong>定义</strong></li></ul><ol><li>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值，或在赋值时被赋予相同类型的另一对象的值，同时不改变源对象的值。对于用户定义的类型，拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义。string 类型就是一个可拷贝类型的例子。</li><li>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值，或在赋值时被赋予相同类型的临时对象的值（因此所有可拷贝对象也是可移动的）。std::unique_ptr&lt; int &gt; 就是一个可移动但不可复制的对象的例子。对于用户定义的类型，移动操作一般是通过移动构造函数和移动赋值操作符实现的。</li><li>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用。例如，通过传值的方式传递对象。</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>许多类型都不需要拷贝，为它们提供拷贝操作会让人迷惑，也显得荒谬而不合理。单件类型（Registerer），与特定的作用域相关的类型 （Cleanup），与其他对象实体紧耦合的类型（Mutex）从逻辑上来说都不应该提供拷贝操作。为基类提供拷贝 / 赋值操作是有害的，因为在使用它们时会造成对象切割。默认的或者随意的拷贝操作实现可能是不正确的，这往往导致令人困惑并且难以诊断出的错误。</li><li>拷贝构造函数是隐式调用的，也就是说，这些调用很容易被忽略。这会让人迷惑，尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此。同时，这从一定程度上说会鼓励过度拷贝，从而导致性能上的问题。</li></ol><ul><li><strong>结论</strong></li></ul><ol><li>如果需要就让你的类型可拷贝 / 可移动。作为一个经验法则，如果对于你的用户来说这个拷贝操作不是一眼就能看出来的，那就不要把类型设置为可拷贝。如果让类型可拷贝，一定要同时给出拷贝构造函数和赋值操作的定义，反之亦然。如果让类型可拷贝，同时移动操作的效率高于拷贝操作，那么就把移动的两个操作（移动构造函数和赋值操作）也给出定义。如果类型不可拷贝，但是移动操作的正确性对用户显然可见，那么把这个类型设置为只可移动并定义移动的两个操作。</li><li>如果定义了拷贝 / 移动操作，则要保证这些操作的默认实现是正确的。记得时刻检查默认操作的正确性，并且在文档中说明类是可拷贝的且 / 或可移动的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(Foo&amp;&amp; other) : field_(other.field) &#123;&#125;</span><br><span class="line">    <span class="comment">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Field field_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>由于存在对象切割的风险，不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数（当然也不要继承有这样的成员函数的类）。如果你的基类需要可复制属性，请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现。</li><li>如果你的类不需要拷贝 / 移动操作，请显式地通过在 public 域中使用 <code>= delete</code> 或其他手段禁用之。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>参考原文</strong>:<br><a href="https://blog.leosocy.top/Google%20C++%20Code%20Style/">Google C++ 编程风格</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google C++ Code Style&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/categories/C/"/>
    
      <category term="编程风格" scheme="https://www.beyondhxl.com/categories/C/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="Google Style" scheme="https://www.beyondhxl.com/categories/C/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/Google-Style/"/>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/tags/C/"/>
    
      <category term="Google" scheme="https://www.beyondhxl.com/tags/Google/"/>
    
      <category term="CodeStyle" scheme="https://www.beyondhxl.com/tags/CodeStyle/"/>
    
      <category term="代码风格" scheme="https://www.beyondhxl.com/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>无锁队列的一种实现</title>
    <link href="https://www.beyondhxl.com/post/870c5c36.html"/>
    <id>https://www.beyondhxl.com/post/870c5c36.html</id>
    <published>2020-07-31T22:15:05.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>无锁队列</strong></p></blockquote><a id="more"></a><p>无锁编程，称为 lock-free，是利用处理器的一些特殊原子指令来避免传统并行设计中对锁的使用，例如 x86 平台下对应的指令是 CMPXCHG。使用无锁编程至少能够带来两个方面的好处，首先是避免锁的争用，提高性能，其次通过避免锁的使用，避免死锁。无锁队列是无锁编程中最基础的，本文在这里给出一个实现。</p><h3 id="一、无锁编程基础"><a href="#一、无锁编程基础" class="headerlink" title="一、无锁编程基础"></a>一、无锁编程基础</h3><p>无锁编程最基本的一个操作是 <code>CAS(compare and swap)</code>，无锁编程的操作用 C++ 语言描述的话如下所示，简而言之就是看看 *reg 里面的内容是不是 oldval，如果是的话，对其复制为 newval。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span><span class="params">(T *reg, T oldval, T newval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*reg = oldval) &#123;</span><br><span class="line">        *reg = newval;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 实现是依赖编译器的：</p><ul><li>GCC 的 CAS<br>GCC4.1+ 版本支持 CAS 的原子操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...)</span><br></pre></td></tr></table></figure><ul><li>Windows 的 CAS</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterlockedCompareExchange ( __inout LONG <span class="keyword">volatile</span> *Target,</span><br><span class="line">                                __in LONG Exchange,</span><br><span class="line">                                __in LONG Comperand);</span><br></pre></td></tr></table></figure><ul><li>C++11 中的 CAS</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">atomic_compare_exchange_weak</span>( <span class="title">std</span>:</span>:atomic* obj,</span><br><span class="line">                                   T* expected, T desired );</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">atomic_compare_exchange_weak</span>( <span class="title">volatile</span> <span class="title">std</span>:</span>:atomic* obj,</span><br><span class="line">                                   T* expected, T desired );</span><br></pre></td></tr></table></figure><h3 id="二、无锁队列的实现"><a href="#二、无锁队列的实现" class="headerlink" title="二、无锁队列的实现"></a>二、无锁队列的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ListNode (<span class="keyword">int</span> val) : value(val), next(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode *head;</span><br><span class="line">    ListNode *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CASQueue() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        ListNode *p = tail;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (__sync_bool_compare_and_swap(&amp;p-&gt;next, <span class="literal">NULL</span>, node) != <span class="literal">true</span>);</span><br><span class="line">        __sync_bool_compare_and_swap(&amp;tail, p, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = head;</span><br><span class="line">        &#125; <span class="keyword">while</span> (__sync_bool_compare_and_swap(&amp;head, p, p-&gt;next) != <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> val = node-&gt;next-&gt;value;</span><br><span class="line">        <span class="keyword">delete</span> node-&gt;next;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CASQueue <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">queue</span>.push(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">queue</span>.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、CAS-的-ABA-问题"><a href="#三、CAS-的-ABA-问题" class="headerlink" title="三、CAS 的 ABA 问题"></a>三、CAS 的 ABA 问题</h3><p>CAS 的 ABA 问题可以概括如下：</p><ol><li>进程 P1 在共享变量中读到值为 A</li><li>P1 被抢占了，进程 P2 执行</li><li>P2 把共享变量里的值从 A 改成了 B，再改回到 A，此时被 P1 抢占</li><li>P1 回来看到共享变量里的值没有被改变，于是继续执行</li></ol><p>虽然 P1 以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。ABA 问题最容易发生在 lock free 的算法中的，CAS 首当其冲，因为 CAS 判断的是指针的地址。如果这个地址被重用了呢，问题就很大了。（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址）。</p><p>维基百科上有一个比较通俗的比喻：</p><blockquote><p>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。</p></blockquote><h3 id="四、解决-ABA-问题"><a href="#四、解决-ABA-问题" class="headerlink" title="四、解决 ABA 问题"></a>四、解决 ABA 问题</h3><p>可以用 double CAS，双保险 CAS 解决 ABA 问题，例如在 32 位系统上，我们要检查 64 位长的内容。</p><ul><li>一次用 CAS 检查双倍长度的值，前半部是指针，后半部分是一个计数器。</li><li>只有这两个都一样，才算通过检查，要赋新的值。并把计数器累加 1。</li><li>这样一来，ABA 发生时，虽然值一样，但是计数器就不一样（但是在 32 位的系统上，这个计数器会溢出回来又从 1 开始的，这还是会有 ABA 的问题）。</li></ul><p><strong>参考原文</strong>:<br><a href="http://harlon.org/2018/09/12/compare_and_swap/">无锁队列的实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;无锁队列&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="无锁队列" scheme="https://www.beyondhxl.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    
    
      <category term="操作系统" scheme="https://www.beyondhxl.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="无锁队列" scheme="https://www.beyondhxl.com/tags/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-浅谈控制反转与依赖注入</title>
    <link href="https://www.beyondhxl.com/post/27cdd96c.html"/>
    <id>https://www.beyondhxl.com/post/27cdd96c.html</id>
    <published>2020-07-31T16:45:36.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>控制反转与依赖注入</strong></p></blockquote><a id="more"></a><h3 id="一、小明和他的手机"><a href="#一、小明和他的手机" class="headerlink" title="一、小明和他的手机"></a>一、小明和他的手机</h3><p>从前有个人叫小明</p><p>小明有三大爱好，抽烟，喝酒…… 咳咳，不好意思，走错片场了。应该是逛知乎、玩王者农药和抢微信红包</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.jpg" alt="小明的三大爱好"></p><p>我们用一段简单的伪代码，来制造一个这样的小明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ming</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    private $_name;</span><br><span class="line"></span><br><span class="line">    private $_age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//逛知乎</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//玩农药</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">grab</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//抢红包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，小明作为一个人类，没有办法仅靠自己就能实现以上的功能，他必须依赖一部手机，所以他买了一台 iphone6，接下来我们来制造一个 iphone6。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iPhone6</span> <span class="keyword">extends</span> <span class="title">Iphone</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">$user=<span class="string">"某人"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        echo $user.<span class="string">"打开了知乎然后编了一个故事 \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params">$user=<span class="string">"某人"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        echo $user.<span class="string">"打开了王者农药并送起了人头 \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">grab</span>(<span class="params">$user=<span class="string">"某人"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        echo $user.<span class="string">"开始抢红包却只抢不发 \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明非常珍惜自己的新手机，每天把它牢牢<strong>控制</strong>在手心里，所以小明变成了这个样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ming</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    private $_name;</span><br><span class="line"></span><br><span class="line">    private $_age;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="keyword">function</span>  <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;_name = <span class="string">'小明'</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;_age = <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        (<span class="keyword">new</span> iPhone6())-&gt;read($<span class="keyword">this</span>-&gt;_name); <span class="comment">//逛知乎</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">play</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        (<span class="keyword">new</span> iPhone6())-&gt;play($<span class="keyword">this</span>-&gt;_name);<span class="comment">//玩农药</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">grab</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        (<span class="keyword">new</span> iPhone6())-&gt;grab($<span class="keyword">this</span>-&gt;_name);<span class="comment">//抢红包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天是周六，小明不用上班，于是他起床，并依次逛起了知乎，玩王者农药，并抢了个红包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ming = <span class="keyword">new</span> Ming();  <span class="comment">//小明起床</span></span><br><span class="line">$ming-&gt;read();</span><br><span class="line">$ming-&gt;play();</span><br><span class="line">$ming-&gt;grab();</span><br></pre></td></tr></table></figure><p>这个时候，我们可以在命令行里看到输出如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">小明打开了知乎然后编了一个故事</span> </span><br><span class="line"><span class="string">小明打开了王者农药并送起了人头</span> </span><br><span class="line"><span class="string">小明开始抢红包却只抢不发</span></span><br></pre></td></tr></table></figure><p>这一天，小明过得很充实，他觉得自己是世界上最幸福的人。</p><h3 id="二、小明的快乐与忧伤"><a href="#二、小明的快乐与忧伤" class="headerlink" title="二、小明的快乐与忧伤"></a>二、小明的快乐与忧伤</h3><p>小明和他的手机曾一起度过了一段美好的时光，一到空闲时刻，他就抱着手机，逛知乎，刷微博，玩游戏，他觉得自己根本不需要女朋友，只要有手机在身边，就满足了。</p><p>可谁能想到，一次次地系统更新彻底打碎了他的梦想，他的手机变得越来越卡顿，电池的使用寿命也越来越短，一直到某一天的寒风中，他的手机终于耐不住寒冷，头也不回地关了机。</p><p>小明很忧伤，他意识到，自己要换手机了。</p><p>为了能获得更好的使用体验，小明一咬牙，剁手了一台 iphoneX，这部手机铃声很大，电量很足，还能双卡双待，小明很喜欢，但是他遇到一个问题，就是他之前过度依赖了原来那一部 iPhone6，他们之间已经深深耦合在一起了，如果要换手机，他就要拿起刀来改造自己，把自己体内所有方法中的 iphone6 都换成 iphoneX。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A51.jpg" alt="漫长的改造过程"></p><p>经历了漫长的改造过程，小明终于把代码中的 iphone6 全部换成了 iphoneX。虽然很辛苦，但是小明觉得他是快乐的。</p><p>于是小明开开心心地带着手机去上班了，并在回来的路上被小偷偷走了。为了应急，小明只好重新使用那部刚刚被遗弃的 iphone6，但是一想到那漫长的改造过程，小明的心里就说不出的委屈，他觉得自己过于<strong>依赖</strong>手机了，为什么每次手机出什么问题他都要去改造他自己，这不仅仅是<strong>过度耦合</strong>，简直是<strong>本末倒置</strong>，他向天空大喊，我不要再<strong>控制</strong>我的手机了。</p><p>天空中的造物主，也就是作为程序员的我，听到了他的呐喊，我告诉他，你不用再控制你的手机了，交给我来管理，把控制权交给我。这就叫做<strong>控制反转</strong>。</p><h3 id="三、造物主的智慧"><a href="#三、造物主的智慧" class="headerlink" title="三、造物主的智慧"></a>三、造物主的智慧</h3><p>小明听到了我的话，他既高兴，又有一点害怕，他跪下来磕了几个头，虔诚地说到：“原来您就是传说中的造物主，巴格梅克上神。我听到您刚刚说了 <strong>控制反转</strong> 四个字，就是把手机的控制权从我的手里交给你，但这只是您的想法，是一种思想罢了，要用什么办法才能实现控制反转，又可以让我继续使用手机呢？”</p><p>“呵”，身为造物主的我在表现完不屑以后，扔下了四个大字，“依赖注入！”</p><p>接下来，伟大的我开始对小明进行惨无人道的改造，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ming</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    private $_name;</span><br><span class="line"></span><br><span class="line">    private $_age;</span><br><span class="line"></span><br><span class="line">    private $_phone; <span class="comment">//将手机作为自己的成员变量</span></span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="keyword">function</span>  <span class="title">__construct</span>(<span class="params">$phone</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;_name = <span class="string">'小明'</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;_age = <span class="number">26</span>;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;_phone = $phone;</span><br><span class="line">        echo <span class="string">"小明起床了 \n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        $<span class="keyword">this</span>-&gt;_phone-&gt;read($<span class="keyword">this</span>-&gt;_name); <span class="comment">//逛知乎</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">play</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        $<span class="keyword">this</span>-&gt;_phone-&gt;play($<span class="keyword">this</span>-&gt;_name);<span class="comment">//玩农药</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span>  <span class="title">grab</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//……  省略若干代码</span></span><br><span class="line">        $<span class="keyword">this</span>-&gt;_phone-&gt;grab($<span class="keyword">this</span>-&gt;_name);<span class="comment">//抢红包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来模拟运行小明的一天</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$phone = <span class="keyword">new</span> IphoneX(); <span class="comment">//创建一个iphoneX的实例</span></span><br><span class="line"><span class="keyword">if</span>($phone-&gt;isBroken())&#123;<span class="comment">//如果iphone不可用，则使用旧版手机</span></span><br><span class="line">    $phone = <span class="keyword">new</span> Iphone6();</span><br><span class="line">&#125;</span><br><span class="line">$ming = <span class="keyword">new</span> Ming($phone);<span class="comment">//小明不用关心是什么手机，他只要玩就行了。</span></span><br><span class="line">$ming-&gt;read();</span><br><span class="line">$ming-&gt;play();</span><br><span class="line">$ming-&gt;grab();</span><br></pre></td></tr></table></figure><p>我们先看一下 iphoneX 是否可以使用，如果不可以使用，则直接换成 iphone6，然后唤醒小明，并把手机塞到他的手里，换句话说，把他所依赖的手机直接注入到他的身上，他不需要关心自己拿的是什么手机，他只要直接使用就可以了。</p><p>这就是<strong>依赖注入</strong>。</p><h3 id="四、小明的感悟"><a href="#四、小明的感悟" class="headerlink" title="四、小明的感悟"></a>四、小明的感悟</h3><p>小明的生活开始变得简单了起来，而他把省出来的时间都用来写笔记了，他在笔记本上这样写到</p><blockquote><p>我曾经有很强的控制欲，过度依赖于我的手机，导致我和手机之间耦合程度太高，只要手机出现一点点问题，我都要改造我自己，这实在是既浪费时间又容易出问题。自从我把控制权交给了造物主，他每天在唤醒我以前，就已经替我选好了手机，我只要按照平时一样玩手机就可以了，根本不用关心是什么手机。即便手机出了问题，也可以由造物主直接搞定，不需要再改造我自己了，我现在买了七部手机，都交给了造物主，每天换一部，美滋滋！<br><strong>我也从其中获得了这样的感悟</strong>： 如果一个类 A 的功能实现需要借助于类 B，那么就称类 B 是类 A 的<strong>依赖</strong>，如果在类 A 的内部去实例化类 B，那么两者之间会出现较高的<strong>耦合</strong>，一旦类 B 出现了问题，类 A 也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。要解决这个问题，就要把 A 类对 B 类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作<strong>控制反转（IOC Inversion Of Control）</strong>。<strong>控制反转是一种思想</strong>，是能够解决问题的一种可能的结果，而<strong>依赖注入（Dependency Injection）</strong>就是其最典型的实现方法。由第三方（<strong>我们称作IOC容器</strong>）来控制依赖，把他通过构造函数、属性或者工厂模式等方法，注入到类 A 内，这样就极大程度的对类 A 和类 B 进行了解耦。</p></blockquote><p><strong>参考原文</strong>:<br><a href="https://zhuanlan.zhihu.com/p/33492169">浅谈控制反转与依赖注入</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;控制反转与依赖注入&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.beyondhxl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="https://www.beyondhxl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="控制反转与依赖注入" scheme="https://www.beyondhxl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="设计模式" scheme="https://www.beyondhxl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="控制反转" scheme="https://www.beyondhxl.com/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="依赖注入" scheme="https://www.beyondhxl.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二分查找</title>
    <link href="https://www.beyondhxl.com/post/43138433.html"/>
    <id>https://www.beyondhxl.com/post/43138433.html</id>
    <published>2020-07-30T23:11:47.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>二分查找</strong></p></blockquote><a id="more"></a><h3 id="零、二分查找实例-定位-IP-对应省份"><a href="#零、二分查找实例-定位-IP-对应省份" class="headerlink" title="零、二分查找实例-定位 IP 对应省份"></a>零、二分查找实例-定位 IP 对应省份</h3><p>通过 IP 地址来查找 IP 归属地功能，不知道你用过没？没用过也没关系，打开百度，在搜索框里随便输入一个 IP 地址，就会看到它的归属地。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE1.jpg" alt=""></p><p>这个功能并不复杂，它是通过维护一个很大的 IP 地址库来实现。地址库中包括 IP 地址范围和归属地的对应关系。</p><p>当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发到 IP 地址落在[202.102.133.0, 202.102.133.255] 这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[202.102.133.0,</span> <span class="number">202.102</span><span class="number">.133</span><span class="number">.255</span><span class="string">]</span>  <span class="string">山东东营市</span> </span><br><span class="line"><span class="string">[202.102.135.0,</span> <span class="number">202.102</span><span class="number">.136</span><span class="number">.255</span><span class="string">]</span>  <span class="string">山东烟台</span> </span><br><span class="line"><span class="string">[202.102.156.34,</span> <span class="number">202.102</span><span class="number">.157</span><span class="number">.255</span><span class="string">]</span> <span class="string">山东青岛</span> </span><br><span class="line"><span class="string">[202.102.48.0,</span> <span class="number">202.102</span><span class="number">.48</span><span class="number">.255</span><span class="string">]</span> <span class="string">江苏宿迁</span> </span><br><span class="line"><span class="string">[202.102.49.15,</span> <span class="number">202.102</span><span class="number">.51</span><span class="number">.251</span><span class="string">]</span> <span class="string">江苏泰州</span> </span><br><span class="line"><span class="string">[202.102.56.0,</span> <span class="number">202.102</span><span class="number">.56</span><span class="number">.255</span><span class="string">]</span> <span class="string">江苏连云港</span></span><br></pre></td></tr></table></figure><p>现在我的问题是，在庞大地址库中逐一比对 IP 地址所在的区间，是非常耗时的。假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速出一个 IP 地址的归属地呢？</p><p>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第 3 卷《排序和查找》中说到：“尽管第一个二分查找算法于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。”</p><p>二分查找的变形问题很多。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.jpg" alt=""></p><h3 id="一、查找第一个值等于给定值的元素"><a href="#一、查找第一个值等于给定值的元素" class="headerlink" title="一、查找第一个值等于给定值的元素"></a>一、查找第一个值等于给定值的元素</h3><p>如果有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据。</p><p>比如下面这样一个有序数组，其中 a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE2.jpg" alt=""></p><p><strong>1、写法一</strong></p><p>100 个人写二分查找就会有 100 种写法。网上有很多关于变形二分查找的实现方法，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (low &lt; n &amp;&amp; a[low]==value) <span class="keyword">return</span> low;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、方法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid] &gt; value 的情况，我们需要更新 high = mid-1；对于 a[mid] &lt; value 的情况，我们需要更新 low = mid+1。那当 a[mid] = value 的时候应该如何处理呢？</p><p>如果我们查找的是任意一个值等于给定值的元素，当 a[mid] 等于要查找的值时，a[mid] 就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 a[mid] 等于要查找的值时，我们就需要确认一下这个 a[mid] 是不是第一个值等于给定值的元素。</p><p>我们重点看第 11 行代码。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high = mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。</p><p>对比上面的两段代码，是不是下面那种更好理解？实际上，很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法。而对于我们做工程开发的人来说，代码易读懂、没 Bug，其实更重要，所以我觉得第二种写法更好。</p><p><strong>3、方法三</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找第一个等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[low] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[mid - <span class="number">1</span>] != value) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">high = mid -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、查找最后一个等于给定值的元素"><a href="#二、查找最后一个等于给定值的元素" class="headerlink" title="二、查找最后一个等于给定值的元素"></a>二、查找最后一个等于给定值的元素</h3><p><strong>1、方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是重点看第 11 行代码。如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 就是我们要找的最后一个值等于给定值的元素。</p><p>如果我们经过检查之后，发现 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。我们就更新 low = mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间。</p><p><strong>2、方法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找最后一个等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[high] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[mid + <span class="number">1</span>] != value) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、查找第一个大于等于给定值的元素"><a href="#三、查找第一个大于等于给定值的元素" class="headerlink" title="三、查找第一个大于等于给定值的元素"></a>三、查找第一个大于等于给定值的元素</h3><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><p><strong>1、方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a[mid] 小于要查找的值 value，那要查找的值肯定在 [mid+1, high] 之间，所以，我们更新 low = mid+1。</p><p>对于 a[mid] 大于等于给定值 value 的情况，我们要先看下这个 a[mid] 是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是我们要找的元素。这段逻辑对应的代码是第 7 行。</p><p>如果 a[mid-1] 也大于等于要查找的值 value，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。</p><p><strong>2、方法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个大于等于</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greaterOrEqualFirst</span><span class="params">(<span class="keyword">int</span>[]a, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = n -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断首尾元素与value的大小关系</span></span><br><span class="line"><span class="keyword">if</span>(value &lt;= a[low]) &#123;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &gt; a[high]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进入循环之后，保证 a[low] &lt; value &lt;= a[high]</span></span><br><span class="line"><span class="keyword">while</span>(low + <span class="number">1</span> != high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= value) &#123;</span><br><span class="line">high = mid + <span class="number">1</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、查找最后一个小于等于给定值的元素"><a href="#四、查找最后一个小于等于给定值的元素" class="headerlink" title="四、查找最后一个小于等于给定值的元素"></a>四、查找最后一个小于等于给定值的元素</h3><p>现在，我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。是不是有点类似上面那一种？实际上，实现思路也是一样的。</p><p><strong>1、方法一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、方法二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后一个小于等于</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lessOrEqualLast</span><span class="params">(<span class="keyword">int</span>[]a, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = n -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(value &lt; a[low]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value &gt;= a[high]) &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(low + <span class="number">1</span> != high) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &lt;= value) &#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">high = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、IP-问题解答"><a href="#五、IP-问题解答" class="headerlink" title="五、IP 问题解答"></a>五、IP 问题解答</h3><p>如何快速定位出一个 IP 地址的归属地？</p><p>现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p><p>然后，这个问题就可以转化为第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。</p><p>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p><h3 id="六、内容小结"><a href="#六、内容小结" class="headerlink" title="六、内容小结"></a>六、内容小结</h3><p>凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p><p>实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。用其他数据结构，比如散列表、二叉树，就比较难实现了。</p><p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。</p><p><strong>参考原文</strong>:<br><a href="https://time.geekbang.org/column/article/42733">二分查找（下）：如何快速定位IP对应的省份地址？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.beyondhxl.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.beyondhxl.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="二分查找" scheme="https://www.beyondhxl.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数据结构" scheme="https://www.beyondhxl.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.beyondhxl.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>行为树（Behavior-Tree）知识点</title>
    <link href="https://www.beyondhxl.com/post/ef1e8494.html"/>
    <id>https://www.beyondhxl.com/post/ef1e8494.html</id>
    <published>2020-07-30T16:39:01.000Z</published>
    <updated>2024-08-02T20:36:09.808Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>行为树（Behavior-Tree）</strong></p></blockquote><a id="more"></a><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/bv-tree-1.png" alt=""></p><p>这是我们为一个士兵定义的一颗行为树（可以先不管这些绿圈和红圈是做什么的），首先，可以看到这是一个树形结构的图，有根节点，有分支，而且子节点个数可以任意，然后有三个分支，分别是巡逻（Patrol），攻击（Attack），逃跑（Retreat），这个三个分支可以看成是我们为这个士兵定义的三个大的行为（Behavior），当然，如果有更多的行为，我们可以继续在根节点中添加新的分支。当我们要决策当前这个士兵要做什么样的行为的时候，<strong>我们就会自顶向下的，通过一些条件来搜索这颗树，最终确定需要做的行为（叶节点），并且执行它</strong>，这就是行为树的基本原理。</p><p>值得注意的是，我们标识的三大行为其实并不是真正的决策的结果，它只是一个类型，来帮助我们了解这个分支的一些行为是属于这类的，真正的行为树的行为都是在叶节点上，一般称之为行为节点（Action Node），如下图红圈表示的</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/behaviortree.png" alt=""></p><p>这些叶节点才是我们真正通过行为树决策出来的结果，如果用我以前提到的那个层次化的AI结构来描述的话，这些行为结果，相当于就是一个个定义好的“请求”（Request），比如移动（Move），无所事事（Idle），射击（Shoot）等等。所以行为树是一种决策树，来帮助我们搜寻到我们想要的某个行为。</p><p>行为节点是游戏相关的，因不同的游戏，我们需要定义不同的行为节点，但对于某个游戏来说，在行为树上行为节点是可以复用的，比如移动，在巡逻的分支上，需要用到，在逃跑分支上，也会用到，这种情况下，我们就可以复用这个节点。行为节点一般分为两种运行状态：</p><ol><li>运行中（Executing）：该行为还在处理中</li><li>完成（Completed）：该行为处理完成，成功或者失败</li></ol><p>除了行为节点，其余一般称之为控制节点（Control Node），用树的“学名”的话，就是那些父节点，如下图绿圈表示</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/bv-tree-control-node.png" alt=""></p><p>控制节点其实是行为树的精髓所在，我们要搜索一个行为，如何搜索？其实就是通过这些控制节点来定义的，从控制节点上，我们就可以看出整个行为树的逻辑走向，所以，行为树的特点之一就是其<strong>逻辑的可见性</strong>。</p><p>我们可以为行为树定义各种各样的控制节点（这也是行为树有意思的地方之一），一般来说，常用的控制节点有以下三种</p><ol><li>选择（Selector）：选择其子节点的某一个执行</li><li>序列（Sequence）：将其所有子节点依次执行，也就是说当前一个返回“完成”状态后，再运行先一个子节点</li><li>并行（Parallel）：将其所有子节点都运行一遍</li></ol><p>用图来表示的话，就是这样，依次为选择，序列和并行</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/selector.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/sequence.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/parallel.png" alt=""></p><p>可以看到，控制节点其实就是“控制”其子节点（子节点可以是叶节点，也可以是控制节点，所谓“执行控制节点”，就是执行其定义的控制逻辑）如何被执行，所以，我们可以扩展出很多其他的控制节点，比如循环（Loop）等，与行为节点不同的是，控制节点是与游戏无关的，因为他只负责行为树逻辑的控制，而不牵涉到任何的游戏代码。如果是作为一个行为树的库的话，其中就一定会包含定义好的控制节点库。</p><p>如果我们继续考察选择节点，会产生一个问题，如何从子节点中选择呢？选择的依据是什么呢？这里就要引入另一个概念，一般称之为前提（Precondition），每一个节点，不管是行为节点还是控制节点，都会包含一个前提的部分，如下图</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/prcondition.png" alt=""></p><p>前提就提供了“选择”的依据，它包含了进入，或者说选择这个节点的条件，当我们用到选择节点的时候，它就是去依次测试每一个子节点的前提，如果满足，则选择此节点。由于我们最终返回的是某个行为节点（叶节点），所以，当前行为的“总”前提就可以看成是：</p><blockquote><p>当前行为节点的前提 And 父节点的前提 And 父节点的父节点的前提 And….And 根节点的前提（一般是不设，直接返回 True）</p></blockquote><p>行为树就是通过行为节点，控制节点，以及每个节点上的前提，把整个 AI 的决策逻辑描述了出来，对于每次的 Tick，可以用如下的流程来描述：</p><blockquote><p>action = root.FindNextAction(input);<br>if action is not empty then<br>action.Execute(request, input)      // request是输出的请求<br>else<br>print “no action is available”</p></blockquote><p>从概念上来说，行为树还是比较简单的，但对 AI 程序员来说，却是充满了吸引力，它的一些特性，比如可视化的决策逻辑，可复用的控制节点，逻辑和实现的低耦合等，较之传统的状态机，都是可以大大帮助我们迅速而便捷的组织我们的行为决策。最后，对这个士兵的巡逻分支画了一个示意图，供大家参考：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/soldier.png" alt=""></p><h2 id="二、节点"><a href="#二、节点" class="headerlink" title="二、节点"></a>二、节点</h2><h3 id="2-1、关于选择节点的讨论"><a href="#2-1、关于选择节点的讨论" class="headerlink" title="2.1、关于选择节点的讨论"></a>2.1、关于选择节点的讨论</h3><p>我们说过选择节点的定义是通过判断子节点的前提条件来选择一个节点执行，这就牵涉到判断顺序的问题，是自左向右，还是随机选择，或者其他的一些规则等等，这样就延伸出各种各样的选择节点。</p><p><strong>1、带优先级的选择节点（Priority Selector）</strong></p><p>这种选择节点每次都是自左向右依次选择，当发现找到一个可执行的子节点后就停止搜索后续子节点。这样的选择方式，就存在一个优先级的问题，也就是说最左边的节点优先级最高，因为它是被最先判断的。对于这种选择节点来说，它的子节点的前提设定，必须是“从窄到宽”的方式，否则后续节点都会发生“饿死”的情况，也就是说永远不会被执行到，为了更清楚的说明，看下面第一张图，这三个子节点在一个带优先级的选择节点下，它们的前提会被依次判断，可以看到这个三个子节点的前提从左向右，一个比一个更严格，如果我们现在 a 为 9，按照下图的定义会执行第一个子节点，如果 a 为 7，则会执行第二个子节点，如果 a=11，则会执行第三个子节点。下面的第二张图演示了一种节点“饿死”（Starvation）的情况，我们看到第一个子节点的前提，比第二个子节点更宽泛，只要 a&lt;10，那自左向右判断的话，永远会进第一个节点，所以，如果要用到带优先级的选择节点，则必须检查每一个子节点的前提，以防止节点饿死的情况。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/priorityselector.png" alt=""></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/priorityselector1.png" alt=""></p><p><strong>2、不带优先级的选择节点（Non-priority Selector）</strong></p><p>这种选择节点的选择顺序是从上一个执行过的子节点开始选择，如果前提满足，则继续执行此节点，如果条件不满足，则从此节点开始，依次判断每一个子节点的前提，当找到一个满足条件的子节点后，则执行该节点。这种方式，是基于一种称之为“持续性”的假设，因为在游戏中，一个行为一般不会在一帧里结束，而是会持续一段时间，所以有时为了优化的目的，我们可以优先判断上一个执行的节点，当其条件不满足时，再寻找下一个可执行的节点。这种寻找方式不存在哪个节点优先判断的问题，所以对于前提的设置的要求，就是要保证“互斥”（Exclusion）。用上面第一张图来说明，如果我们把控制节点换成不带优先级的选择节点，可以看到，当 a=3 时，第二个子节点会被执行，下一次当 a 变成 9 时，由于不是从头依次判断前提的，所以，我们还是会选择第二个节点，而不是我们可能期望的第一个节点。正确的做法见下图，注意每一个子节点的前提是“互斥的”。所以对于不带优先级的选择节点，它子节点的排列顺序就不是那么重要了，可以任意排列。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/bv-tree-nonpriority-selector-1.png" alt=""></p><p><strong>3、带权值的选择节点（Weighted Selector）</strong></p><p>对于这种选择节点，我们会预先为每一个分支标注一个“权值”（Weight Value），然后当我们选择的时候，采用随机选择的方式来选，随机时会参考权值，并且保证已经被测试过的节点不会再被测试，直到有一个节点的前提被满足，或者测试完所有的节点。带权值的选择节点对于子节点前提由于随机的存在，所以子节点的前提可以任意，而不会发生“饿死”的情况，一般来说，我们通常会把所有子节点的前提设为相同，以更好的表现出权值带来的概率上的效果。当所有子节点的权值一样时，这种选择节点就成为了随机选择节点（Random Selector），带权值的选择节点对于需要丰富 AI 行为的地方，非常适用，比如养成类游戏中，小狗表示开心的时候，可能会有各种各样的表现，我们就可以用这种选择节点，添加各种子节点行为来实现。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/bv-tree-weighted-selector-1.png" alt=""></p><p>这些就是常用的选择节点类型，我们可以根据需要，定义更多的选择节点的选择行为，其实我们可以看到，不同的选择行为对于子节点前提的要求会有略微的不同，这是在搭建行为树的时候需要注意的地方。</p><h3 id="2-2、关于并行节点结束条件的讨论"><a href="#2-2、关于并行节点结束条件的讨论" class="headerlink" title="2.2、关于并行节点结束条件的讨论"></a>2.2、关于并行节点结束条件的讨论</h3><p>我们每个节点都会有一个运行状态，来表示当前行为是否结束。对于控制节点来说，它的运行状态就是其子节点的运行状态，选择节点和序列节点比较好处理，因为对于这两种控制节点来说，每时刻，只会有一个子节点在运行，只要返回在运行的这个子节点的状态即可。但对于并行节点来说，它同时刻会有多个子节点运行，那我们如何来处理并行节点的运行状态问题呢？一般有两种：</p><ul><li>与：只有所有的子节点都运行结束，才返回结束。</li><li>或：只要有一个子节点运行结束，就返回结束。</li></ul><p>为什么要需要有节点的运行状态呢？</p><ul><li>序列控制节点中，需要用运行状态来控制序列的执行</li><li>外部世界需要了解行为的运行状态，来决定是否要更新决策（如果行为树在决策层）/ 请求（如果行为树在行为层）</li></ul><p>对于第二点，可以举个例子，比如我们有一个行为是“走到 A 点”，假设这个行为是不可被打断的，那当我们在走向 A 点的过程中，行为树的运行状态就是“正在执行”，当到达 A 点时，行为树就返回“已完成”，这样，对外部来说，当我们看到行为树是“正在执行”的时候，我们就不需要做任何新的行为（为了优化，或者为了行为抖动等等），当看到“已完成”的时候，我们就可以做新的决策或者行为了。这样一个运行状态还有助于我们检测行为树的状态，帮助调试。</p><h3 id="2-3、关于具体实现的讨论"><a href="#2-3、关于具体实现的讨论" class="headerlink" title="2.3、关于具体实现的讨论"></a>2.3、关于具体实现的讨论</h3><p>行为树的实现可以有多种多样，一般来说，行为树每个节点需要有进入（Enter），离开（Exit），运行（Execute）等部分，需要有行为节点（ActionNode），控制节点（ControlNode），前提（Precondition）等基类，然后，还需要定义行为树的输入（InputParam）和输出（OutputParam），一般来说，我们希望行为树是一个黑盒，也就是说，它仅依赖于预定义的输入。输入可以是黑板（Blackboard），工作池（Working Memory）等等数据结构，输出可以是请求（Request），或者其他自定义的数据结构，如下图:</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/behaviortree2.png" alt=""></p><h3 id="2-4、关于绘制和调试的讨论"><a href="#2-4、关于绘制和调试的讨论" class="headerlink" title="2.4、关于绘制和调试的讨论"></a>2.4、关于绘制和调试的讨论</h3><p>看到行为树的定义后，作为程序员的直觉，我们很自然的就会想到，这好像应该能做一个工具来辅助行为树的创建和调试，我们可以把预定义好的前提和节点，在一个可视化的编辑器里搭建成行为树，然后再导出成数据给游戏用。对于调试来说，我们可以让工具和游戏通信，然后实时的检测行为树的运行状况，比如当前在哪个分支中等等。由于行为树的逻辑是可见的，并且是静态的，所以我们看其选择的路径，我们就可以知道 AI 为什么会作出这样的决策了。</p><p><strong>参考原文</strong>:<br><a href="http://www.aisharing.com/archives/90">行为树（Behavior Tree）实践（1）– 基本概念</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;行为树（Behavior-Tree）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="AI" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/AI/"/>
    
      <category term="行为树" scheme="https://www.beyondhxl.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/AI/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
    
      <category term="游戏开发" scheme="https://www.beyondhxl.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="AI" scheme="https://www.beyondhxl.com/tags/AI/"/>
    
      <category term="行为树" scheme="https://www.beyondhxl.com/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++STL知识点简析</title>
    <link href="https://www.beyondhxl.com/post/2835216b.html"/>
    <id>https://www.beyondhxl.com/post/2835216b.html</id>
    <published>2020-07-28T11:21:56.000Z</published>
    <updated>2024-08-02T20:36:09.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>STL</strong></p></blockquote><a id="more"></a><h2 id="一、STL-简介"><a href="#一、STL-简介" class="headerlink" title="一、STL 简介"></a>一、STL 简介</h2><p>Standard Template Library，标准模板库，是 C++ 的标准库之一，一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。<strong>STL 包含 6 大部件：容器、迭代器、算法、仿函数、适配器和空间配置器</strong>。</p><ul><li><p>容器：容纳一组元素的对象。</p></li><li><p>迭代器：提供一种访问容器中每个元素的方法。</p></li><li><p>函数对象：一个行为类似函数的对象，调用它就像调用函数一样。</p></li><li><p>算法：包括查找算法、排序算法等等。</p></li><li><p>适配器：用来修饰容器等，比如 queue 和 stack，底层借助了 deque。</p></li><li><p>空间配置器：负责空间配置和管理。</p></li></ul><h2 id="二、STL-空间配置器"><a href="#二、STL-空间配置器" class="headerlink" title="二、STL 空间配置器"></a>二、STL 空间配置器</h2><p>对象构造前的空间配置和对象析构后的空间释放，由 &lt;stl_alloc.h&gt; 负责，SGI 对此的设计哲学如下：</p><ul><li><p>向 system heap 申请空间。</p></li><li><p>考虑多线程状态。</p></li><li><p>考虑内存不足时的应变措施。</p></li><li><p>考虑过多“小型区块”可能造成的内存碎片问题。</p></li></ul><p>考虑小型区块造成的内存破碎问题，SGI 设计了双层级配置器：</p><ul><li><p>第一级直接使用 <font color=#0099ff size=3 face="黑体">allocate() 调用 malloc()、deallocate() 调用 free()</font>，使用类似new_handler 机制解决内存不足（<strong>抛出异常</strong>），配置无法满足的问题（如果在申请动态内存时找不到足够大的内存块，malloc 和 new 将返回 NULL 指针，宣告内存申请失败）。</p></li><li><p>第二级视情况使用不同的策略，<strong>当配置区块大于 128 bytes 时，调用第一级配置器，当配置区块小于 128 bytes 时，采用内存池的方式：配置器维护 16 个（128/8）自由链表，负责 16 种小型区块的配置能力</strong>。内存池以 malloc 配置而得，如果内存不足转第一级配置器处理。</p></li></ul><p><strong>1、第二级空间配置器详解</strong></p><p>第二级空间配置器实际上是一个内存池，维护了 16 个自由链表。<strong>自由链表是一个指针数组，有点类似 hash 桶，它的数组大小为 16，每个数组元素代表所挂的区块大小</strong>，比如 free_list[0] 代表下面挂的是 8 bytes 的区块，free_list[1] 代表下面挂的是 16 bytes 的区块。依次类推，直到 free_list[15] 代表下面挂的是 128 bytes 的区块。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/STL/%E5%86%85%E5%AD%98%E6%B1%A0.jpg" alt=""></p><p><strong>2、空间配置器存在的问题</strong></p><ul><li><p>自由链表所挂区块都是 8 的整数倍，因此当我们需要非 8 倍数的区块，往往会导致浪费。</p></li><li><p>由于配置器的所有方法，成员都是静态的，都存放在静态区。释放时机就是程序结束，这样会导致自由链表一直占用内存，自己进程可以用，其他进程却用不了。</p></li></ul><h2 id="三、STL-各种容器"><a href="#三、STL-各种容器" class="headerlink" title="三、STL 各种容器"></a>三、STL 各种容器</h2><ol><li>vector<br>可变大小的数组。支持快速随机访问，在尾部之外的位置插入和删除元素可能会很慢。</li><li>deque<br>双端队列。支持快速随机访问，在头尾位置插入/删除速度很快。</li><li>list<br>只支持双向顺序访问。在 list 任何位置插入/删除速度很快。</li><li>forward_list<br>单向链表。只支持单向顺序访问。在 forward_list 任何位置插入/删除速度很快。</li><li>array<br>固定大小的数组。支持快速随机访问，不能添加或者删除元素。</li><li>string<br>与 vector 相似的容器，专门存储字符。随机访问快。在尾位置插入/删除速度很快。</li></ol><p>支持随机访问的容器：vector、deque、array、string。</p><p>支持在任意位置插入/删除元素：list、forward_list。</p><p>在尾部插入元素：vector、string、deque（头部也可以）。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>1、vector 的底层原理</strong></p><p>vector 底层是一个<strong>动态数组</strong>，包含三个迭代器，start 和 finish 之间是已经被使用的空间范围，end_of_storage 是整块连续空间包括备用空间的尾部。</p><p>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5 倍或者 2 倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间（vector 内存增长机制）。</p><p>当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。</p><p>因此，对 vector 的任何操作一旦引起了空间的重新配置，指向原 vector 的所有迭代器会都失效了。</p><p><strong>2、vector 中的 reserve() 和 resize() 的区别</strong></p><ul><li>resize(n)<br>调整容器的长度大小，使其能容纳 n 个元素。如果 n 小于容器的当前的 size，则删除多出来的元素。否则，添加采用值初始化的元素。</li><li>resize(n，t)<br>多一个参数 t，将所有新添加的元素初始化为 t。</li><li>reserve(n)<br>预分配 n 个元素的存储空间。</li></ul><p>reserve() 是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化 push_back()），其次还可以减少多次要拷贝数据的问题。reserve() 只是保证 vector 中的空间大小（capacity）最少达到参数所指定的大小 n。reserve() 只有一个参数。</p><p>resize() 可以改变有效空间的大小，也有改变默认值的功能。capacity 的大小也会随着改变。resize() 可以有多个参数。</p><p><strong>3、容器的 capacity（容量）与 size（长度）的区别</strong></p><p>size 指容器当前拥有的元素个数，而 capacity 则指容器在必须分配新存储空间之前可以存储的元素总数，也可以说是预分配存储空间的大小。</p><p>resize() 函数和容器的 size 息息相关。调用 resize(n) 后，容器的 size 即为 n。至于是否影响 capacity，取决于调整后的容器的 size 是否大于 capacity。</p><p>reserve() 函数和容器的 capacity 息息相关。调用 reserve(n) 后，若容器的 capacity &lt; n，则重新分配内存空间，从而使得 capacity 等于n。如果 capacity &gt;=n 呢？capacity 无变化。</p><p>从两个函数的用途可以发现，容器调用 resize() 函数后，所有的空间都已经初始化了，所以可以直接访问。而 reserve() 函数预分配出的空间没有被初始化，所以不可访问。</p><p><strong>4、迭代器失效的情况</strong></p><p>当插入一个元素到 vector 中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。</p><p>当删除容器中一个元素后，该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase 方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要 it = vec.erase(it);。</p><p><strong>5、vector 的元素类型可以是引用吗？</strong></p><p>vector 的底层实现要求<strong>连续的对象排列，引用并非对象，没有实际地址，因此 vector 的元素类型不能是引用</strong>。</p><p><strong>6、正确释放 vector 的内存（clear()、swap()、shrink_to_fit()）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec.clear();              <span class="comment">// 清空内容，但是不释放内存。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(vec);  <span class="comment">// 清空内容，且释放内存，得到一个全新的 vector。</span></span><br><span class="line">vec.shrink_to_fit();      <span class="comment">// 请求容器降低其 capacity 和 size 匹配。</span></span><br><span class="line">vec.clear(); vec.shrink_to_fit();  <span class="comment">// 清空内容，且释放内存。</span></span><br></pre></td></tr></table></figure><p><strong>std::vector::clear()</strong></p><p>Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after clear size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after clear capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">size:<span class="number">5</span></span><br><span class="line">capacity:<span class="number">6</span></span><br><span class="line">after clear size:<span class="number">0</span></span><br><span class="line">after clear capacity:<span class="number">6</span></span><br></pre></td></tr></table></figure><p>A reallocation is not guaranteed to happen, and the <strong>vector capacity is not guaranteed</strong> to change due to calling this function. A typical alternative that forces a reallocation is to use swap.</p><p><strong>std::vector::swap</strong></p><p>Exchanges the content of the container by the content of x, which is another vector object of the same type. Sizes may differ.</p><p>After the call to this member function, the elements in this container are those which were in x before the call, and the elements of x are those which were in this. All iterators, references and pointers remain valid for the swapped objects.</p><p>Notice that a non-member function exists with the same name, swap, overloading that algorithm with an optimization that behaves like this member function.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">    foo.push_back(<span class="number">1</span>);</span><br><span class="line">    foo.push_back(<span class="number">2</span>);</span><br><span class="line">    foo.push_back(<span class="number">3</span>);</span><br><span class="line">    foo.push_back(<span class="number">4</span>);</span><br><span class="line">    foo.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;  </span><br><span class="line">    bar.push_back(<span class="number">1</span>);</span><br><span class="line">    bar.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo size:"</span> &lt;&lt; foo.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo capacity:"</span> &lt;&lt; foo.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar size:"</span> &lt;&lt; bar.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar capacity:"</span> &lt;&lt; bar.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    foo.swap(bar);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap foo size:"</span> &lt;&lt; foo.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap foo capacity:"</span> &lt;&lt; foo.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap bar size:"</span> &lt;&lt; bar.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap bar capacity:"</span> &lt;&lt; bar.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">foo size:<span class="number">5</span></span><br><span class="line">foo capacity:<span class="number">6</span></span><br><span class="line">bar size:<span class="number">2</span></span><br><span class="line">bar capacity:<span class="number">2</span></span><br><span class="line">after swap foo size:<span class="number">2</span></span><br><span class="line">after swap foo capacity:<span class="number">2</span></span><br><span class="line">after swap bar size:<span class="number">5</span></span><br><span class="line">after swap bar capacity:<span class="number">6</span></span><br></pre></td></tr></table></figure><p>swap 之后，不仅仅是 size 变化了，capacity 也是变化了。<strong>用 swap 实现真正的 clear</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">size:<span class="number">5</span></span><br><span class="line">capacity:<span class="number">6</span></span><br><span class="line">after swap size:<span class="number">0</span></span><br><span class="line">after swap capacity:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>C++11 推出了 shrink_to_fit 方法，也可以达到正确释放 vector 的内存的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);</span><br><span class="line">    v.push_back(<span class="number">4</span>);</span><br><span class="line">    v.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.clear();</span><br><span class="line">    v.shrink_to_fit();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap capacity:"</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">size:<span class="number">5</span></span><br><span class="line">capacity:<span class="number">6</span></span><br><span class="line">after swap size:<span class="number">0</span></span><br><span class="line">after swap capacity:<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>7、vector 扩容为什么要以 1.5 倍或者 2 倍扩容？</strong></p><p>根据查阅的资料显示，考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以 2 倍的方式扩容，或者以 1.5 倍的方式扩容。</p><p>以 2 倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为（1-2）之间：</p><p>$$k\sum_{i=0}^{n}2^i = k(2^{n+1} - 1) &lt; k2^{n+1} $$</p><p><strong>8、vector 的常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;           <span class="comment">// 创建10个元素,每个元素值为100</span></span><br><span class="line">vec.resize(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c, <span class="number">0</span>));   <span class="comment">// 二维数组初始化</span></span><br><span class="line">reverse(vec.begin(), vec.end())     <span class="comment">// 将元素翻转</span></span><br><span class="line">sort(vec.begin(), vec.end());       <span class="comment">// 排序，默认升序排列</span></span><br><span class="line">vec.push_back(val);                 <span class="comment">// 尾部插入数字</span></span><br><span class="line">vec.size();                         <span class="comment">// 向量大小</span></span><br><span class="line">find(vec.begin(), vec.end(), <span class="number">1</span>);    <span class="comment">// 查找元素</span></span><br><span class="line">iterator = vec.erase(iterator)      <span class="comment">// 删除元素</span></span><br></pre></td></tr></table></figure><p><strong>9、vector 实例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.reserve(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a的容量:"</span>&lt;&lt; a.capacity() &lt;&lt; <span class="string">" ;a的大小:"</span>&lt;&lt; a.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 10; i++ )&#123;</span></span><br><span class="line"><span class="comment">     a.push_back(i); //新元素这时才构造</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">b.resize(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b的容量:"</span>&lt;&lt; b.capacity() &lt;&lt; <span class="string">" ;b的大小:"</span> &lt;&lt; b.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b[7]="</span> &lt;&lt;b[<span class="number">7</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b1;</span><br><span class="line">b1.resize(<span class="number">10</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b1的容量:"</span>&lt;&lt; b1.capacity() &lt;&lt; <span class="string">" ;b1的大小:"</span> &lt;&lt; b1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b1[7]="</span> &lt;&lt;b1[<span class="number">7</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c的容量:"</span>&lt;&lt; c.capacity() &lt;&lt; <span class="string">" ;c的大小:"</span> &lt;&lt; c.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"d的容量:"</span>&lt;&lt; d.capacity() &lt;&lt; <span class="string">" ;d的大小:"</span> &lt;&lt; d.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"d[7]="</span>&lt;&lt; d[<span class="number">7</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"d1的容量:"</span>&lt;&lt; d1.capacity() &lt;&lt; <span class="string">" ;d1的大小:"</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"d1[7]="</span>&lt;&lt; d1[<span class="number">7</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a的容量:10 ;a的大小:0</span><br><span class="line">b的容量:10 ;b的大小:10</span><br><span class="line">b[7]=0</span><br><span class="line">b1的容量:10 ;b1的大小:10</span><br><span class="line">b1[7]=7</span><br><span class="line">c的容量:0 ;c的大小:0</span><br><span class="line">d的容量:10 ;d的大小:10</span><br><span class="line">d[7]=0</span><br><span class="line">d1的容量:10 ;d1的大小:10</span><br><span class="line">d1[7]=7</span><br></pre></td></tr></table></figure><p><strong>10、vector 中 push_back 的时间复杂度分析</strong></p><p>vector 是 STL 中的一种序列式容器，采用的数据结构为线性连续空间，它以两个迭代器 start 和 finish 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 end_of_storage 指向整块连续空间（含备用空间）的尾端，结构如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">       iterator start;             <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">       iterator finish;            <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">       iterator end_of_storage;    <span class="comment">// 表示可用空间的尾</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间，重新配置、移动数据，释放原空间。​</p><p>其中​判断是否有备用空间，就是判断 finish 是否与 end_of_storage 相等。如果 finish != end_of_storage，说明还有备用空间，否则已无备用空间。</p><p>当执行 push_back 操作，该 vector 需要分配更多空间时，它的容量（capacity）会增大到原来的 m 倍。​现在我们用<strong>均摊分析方法</strong>来计算 push_back 操作的时间复杂度。</p><p>假定有 n 个元素，倍增因子为 m。那么完成这 n 个元素往一个 vector 中的 push_back ​操作，需要重新分配内存的次数大约为 log<sub>m</sub>(n)，第 i 次重新分配将会导致复制 m^i （也就是当前的 vector.size() 大小）个旧空间中元素，因此 n 次 push_back 操作所花费的总时间约为 n*m/(m - 1)。</p><p>很明显这是一个等比数列。那么 n 个元素，n 次操作，每一次操作需要花费时间为 m / (m - 1)，这是一个常量。</p><p>所以，我们采用均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间。</p><p>在 STL 中，vector 的每次扩容都是 2 倍，也就是 m=2。这样，n 次总的时间约为 n*2/(2-1) = 2n；那么每一操作要花的时间就是 2，因此是常量级。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>1、list 的底层是一个<strong>双向链表</strong>，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。</p><p>2、list 不支持随机存取，如果需要大量的插入和删除，而不关心随机存取，建议使用 list。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/STL/list/list.jpg" alt=""></p><p><strong>1、list 常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.push_back(elem);<span class="comment">// 在尾部加入一个数据</span></span><br><span class="line"><span class="built_in">list</span>.pop_back();        <span class="comment">// 删除尾部数据</span></span><br><span class="line"><span class="built_in">list</span>.push_front(elem);<span class="comment">// 在头部插入一个数据</span></span><br><span class="line"><span class="built_in">list</span>.pop_front();       <span class="comment">// 删除头部数据</span></span><br><span class="line"><span class="built_in">list</span>.size();        <span class="comment">// 返回容器中实际数据的个数</span></span><br><span class="line"><span class="built_in">list</span>.sort();            <span class="comment">// 排序，默认由小到大 </span></span><br><span class="line"><span class="built_in">list</span>.unique();          <span class="comment">// 移除数值相同的连续元素</span></span><br><span class="line"><span class="built_in">list</span>.back();            <span class="comment">// 取尾部迭代器</span></span><br><span class="line"><span class="built_in">list</span>.erase(iterator);   <span class="comment">// 删除一个元素，参数是迭代器，返回的是删除迭代器的下一个位置</span></span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><strong>1、deque 的底层原理</strong></p><p>deque 是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p><p><strong>2、什么情况下用 vector，什么情况下用 list，什么情况下用 deque？</strong></p><p>vector 可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），<strong>但在非尾部插入删除数据时，效率很低</strong>，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用 vector 而非 deque，因为 deque 的迭代器比 vector 迭代器复杂很多。</p><p>list 不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。</p><p>需要从首尾两端进行插入或删除操作的时候需要选择 deque。</p><p><strong>3、deque 常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.push_back(elem);<span class="comment">// 在尾部加入一个数据。</span></span><br><span class="line"><span class="built_in">deque</span>.pop_back();       <span class="comment">// 删除尾部数据。</span></span><br><span class="line"><span class="built_in">deque</span>.push_front(elem);<span class="comment">// 在头部插入一个数据。</span></span><br><span class="line"><span class="built_in">deque</span>.pop_front();      <span class="comment">// 删除头部数据。</span></span><br><span class="line"><span class="built_in">deque</span>.size();        <span class="comment">// 返回容器中实际数据的个数。</span></span><br><span class="line"><span class="built_in">deque</span>.at(idx);        <span class="comment">// 传回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br></pre></td></tr></table></figure><h3 id="priority-queue-优先级队列"><a href="#priority-queue-优先级队列" class="headerlink" title="priority_queue 优先级队列"></a>priority_queue 优先级队列</h3><p><strong>1、priority_queue 的底层原理</strong></p><p>其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。</p><p><strong>2、priority_queue 的常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;   <span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; pq;      <span class="comment">// 最大堆</span></span><br><span class="line">pq.empty();   <span class="comment">// 如果队列为空返回真</span></span><br><span class="line">pq.pop();     <span class="comment">// 删除对顶元素</span></span><br><span class="line">pq.push(val); <span class="comment">// 加入一个元素</span></span><br><span class="line">pq.size();    <span class="comment">// 返回优先队列中拥有的元素个数</span></span><br><span class="line">pq.top();     <span class="comment">// 返回优先级最高的元素</span></span><br></pre></td></tr></table></figure><h3 id="map、set、multiset、multimap"><a href="#map、set、multiset、multimap" class="headerlink" title="map、set、multiset、multimap"></a>map、set、multiset、multimap</h3><p><strong>1、map 、set、multiset、multimap 的底层原理</strong></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/20200719222720.png" alt=""></p><p>map、set、multiset、multimap 的底层实现都是<a href="https://beyondhxl.com/post/b1830f1a.html">红黑树</a>。</p><p>对于 STL 里的 map 容器，count 方法与 find 方法，都可以用来判断一个 key 是否出现，<code>mp.count(key) &gt; 0</code> 统计的是 key 出现的次数，因此只能为 0/1，而 <code>mp.find(key) != mp.end()</code> 则表示 key 存在。</p><p><strong>2、map 、set、multiset、multimap 的特点</strong></p><p>set 和 multiset 会根据特定的排序准则自动将元素排序，set 中元素不允许重复，multiset 可以重复。</p><p>map 和multimap 将 key 和 value 组成的 pair 作为元素，根据 key 的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以 map 默认是按 key 排序的），map 中元素的 key 不允许重复，multimap 可以重复。</p><p>map 和 set 的增删改查速度为都是 O(logn)，是比较高效的。</p><p><strong>3、为何 map 和 set 的插入删除效率比其他序列容器高，而且每次 insert 之后，以前保存的 iterator 不会失效？</strong></p><p>因为存储的是结点，不需要内存拷贝和内存移动。</p><p>因为插入操作只是结点指针交换，结点内存没有改变。而 iterator 就像指向结点的指针，内存没变，指向内存的指针也不会变。</p><p><strong>4、为何 map 和 set 不能像 vector 一样有个 reserve 函数来预分配数据？</strong></p><p>因为在 map 和 set 内部存储的已经不是元素本身了，而是包含元素的结点。也就是说 map 内部使用的 Alloc 并不是 <code>map&lt;Key, Data, Compare, Alloc&gt;</code> 声明的时候从参数中传入的 Alloc。</p><p><strong>5、map、set、multiset、multimap 的常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it <span class="built_in">map</span>.begin(); 　        <span class="comment">// 返回指向容器起始位置的迭代器（iterator） </span></span><br><span class="line">it <span class="built_in">map</span>.end();             <span class="comment">// 返回指向容器末尾位置的迭代器 </span></span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>.empty();         <span class="comment">// 若容器为空，则返回true，否则false</span></span><br><span class="line">it <span class="built_in">map</span>.find(k);           <span class="comment">// 寻找键值为k的元素，并用返回其地址</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>.size();           <span class="comment">// 返回map中已存在元素的数量</span></span><br><span class="line"><span class="built_in">map</span>.insert(&#123;<span class="keyword">int</span>,<span class="built_in">string</span>&#125;); <span class="comment">// 插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历删除</span></span><br><span class="line"><span class="keyword">for</span> (it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"target"</span>)</span><br><span class="line">        <span class="built_in">map</span>.erase(it++) ; <span class="comment">// erase之后，令当前迭代器指向其后继。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-map、unordered-set"><a href="#unordered-map、unordered-set" class="headerlink" title="unordered_map、unordered_set"></a>unordered_map、unordered_set</h3><p><strong>1、unordered_map、unordered_set 的底层原理</strong></p><p>unordered_map 的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为 O(1)；而代价仅仅是消耗比较多的内存。</p><p>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（<strong>哈希函数（一般使用除留取余法），也叫做散列函数</strong>），使得每个元素的 key 都与一个函数值（即数组下标，hash 值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，<code>按照 key 为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶</code>。</p><p>但是，<strong>不能够保证每个元素的 key 与函数值是一一对应的</strong>，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。一般可采用拉链法解决冲突：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://blogimage-1300452281.cos.ap-shanghai.myqcloud.com/C%2B%2B/STL/bucket.jpg" alt=""></p><p><strong>2、哈希表的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> hashsize = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定一个节点的结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T _key;<span class="comment">//键</span></span><br><span class="line">    U _value;<span class="comment">//值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用拉链法实现哈希表类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HashTable() : vec(hashsize) &#123;&#125;<span class="comment">//类中的容器需要通过构造函数来指定大小</span></span><br><span class="line">    ~HashTable() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert_data</span><span class="params">(<span class="keyword">const</span> T &amp;key, <span class="keyword">const</span> U &amp;value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> T &amp;key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hash_find</span><span class="params">(<span class="keyword">const</span> T &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;HashNode&lt;T, U&gt;&gt;&gt; vec;<span class="comment">//将节点存储到容器中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数（除留取余）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">int</span> HashTable&lt;T, U&gt;::hash(<span class="keyword">const</span> T &amp;key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希查找</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">bool</span> HashTable&lt;T, U&gt;::hash_find(<span class="keyword">const</span> T &amp;key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> index = hash(key);<span class="comment">//计算哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec[index].begin(); it != vec[index].end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == it -&gt; _key)<span class="comment">//如果找到则打印其关联值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it-&gt;_value &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出数据前应该确认是否包含相应类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">bool</span> HashTable&lt;T, U&gt;::insert_data(<span class="keyword">const</span> T &amp;key, <span class="keyword">const</span> U &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    HashNode&lt;T, U&gt; node;</span><br><span class="line">    node._key = key;</span><br><span class="line">    node._value = value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashsize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == hash(key))<span class="comment">//如果溢出则把相应的键值添加进链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            vec[i].push_back(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashTable&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ht;</span><br><span class="line">    <span class="keyword">static</span> default_random_engine e;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a = <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; ++i)</span><br><span class="line">        ht.insert_data(i, u(e));</span><br><span class="line">    <span class="keyword">clock_t</span> start_time = clock();</span><br><span class="line">    ht.hash_find(<span class="number">114</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> end_time = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Running time is: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(end_time - start_time) / CLOCKS_PER_SEC * <span class="number">1000</span> &lt;&lt;</span><br><span class="line">        <span class="string">"ms"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出运行时间。</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、unordered_map 与 map 的区别与使用场景</strong></p><ul><li>构造函数<br>unordered_map 需要 hash 函数、等于函数；map 只需要比较函数（小于函数）。</li><li>存储结构<br>unordered_map 采用 hash 表存储，map 一般采用红黑树（RB Tree）实现。因此它们的 memory 数据结构是不一样的。</li></ul><p>总体来说，<code>unordered_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小相关，属于常数级别；而 map 的查找速度是 O(log(n)) 级别，并不一定常数就比 O(log(n)) 小</code>。hash 还有 hash 函数的耗时，如果你考虑效率，<strong>特别是在元素达到一定数量级时，考虑 unordered_map</strong>。但若你对内存使用特别严格，希望程序尽可能少消耗内存，unordered_map 可能会让你陷入尴尬，特别是当你的 unordered_map 对象特别多时，你就更无法控制了，而且 unordered_map 的构造速度较慢。</p><p><strong>4、unordered_map、unordered_set 的常用函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>.begin();<span class="comment">// 返回指向容器起始位置的迭代器（iterator） </span></span><br><span class="line"><span class="built_in">unordered_map</span>.end();<span class="comment">// 返回指向容器末尾位置的迭代器 </span></span><br><span class="line"><span class="built_in">unordered_map</span>.cbegin();<span class="comment">// 返回指向容器起始位置的常迭代器（const_iterator） </span></span><br><span class="line"><span class="built_in">unordered_map</span>.cend();<span class="comment">// 返回指向容器末尾位置的常迭代器 </span></span><br><span class="line"><span class="built_in">unordered_map</span>.size();<span class="comment">// 返回有效元素个数 </span></span><br><span class="line"><span class="built_in">unordered_map</span>.insert(key);<span class="comment">// 插入元素 </span></span><br><span class="line"><span class="built_in">unordered_map</span>.find(key);<span class="comment">// 查找元素，返回迭代器</span></span><br><span class="line"><span class="built_in">unordered_map</span>.count(key);<span class="comment">// 返回匹配给定主键的元素的个数</span></span><br></pre></td></tr></table></figure><h2 id="四、STL-迭代器的底层机制和失效的问题"><a href="#四、STL-迭代器的底层机制和失效的问题" class="headerlink" title="四、STL 迭代器的底层机制和失效的问题"></a>四、STL 迭代器的底层机制和失效的问题</h2><h3 id="迭代器的底层原理"><a href="#迭代器的底层原理" class="headerlink" title="迭代器的底层原理"></a>迭代器的底层原理</h3><p>迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实现包含两个重要的部分：<strong>萃取技术和模板偏特化</strong>。</p><p>萃取技术（traits）可以进行类型推导，根据不同类型可以执行不同的处理流程，比如容器是 vector，那么 traits 必须推导出其迭代器类型为随机访问迭代器，而 list 则为双向迭代器。</p><p>例如 STL 算法库中的 distance 函数，<strong>distance 函数接受两个迭代器参数，然后计算他们两者之间的距离</strong>。显然对于不同的迭代器计算效率差别很大。比如对于 vector 容器来说，<strong>由于内存是连续分配的，因此指针直接相减即可获得两者的距离</strong>；而 list 容器是链式表，<strong>内存一般都不是连续分配，因此只能通过一级一级调用 next() 或其他函数</strong>，每调用一次再判断迭代器是否相等来计算距离。vector 迭代器计算 distance 的效率为 O(1)，而 list 则为 O(n)，n 为距离的大小。</p><p>使用萃取技术（traits）进行类型推导的过程中会使用到模板偏特化。模板偏特化可以用来推导参数，如果我们自定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于是个类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitsHelper</span> &#123;</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> isPointer = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitsHelper</span>&lt;T*&gt; &#123;</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> isPointer = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TraitsHelper&lt;T&gt;::isPointer)</span><br><span class="line">     ...... <span class="comment">// 可以得出当前类型int*为指针类型</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     ...... <span class="comment">// 可以得出当前类型int非指针类型</span></span><br></pre></td></tr></table></figure><h3 id="一个理解-traits-的例子"><a href="#一个理解-traits-的例子" class="headerlink" title="一个理解 traits 的例子"></a>一个理解 traits 的例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要在T为int类型时，Compute方法的参数为int，返回类型也为int，</span></span><br><span class="line"><span class="comment">// 当T为float时，Compute方法的参数为float，返回类型为int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     TraitsHelper&lt;T&gt;::<span class="function">ret_type <span class="title">Compute</span><span class="params">(TraitsHelper&lt;T&gt;::par_type d)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     T mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitsHelper</span> &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> T ret_type;</span><br><span class="line">     <span class="keyword">typedef</span> T par_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板偏特化，处理int类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitsHelper</span>&lt;int&gt; &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">int</span> ret_type;</span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">int</span> par_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板偏特化，处理float类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitsHelper</span>&lt;float&gt; &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">float</span> ret_type;</span><br><span class="line">     <span class="keyword">typedef</span> <span class="keyword">int</span> par_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同时，traits 会是一种很好的解决方案。</p><h3 id="迭代器的种类"><a href="#迭代器的种类" class="headerlink" title="迭代器的种类"></a>迭代器的种类</h3><ul><li><p><strong>输入迭代器</strong>：是只读迭代器，在每个被遍历的位置上只能读取一次。例如上面 find 函数参数就是输入迭代器。</p></li><li><p><strong>输出迭代器</strong>：是只写迭代器，在每个被遍历的位置上只能被写一次。</p></li><li><p><strong>前向迭代器</strong>：兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持 operator–，所以只能向前移动。</p></li><li><p><strong>双向迭代器</strong>：很像前向迭代器，只是它向后移动和向前移动同样容易。</p></li><li><p><strong>随机访问迭代器</strong>：有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置，包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种 Iterator 的所有操作，并另外支持 it + n、it - n、it += n、 it -= n、it1 - it2 和 it[n] 等操作。</p></li></ul><h3 id="迭代器失效的问题"><a href="#迭代器失效的问题" class="headerlink" title="迭代器失效的问题"></a>迭代器失效的问题</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li><p>对于 vector 和 string，如果容器内存被重新分配，iterators、pointers、references 失效；如果没有重新分配，那么插入点之前的iterator 有效，插入点之后的 iterator 失效；</p></li><li><p>对于 deque，如果插入点位于除 front 和 back 的其它位置，iterators、pointers、references 失效；当我们插入元素到 front 和 back 时，deque 的迭代器失效，但 reference 和 pointers 有效；</p></li><li><p>对于 list 和 forward_list，所有的 iterator、pointer 和 refercnce 有效。</p></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li><p>对于 vector 和 string，删除点之前的 iterators、pointers、references 有效；off-the-end 迭代器总是失效的；</p></li><li><p>对于 deque，如果删除点位于除 front 和 back 的其它位置，iterators、pointers、references 失效；当我们插入元素到 front 和 back 时，off-the-end 失效，其他的 iterators、pointers、references 有效；</p></li><li><p>对于 list 和 forward_list，所有的 iterator、pointer 和 refercnce 有效。</p></li><li><p>对于关联容器 map 来说，如果某一个元素已经被删除，那么<strong>其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为</strong>。</p></li></ul><h2 id="五、STL-容器的线程安全性"><a href="#五、STL-容器的线程安全性" class="headerlink" title="五、STL 容器的线程安全性"></a>五、STL 容器的线程安全性</h2><h3 id="5-1、线程安全的情况"><a href="#5-1、线程安全的情况" class="headerlink" title="5.1、线程安全的情况"></a>5.1、线程安全的情况</h3><ul><li><p><strong>多个读取者是安全的</strong>。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器；</p></li><li><p>对不同容器的多个写入者是安全的。多线程可以同时写不同的容器。</p></li></ul><h3 id="5-2、线程不安全的情况"><a href="#5-2、线程不安全的情况" class="headerlink" title="5.2、线程不安全的情况"></a>5.2、线程不安全的情况</h3><ul><li><p>在对同一个容器进行多线程的读写、写操作时；</p></li><li><p>在每次调用容器的成员函数期间都要锁定该容器；</p></li><li><p>在每个容器返回的迭代器（例如通过调用 begin 或 end）的生存期之内都要锁定该容器；</p></li><li><p>在每个在容器上调用的算法执行期间锁定该容器。</p></li></ul><p><strong>参考原文</strong>:<br><a href="https://blog.csdn.net/daaikuaichuan/article/details/80717222">STL详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;STL&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/categories/C/"/>
    
      <category term="STL" scheme="https://www.beyondhxl.com/categories/C/STL/"/>
    
    
      <category term="C++" scheme="https://www.beyondhxl.com/tags/C/"/>
    
      <category term="STL" scheme="https://www.beyondhxl.com/tags/STL/"/>
    
      <category term="vector" scheme="https://www.beyondhxl.com/tags/vector/"/>
    
      <category term="list" scheme="https://www.beyondhxl.com/tags/list/"/>
    
      <category term="map" scheme="https://www.beyondhxl.com/tags/map/"/>
    
      <category term="set" scheme="https://www.beyondhxl.com/tags/set/"/>
    
  </entry>
  
</feed>
